/*
  Some examples are in src/numerical/quadpack.lisp
*/

/* close enough */
(kill(ce), ce(x,y,eps) := is(abs(first(x)-y)<eps),
kill(cec), cec(x,y,eps) := is(abs(realpart(first(x))-realpart(y))
      + abs(imagpart(first(x))-imagpart(y)) < eps), true)$
true;

ce(nintegrate(x^3*log(abs((x^2-1)*(x^2-2))),[x,0,3]), 52.7407484, 1d-7)$
true;

ce(nintegrate(x^3*log(abs((x^2-1)*(x^2-2))),[x,0,3],[1,sqrt(2)]),52.7407483, 1d-7)$
true;

/* quadpack does this without the intermediate points */
ce(nintegrate(x^3*log(abs((x^2-1)*(x^2-2))),[x,0,3]),52.7407483, 1d-6)$
true;

ce(nintegrate(x^2*exp(-4*x), [x, 0, inf]),0.03125, 1d-10)$
true;

ce(nintegrate(sin(sin(x)), [x, 0, 2]), 1.247056058, 1d-8)$
true;

ce(nintegrate(exp(exp(-x)), [x, 0, 5]), 6.31115283, 1e-8)$
true;

ce(nintegrate(x^x, [x, 1, 5]),1241.03328404, 1e-8)$
true;

ce(nintegrate(1/(1+x^2), [x, 0, inf]), 1.570796326794897, 1d-9)$
true;

/* No single quadpack routine will do this. */
ce(nintegrate(1/sqrt(abs(1-x)) * exp(-x),[x,0,inf], [1] ), 1.728208345998, 1d-9)$
true;

/* This looks for the singularity */
ce(nintegrate(1/sqrt(abs(1-x)) * exp(-x),[x,0,inf]), 1.728208345998, 1d-9)$
true;

/* The simplifier removes %i before the routine is called */
ce(nintegrate( cos(%i * x), [x,0,1]), sinh(1.0), 1d-11)$
true;

/* The routine does two real integrals for this example. */
cec(nintegrate(exp(%i*x) * exp(-x*x), [x,0,inf]), .4244363835020222 * %i + .6901942235215709, 1e-8)$
true;

/* Excessive roundoff reported here. Probably for the integral that gives zero */
cec(nintegrate( %i * exp(%i*x)/(1/2 + exp(%i*x)), [x,0,2*%pi]),
    6.28318531*%i-1.05172327e-16, 1e-8)$
true;

/* Singularity at end point */
ce(nintegrate(x^(1/2)*log(1/x), [x, 0, 1]), 4/9, 1e-12)$
true;

ce(nintegrate(1/sqrt(x), [x,0,1]),2,1e-10)$
true;

ce(nintegrate(1/sqrt(1-x), [x,0,1]),2,1e-10)$
true;

ce(nintegrate(1/x^(1/3), [x,0,1]),1.5, 1e-10)$
true;

ce(nintegrate(1/(1-x)^(1/3), [x,0,1]),1.5, 1e-10)$
true;

ce(nintegrate(1/x^(1/5), [x,0,1]),1.25, 1e-10)$
true;

ce(nintegrate(1/(1-x)^(1/5), [x,0,1]),1.25, 1e-10)$
true;

ce(nintegrate(airy_ai(10*log(x)),[x,0,1]), .06392250187680061, 1e-9)$
true;

ce(nintegrate(sin(10^3*sqrt(x)),[x,0,1]),-.001123104393500761, 1e-10)$
true;

ce(nintegrate(log(x),[x,0,1]), -1, 1e-12)$
true;

cec(nintegrate(log(log(x)),[x,0,1]), %pi * %i - .5772156649015613, 1e-10)$
true;

cec(nintegrate(sqrt(log(x)),[x,0,1]), sqrt(%pi)*%i/2, 1e-8)$
true;

ce(nintegrate(log(x)^2,[x,0,1]), 2, 1e-13)$
true;

ce(nintegrate(1/(sqrt(1-x)*x^(1/5)),[x,0,1]), beta(1/2,4/5), 1e-8)$
true;

/* Must explicitly give the roots of sin(x) within integration range */
cec(nintegrate(1/(sqrt(sin(x))),[x,0,10], [%pi,2*%pi,3*%pi]),
     10.48823021716687 - 6.769465521725385 * %i, 1e-7)$
true;   

/* Mma docs supply singular points. We don't need to do this
   nintegrate(sqrt(log(x-7)),[x,0,20], [7,8]);
   NIntegrate[Sqrt[Log[x - 7]], {x, 0, 20}, Exclusions -> {7, 8}]    
*/   
cec(nintegrate(sqrt(log(x-7)),[x,0,20], epsrel->1e-10),
   rectform(float(rectform(integrate(sqrt(log(x-7)),x,0,20)))), 1e-10)$
true;

/* This works well, but needs extra subintervals
  first(nintegrate(exp(%i*x),[x,1,10^4], subint -> 3000)) -
     rectform(float(integrate(exp(%i*x),x,1,10^4)));
     2.247091401841317e-13 %i + 2.675637489346627e-13
*/     

cec(nintegrate(exp(%i*x),[x,1,10^4], subint -> 3000),rectform(float(integrate(exp(%i*x),x,1,10^4))),1e-12)$
true;

/* This is ok, but slow
  first(nintegrate(1/sqrt(x) + cos(x), [x,0,5000], subint->1000)) -
     float(integrate(1/sqrt(x) + cos(x), x,0,5000));
*/
ce(nintegrate(1/sqrt(x) + cos(x), [x,0,5000], subint->1000),
   float(integrate(1/sqrt(x) + cos(x), x,0,5000)), 1e-12)$
true; 

/*
 Might be better to use quadpack function with factor of sin(x), but
 we would need to detect it.
*/ 
ce(nintegrate(sin(x)/sqrt(x),[x,0,5000],subint->1000),rectform(float(integrate(sin(x)/sqrt(x),x,0,5000))),
    1e-7)$
true;  

kill(ce)$
done;

/*

Look at, or include these from Mma docs.

This does not work with infinite range.
nintegrate(bessel_j(1,x),[x,1,inf],subint->10000);
This gets there, but very slowly
nintegrate(bessel_j(1,x),[x,1,30000],subint->10000);

nintegrate(bessel_j(2,sqrt(2)*x)^2,[x,1,10^4],subint->10000);

Converges too slowly
nintegrate(sin(1/((5*x-1)*(5*x-2)*(5*x-3))),[x,0,1], subint->10000);

This is worse
nintegrate(sin(1/((5*x-1)*(5*x-2)*(5*x-3))),[x,0,1], [1/5,2/5,3/5],  subint->10000);

Converges slowly
nintegrate(sin(1/x)*cos(1/(1-x)),[x,0,1],subint->10000);

This says OK, but it is not efficient
nintegrate(sin(1/x)*cos(1/(1-x)),[x,0,1],subint->20000, epsrel->1e-6);

*/


/* We cannot do these:

  quad_qag(cos(log(x)/x)/x, x,0,1,6); fails
  nintegrate(cos(log(x)/x)/x,  [x,0,1]);

  nintegrate(exp(%i*x*x),[x,minf,inf]); fails

  The error estimates given here are too low, I think.
   No , maybe not too low.
  nintegrate(exp(%i*x*x),[x,-200,200],subint->10000);
  [1.25170114 %i + 1.25804682, 2.507635982e-8, 760578, no problems]


*/
