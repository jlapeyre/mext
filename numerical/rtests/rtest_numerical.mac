/*
  Some examples are in src/numerical/slatec/quadpack.lisp
*/

/* Test 1 */
/* close enough tests */
(kill(ce), ce(x,y,eps) := is(abs(first(x)-y)<eps),
kill(cec), cec(x,y,eps) := is(abs(realpart(first(x))-realpart(y))
      + abs(imagpart(first(x))-imagpart(y)) < eps), true)$
true;


/* Test 2 */
ce(nintegrate(x^3*log(abs((x^2-1)*(x^2-2))),[x,0,3]), 52.7407484, 1d-7)$
true;

/* Test 3 */
ce(nintegrate(x^3*log(abs((x^2-1)*(x^2-2))),[x,0,3],[1,sqrt(2)]),52.7407483, 1d-7)$
true;

/* Test 4 */
/* quadpack does this without the intermediate points */
ce(nintegrate(x^3*log(abs((x^2-1)*(x^2-2))),[x,0,3]),52.7407483, 1d-6)$
true;

/* Test 5 */
ce(nintegrate(x^2*exp(-4*x), [x, 0, inf]),0.03125, 1d-10)$
true;

/* Test 6 */
ce(nintegrate(sin(sin(x)), [x, 0, 2]), 1.247056058, 1d-8)$
true;

/* Test 7 */
ce(nintegrate(exp(exp(-x)), [x, 0, 5]), 6.31115283, 1e-8)$
true;

/* Test 8 */
ce(nintegrate(x^x, [x, 1, 5]),1241.03328404, 1e-8)$
true;

/* Test 9 */
ce(nintegrate(1/(1+x^2), [x, 0, inf]), 1.570796326794897, 1d-9)$
true;

/* Test 10 */
/* No single quadpack routine will do this. */
ce(nintegrate(1/sqrt(abs(1-x)) * exp(-x),[x,0,inf], [1] ), 1.728208345998, 1d-9)$
true;

/* Test 11 */
/* Test that singularties are found and are included or not depending on limits. */
/* include x=1 */
ce(nintegrate(1/sqrt(abs(1-x)) * exp(-x),[x,0,inf]), 1.728208345998, 1d-9)$
true;

/* Test 12 */
/* Find, but don't use x=1 */
ce(nintegrate(1/sqrt(abs(1-x)) * exp(x),[x,minf,0]),0.757872156141312, 1e-7)$
true;

/* Test 13 */
/* Find and use x=-1 */
ce(nintegrate(1/sqrt(abs(1+x)) * exp(x),[x,minf,0]),1.728208345998552, 1e-7)$
true;

/* Test 14 */
/* Find, but don't use x=-1 */
ce(nintegrate(1/sqrt(abs(1+x)) * exp(-x),[x,0,inf]),0.757872156141312, 1e-7)$
true;

/* Test 15 */
/* Two sing. outside of region */
ce(nintegrate( 1/((x-3)*(x-6)) , [x,4,5]), -2*log(2)/3, 1e-10)$
true;

/* Test 16 */
/* The simplifier removes %i before the routine is called */
ce(nintegrate( cos(%i * x), [x,0,1]), sinh(1.0), 1d-11)$
true;

/* Test 17 */
/* The routine does two real integrals for this example. */
cec(nintegrate(exp(%i*x) * exp(-x*x), [x,0,inf]), .4244363835020222 * %i + .6901942235215709, 1e-8)$
true;

/*
  Excessive roundoff reported here. Probably for the integral that gives zero

  Note that:
  integrate( %i * exp(%i*x)/(1/2 + exp(%i*x)), x,0,2*%pi) --> 0
  
*/
/* Test 18 */
cec(nintegrate( %i * exp(%i*x)/(1/2 + exp(%i*x)), [x,0,2*%pi]), %i * 2 * %pi, 1e-8)$
true;

/* Test 19 */
/* Singularity at end point */
ce(nintegrate(x^(1/2)*log(1/x), [x, 0, 1]), 4/9, 1e-12)$
true;

/* Test 20 */
ce(nintegrate(1/sqrt(x), [x,0,1]),2,1e-10)$
true;

/* Test 21 */
ce(nintegrate(1/sqrt(1-x), [x,0,1]),2,1e-10)$
true;

/* Test 22 */
ce(nintegrate(1/x^(1/3), [x,0,1]),1.5, 1e-10)$
true;

/* Test 23 */
ce(nintegrate(1/(1-x)^(1/3), [x,0,1]),1.5, 1e-10)$
true;

/* Test 24 */
ce(nintegrate(1/x^(1/5), [x,0,1]),1.25, 1e-10)$
true;

/* Test 25 */
ce(nintegrate(1/(1-x)^(1/5), [x,0,1]),1.25, 1e-10)$
true;

/* Test 26 */
ce(nintegrate(1/x^(4/5), [x,0,1]),5, 1e-10)$
true;

/* Test 27 */
ce(nintegrate(airy_ai(10*log(x)),[x,0,1]), .06392250187680061, 1e-9)$
true;

/* Test 28 */
ce(nintegrate(sin(10^3*sqrt(x)),[x,0,1]),-.001123104393500761, 1e-10)$
true;

/* Test 29 */
ce(nintegrate(log(x),[x,0,1]), -1, 1e-12)$
true;

/* Test 30 */
cec(nintegrate(log(log(x)),[x,0,1]), %pi * %i - .5772156649015613, 1e-10)$
true;

/* Test 31 */
cec(nintegrate(sqrt(log(x)),[x,0,1]), sqrt(%pi)*%i/2, 1e-8)$
true;

/* Test 32 */
ce(nintegrate(log(x)^2,[x,0,1]), 2, 1e-13)$
true;

/* Test 33 */
ce(nintegrate(1/(sqrt(1-x)*x^(1/5)),[x,0,1]), beta(1/2,4/5), 1e-8)$
true;

/* Test 34 */
ce(nintegrate(1/(sqrt(1-x)*x^(4/5)),[x,0,1]), beta(1/5,1/2), 1e-8)$
true;

/* Test 35 */
ce(nintegrate(log(2*x)/sqrt(1-x),[x,0,1]), 6 * log(2) - 4, 1e-8)$
true;


/*
  Must explicitly give the roots of sin(x) within integration range
  Omitting the singularities still works, but with reduced accuracy
  and warnings.
  But, with to_poly_solve and a little more work, we could compute these
  roots automatically.
*/
/* Test 36 */
cec(nintegrate(1/(sqrt(sin(x))),[x,0,10], [%pi,2*%pi,3*%pi]),
     10.48823021716687 - 6.769465521725385 * %i, 1e-7)$
true;   

/* Test 37 */
/* Example in Mma docs supplies singular points. We don't need to do this.
   nintegrate(sqrt(log(x-7)),[x,0,20], [7,8]);
   NIntegrate[Sqrt[Log[x - 7]], {x, 0, 20}, Exclusions -> {7, 8}]    
*/   
cec(nintegrate(sqrt(log(x-7)),[x,0,20], epsrel->1e-10),
   rectform(float(rectform(integrate(sqrt(log(x-7)),x,0,20)))), 1e-10)$
true;

/*
  This works well, but needs extra subintervals
  first(nintegrate(exp(%i*x),[x,1,10^4], subint -> 3000)) -
     rectform(float(integrate(exp(%i*x),x,1,10^4)));
     2.247091401841317e-13 %i + 2.675637489346627e-13

  A better method for this would be good.
  In fact quad_qawo(1, x, 1, 10^4, 1, cos) works well. Faster, with fewer intervals
  and no error. We could try to detect this somehow.
*/     
/* Test 38 */
cec(nintegrate(exp(%i*x),[x,1,10^4], subint -> 3000),rectform(float(integrate(exp(%i*x),x,1,10^4))),1e-12)$
true;

/* This is ok, but slow
  first(nintegrate(1/sqrt(x) + cos(x), [x,0,5000], subint->1000)) -
     float(integrate(1/sqrt(x) + cos(x), x,0,5000));

  What would work: integrate each term, using qawo on the cosine part.
  (I wonder when we are allowed to use symbolic integration, anyway)
  quad_qawo(1, x, 0, 5000, 1, cos, epsrel=1e-9); This essentially does
  analytic integration, anyway.

*/

/* Test 39 */
ce(nintegrate(1/sqrt(x) + cos(x), [x,0,5000], subint->1000),
   float(integrate(1/sqrt(x) + cos(x), x,0,5000)), 1e-12)$
true; 

/*
 Following works, but it is slow.

Correct result is:
(sqrt(%pi) ((sqrt(2) %i + sqrt(2)) erf(50 %i + 50)
 + (sqrt(2) %i - sqrt(2)) erf(50 %i - 50)))/4

 = 1.251128192999533

Following is much faster, but the routine does not allow us to go too close to 0.
quad_qawo (1/sqrt(x), x, 1e-12, 5000, 1, sin, epsrel=1e-13);

We would have to split the interval and integrate from, say 0 to 1
and then 1 to 5000.
 
*/

/* Test 40 */
ce(nintegrate(sin(x)/sqrt(x),[x,0,5000],subint->1000),rectform(float(integrate(sin(x)/sqrt(x),x,0,5000))),
    1e-7)$
true;  

/* Test 41 */
kill(ce)$
done;

/*

Look at, or include these from Mma docs.

This does not work with infinite range.
nintegrate(bessel_j(1,x),[x,1,inf],subint->10000);
This gets there, but very slowly
nintegrate(bessel_j(1,x),[x,1,30000],subint->10000);

nintegrate(bessel_j(2,sqrt(2)*x)^2,[x,1,10^4],subint->10000);

Converges too slowly
nintegrate(sin(1/((5*x-1)*(5*x-2)*(5*x-3))),[x,0,1], subint->10000);

This is worse
nintegrate(sin(1/((5*x-1)*(5*x-2)*(5*x-3))),[x,0,1], [1/5,2/5,3/5],  subint->10000);

Converges slowly
nintegrate(sin(1/x)*cos(1/(1-x)),[x,0,1],subint->10000);

This says OK, but it is not efficient
nintegrate(sin(1/x)*cos(1/(1-x)),[x,0,1],subint->20000, epsrel->1e-6);

*/


/* We cannot do these:

  quad_qag(cos(log(x)/x)/x, x,0,1,6); fails
  nintegrate(cos(log(x)/x)/x,  [x,0,1]);

  Can do this transformation, but I am not sure how it helps
  nintegrate( cos(-u*log(u))/(u), [u,1,1000], subint->1000);

  ---------

  nintegrate(exp(%i*x*x),[x,minf,inf]); fails

  The error estimates given here are too low, I think.
   No , maybe not too low.
  nintegrate(exp(%i*x*x),[x,-200,200],subint->10000);
  [1.25170114 %i + 1.25804682, 2.507635982e-8, 760578, no problems]

  integrate(cos(x*x),x) =
    -sqrt(%pi)*((sqrt(2)*%i-sqrt(2))*erf((sqrt(2)*%i+sqrt(2))*x/2)
                  +(sqrt(2)*%i+sqrt(2))*erf((sqrt(2)*%i-sqrt(2))*x/2))

  integrate(cos(x*x),x,minf,inf) = sqrt(%pi)/sqrt(2) = 1.2533141373155

  Maybe handle this by susbstituting  u = x^2, then
  using qawo.

  cos(x^2) dx --> cos(u)/sqrt(u) .

  Not easy, qaqwo still has problems.

*/
