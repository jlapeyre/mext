<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Third-party maxima software
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea ./thirdparty.tex -->
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Third-party maxima software</H1><H3 CLASS="titlerest">John Lapeyre</H3></TD></TR>
</TABLE><!--TOC section Contents-->
<H2 CLASS="section"><!--SEC ANCHOR -->Contents</H2><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">1  Array Representation For Expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc2">2  Attributes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">2.1  Function: attributes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">2.2  Function: attributes_find</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">2.3  Function: set_match_form</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">2.4  Function: set_nowarn</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">2.5  Function: unset_match_form</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">2.6  Function: unset_nowarn</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">3  Functions and Variables for Array Represention for Expressions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc10">3.1  Function: aeop</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">3.2  Function: aex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">3.3  Function: aex_cp</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">3.4  Function: aex_get</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">3.5  Function: aex_new</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">3.6  Function: aex_set</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">3.7  Function: aex_shift</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">3.8  Function: aex_unshift</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">3.9  Function: aexg</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">3.10  Function: aexs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">3.11  Function: copy_aex_type</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">3.12  Function: deep_copy</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">3.13  Function: faex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">3.14  Function: flex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">3.15  Function: iapply</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">3.16  Function: iargs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">3.17  Function: ilength</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">3.18  Function: iop</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">3.19  Function: ipart</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">3.20  Function: ipart_set</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">3.21  Function: ireverse</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">3.22  Function: lex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">3.23  Function: raex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">3.24  Function: rlex</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">4  Functions and Variables for Combinatorics</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc35">4.1  Function: ae_random_permutation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">4.2  Function: cycles_to_perm</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">4.3  Function: inverse_permutation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">4.4  Function: perm_to_cycles</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">4.5  Function: perm_to_transpositions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">4.6  Function: permutation_p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">4.7  Function: permutation_p1</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">4.8  Function: random_cycle</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">4.9  Function: random_permutation_sym</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">4.10  Function: signature_permutation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">4.11  Function: transpositions_to_perm</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">5  Functions and Variables for Documentation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc47">5.1  Variable: doc_system_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">5.2  Function: doc_system_set</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc49">5.3  Variable: error_code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">5.4  Function: maxdoc</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">5.5  Function: maxdoc_author</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc52">5.6  Function: maxdoc_copyright</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">5.7  Function: maxdoc_examples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">5.8  Function: maxdoc_set_cur_sec</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">5.9  Function: maxdoc_set_mext_package</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">5.10  Function: maxdoc_split_text</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">5.11  Function: mext_package_record</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">5.12  Variable: pager_command</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">5.13  Variable: print_authors</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">5.14  Variable: print_copyrights</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">5.15  Function: print_entry_latex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">5.16  Variable: print_implementation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">5.17  Function: print_maxdoc_entry</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">5.18  Function: print_maxdoc_sections</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">5.19  Function: print_sections_latex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">5.20  Variable: read_docs_with_pager</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">5.21  Function: simple_doc_add</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">5.22  Function: simple_doc_delete</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">5.23  Function: simple_doc_get</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc70">5.24  Function: simple_doc_init</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">5.25  Function: simple_doc_print</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">6  Functions and Variables for Equations</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc73">6.1  Function: alt_eigen</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc74">6.2  Function: nelder_mead</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">6.3  Function: to_poly_clean</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">7  Functions and Variables for Function Definition</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc77">7.1  Function: comp_load</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">7.2  Function: compile_file1</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">8  Functions and Variables for Input and Output</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc80">8.1  Function: pager_string</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">8.2  Function: restore</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">8.3  Function: restore_fast</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">8.4  Function: store</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">8.5  Function: store_fast</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">9  Functions and Variables for Lists</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc86">9.1  Function: aelistp</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">9.2  Function: constant_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc88">9.3  Function: count</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">9.4  Function: drop_while</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">9.5  Function: every1</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">9.6  Function: fold</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">9.7  Function: fold_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc93">9.8  Function: icons</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">9.9  Function: imap</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">9.10  Function: length_while</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">9.11  Function: lrange</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">9.12  Function: nest</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">9.13  Function: nest_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">9.14  Function: nest_while</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc100">9.15  Function: nreverse</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">9.16  Function: partition_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">9.17  Function: select</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">9.18  Argument type: sequence specifier</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc104">9.19  Function: table</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">9.20  Function: take</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">9.21  Function: take_while</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">9.22  Function: tuples</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">10  Functions and Variables for Number Theory</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc109">10.1  Function: abundant_p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">10.2  Function: aliquot_sequence</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">10.3  Function: aliquot_sum</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">10.4  Function: amicable_p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">10.5  Function: catalan_number</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc114">10.6  Function: divisor_function</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc115">10.7  Function: divisor_summatory</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc116">10.8  Function: from_digits</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">10.9  Function: integer_digits</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">10.10  Function: integer_string</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc119">10.11  Function: oeis_A092143</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc120">10.12  Function: perfect_p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc121">10.13  Function: prime_pi</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">10.14  Function: prime_pi_soe</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">10.15  Function: prime_twins</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc124">10.16  Function: primes1</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">11  Functions and Variables for Numerical Computation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc126">11.1  Function: mquad_qag</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc127">11.2  Function: mquad_qagi</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc128">11.3  Function: mquad_qagp</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">11.4  Function: mquad_qags</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc130">11.5  Function: mquad_qawc</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc131">11.6  Function: mquad_qawf</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc132">11.7  Function: mquad_qawo</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc133">11.8  Function: mquad_qaws</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc134">11.9  Function: n_abs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc135">11.10  Function: n_acos</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc136">11.11  Function: n_acosh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc137">11.12  Function: n_asin</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc138">11.13  Function: n_asinh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc139">11.14  Function: n_atan</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc140">11.15  Function: n_atanh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc141">11.16  Function: n_cos</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc142">11.17  Function: n_cosh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc143">11.18  Function: n_exp</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc144">11.19  Function: n_expt</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc145">11.20  Function: n_log</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc146">11.21  Function: n_sin</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc147">11.22  Function: n_sinh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc148">11.23  Function: n_sqrt</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc149">11.24  Function: n_tan</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc150">11.25  Function: n_tanh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc151">11.26  Function: nintegrate</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc152">12  Functions and Variables for Numerics</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc153">13  Functions and Variables for Predicates</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc154">13.1  Function: aex_p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc155">13.2  Function: cmplength</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc156">13.3  Function: length0p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc157">13.4  Function: length1p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc158">13.5  Function: length_eq</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc159">13.6  Function: type_of</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc160">14  Functions and Variables for Program Flow</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc161">14.1  Function: error_str</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc162">15  Functions and Variables for Quicklisp</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc163">15.1  Function: quicklisp_apropos</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc164">15.2  Function: quicklisp_install</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc165">15.3  Function: quicklisp_load</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc166">15.4  Function: quicklisp_start</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc167">16  Functions and Variables for Runtime Environment</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc168">16.1  Function: allow_kill</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc169">16.2  Function: allow_kill_share</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc170">16.3  Function: chdir</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc171">16.4  Function: dir_exists</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc172">16.5  Function: dirstack</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc173">16.6  Function: dont_kill</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc174">16.7  Function: dont_kill_share</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc175">16.8  Function: get_dont_kill</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc176">16.9  Variable: homedir</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc177">16.10  Variable: lisp_bin_ext</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc178">16.11  Variable: lisp_type</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc179">16.12  Function: lisp_type_symbol</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc180">16.13  Variable: lisp_version</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc181">16.14  Function: list_directory</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc182">16.15  Variable: maxima_version</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc183">16.16  Function: mcompile_file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc184">16.17  Function: mext_clear</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc185">16.18  Function: mext_find_package</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc186">16.19  Function: mext_info</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc187">16.20  Function: mext_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc188">16.21  Function: mext_list_loaded</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc189">16.22  Function: mext_list_package</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc190">16.23  Function: mext_test</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc191">16.24  Variable: mext_verbose</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc192">16.25  Function: mtranslate_file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc193">16.26  Function: popdir</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc194">16.27  Function: probe_file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc195">16.28  Function: pwd</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc196">16.29  Function: require</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc197">16.30  Function: timing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc198">16.31  Function: truename</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc199">16.32  Function: updir</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc200">17  Functions and Variables for Strings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc201">17.1  Function: string_drop</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc202">17.2  Function: string_reverse</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc203">17.3  Function: string_take</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc204">17.4  Function: with_output_to_string</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc205">18  Miscellaneous Functions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc206">18.1  Function: examples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc207">18.2  Function: examples_add</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc208">19  Miscellaneous utilities</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc209">19.1  Variable: compile_lambda_verbose</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc210">20  Options</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc211">20.1  Option: adj</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc212">20.2  Option: compile</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc213">20.3  Function: foptions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc214">20.4  Option: ot</A>
</LI></UL>
</LI></UL><!--TOC section Array Representation For Expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>  Array Representation For Expressions</H2><!--SEC END --><P>Maxima expressions are normally implemented internally as lisp lists,
but they may also be represented by lisp arrays. Each representation has
advantages.
</P><!--TOC section Attributes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>  Attributes</H2><!--SEC END --><P>A function may possess a list of attributes. The attributes control how the arguments
to the function are evaluated and how errors are handled.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#attributes"><TT>attributes</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#attributes_find"><TT>attributes_find</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#set_match_form"><TT>set_match_form</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#set_nowarn"><TT>set_nowarn</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#unset_match_form"><TT>unset_match_form</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>
</LI></UL><!--TOC subsection Function: attributes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">2.1</A>  Function: attributes<A NAME="sec:attributes"></A></H3><!--SEC END --><P>
<A NAME="attributes"></A>
<B>attributes</B>(<I>name</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Returns a list of the ‘attributes’ of function <I>name</I>.</P><P><B>Arguments</B>
<TT>attributes</TT> requires one argument <I>name</I>, which must be a string or a symbol.</P><P><B>See also</B>
<A HREF="#unset_match_form"><TT>unset_match_form</TT></A>, <A HREF="#set_match_form"><TT>set_match_form</TT></A>, <A HREF="#set_nowarn"><TT>set_nowarn</TT></A>, and <A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>.</P><!--TOC subsection Function: attributes_find-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">2.2</A>  Function: attributes_find<A NAME="sec:attributes_find"></A></H3><!--SEC END --><P>
<A NAME="attributes_find"></A>
<B>attributes_find</B>( :optional <I>attribute</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Return a list of all functions for which the attribute <I>attribute</I> is set. Some attributes are <I>match_form</I>,<I>hold_all</I>, and <I>nowarn</I>.</P><P><B>Arguments</B>
<TT>attributes_find</TT> requires either zero or one arguments. If present, the argument <I>attribute</I> must be a a string or a symbol.</P><!--TOC subsection Function: set_match_form-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">2.3</A>  Function: set_match_form<A NAME="sec:set_match_form"></A></H3><!--SEC END --><P>
<A NAME="set_match_form"></A>
<B>set_match_form</B>(<I>names</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Set the ‘match_form’ attribute for function(s) <I>names</I>. If the argument checks for a function call fail, and the attribute ‘match_form’ is set, then rather than signaling an error, the unevaluated form is returned. Furthemore, if the attribute ‘nowarn’ is not set, then a warning message is 
printed. Currently, only automatic argument checks generated from the defmfun1 protocol are controlled. Argument checks and errors written within the body of the functions occur regardless of function attributes.</P><P><B>Arguments</B>
<TT>set_match_form</TT> requires one argument <I>names</I>, which must be a string, a symbol, or a list of strings or symbols.</P><P><B>See also</B>
<A HREF="#unset_match_form"><TT>unset_match_form</TT></A>, <A HREF="#set_nowarn"><TT>set_nowarn</TT></A>, <A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>, and <A HREF="#attributes"><TT>attributes</TT></A>.</P><!--TOC subsection Function: set_nowarn-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc6">2.4</A>  Function: set_nowarn<A NAME="sec:set_nowarn"></A></H3><!--SEC END --><P>
<A NAME="set_nowarn"></A>
<B>set_nowarn</B>(<I>names</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Set the ‘nowarn’ attribute for function(s) <I>names</I>. If the argument checks for a function call fail, and the attribute ‘match_form’ is set, and the attribute ‘nowarn’ is set, then rather than signaling an error, the unevaluated form is returned and no warning message is printed.</P><P><B>Arguments</B>
<TT>set_nowarn</TT> requires one argument <I>names</I>, which must be a string, a symbol, or a list of strings or symbols.</P><P><B>See also</B>
<A HREF="#unset_match_form"><TT>unset_match_form</TT></A>, <A HREF="#set_match_form"><TT>set_match_form</TT></A>, <A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>, and <A HREF="#attributes"><TT>attributes</TT></A>.</P><!--TOC subsection Function: unset_match_form-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">2.5</A>  Function: unset_match_form<A NAME="sec:unset_match_form"></A></H3><!--SEC END --><P>
<A NAME="unset_match_form"></A>
<B>unset_match_form</B>(<I>names</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Unset the ‘match_form’ attribute for function(s) <I>names</I>. If the argument checks for a function call fail, and the attribute ‘match_form’ is set, then rather than signaling an error, the unevaluated form is returned. Furthemore, if the attribute ‘nowarn’ is not set, then a warning message is 
printed. Currently, only automatic argument checks generated from the defmfun1 protocol are controlled. Argument checks and errors written within the body of the functions occur regardless of function attributes.</P><P><B>Arguments</B>
<TT>unset_match_form</TT> requires one argument <I>names</I>, which must be a string, a symbol, or a list of strings or symbols.</P><P><B>See also</B>
<A HREF="#set_match_form"><TT>set_match_form</TT></A>, <A HREF="#set_nowarn"><TT>set_nowarn</TT></A>, <A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>, and <A HREF="#attributes"><TT>attributes</TT></A>.</P><!--TOC subsection Function: unset_nowarn-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc8">2.6</A>  Function: unset_nowarn<A NAME="sec:unset_nowarn"></A></H3><!--SEC END --><P>
<A NAME="unset_nowarn"></A>
<B>unset_nowarn</B>(<I>names</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Unset the ‘nowarn’ attribute for function(s) <I>names</I>. If the argument checks for a function call fail, and the attribute ‘match_form’ is set, and the attribute ‘nowarn’ is set, then rather than signaling an error, the unevaluated form is returned and no warning message is printed.</P><P><B>Arguments</B>
<TT>unset_nowarn</TT> requires one argument <I>names</I>, which must be a string, a symbol, or a list of strings or symbols.</P><P><B>See also</B>
<A HREF="#unset_match_form"><TT>unset_match_form</TT></A>, <A HREF="#set_match_form"><TT>set_match_form</TT></A>, <A HREF="#set_nowarn"><TT>set_nowarn</TT></A>, and <A HREF="#attributes"><TT>attributes</TT></A>.</P><!--TOC section Functions and Variables for Array Represention for Expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">3</A>  Functions and Variables for Array Represention for Expressions</H2><!--SEC END --><P>These functions operate on the the array expression data structure.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#aeop"><TT>aeop</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex"><TT>aex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_cp"><TT>aex_cp</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_get"><TT>aex_get</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_new"><TT>aex_new</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_set"><TT>aex_set</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_shift"><TT>aex_shift</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_unshift"><TT>aex_unshift</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aexg"><TT>aexg</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aexs"><TT>aexs</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#copy_aex_type"><TT>copy_aex_type</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#deep_copy"><TT>deep_copy</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#faex"><TT>faex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#flex"><TT>flex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#iapply"><TT>iapply</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#iargs"><TT>iargs</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ilength"><TT>ilength</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#iop"><TT>iop</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ipart"><TT>ipart</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ipart_set"><TT>ipart_set</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ireverse"><TT>ireverse</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#lex"><TT>lex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#raex"><TT>raex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#rlex"><TT>rlex</TT></A>
</LI></UL><!--TOC subsection Function: aeop-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc10">3.1</A>  Function: aeop<A NAME="sec:aeop"></A></H3><!--SEC END --><P>
<A NAME="aeop"></A>
<B>aeop</B>(<I>expr</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
op function for aex. returns op if <I>e</I> is not an aex.</P><P><B>Arguments</B>
<TT>aeop</TT> requires one argument <I>expr</I>, which must be non-atomic.</P><!--TOC subsection Function: aex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">3.2</A>  Function: aex<A NAME="sec:aex"></A></H3><!--SEC END --><P>
<A NAME="aex"></A>
<B>aex</B>( :optional <I>x</I>)</P><P>mext package: aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>aex</B>(<I>e</I>)
Converts expression <I>e</I> to an array representation. The input expression <I>e</I> is returned unchanged if it is already an array expression or is a symbol or number or specially represented maxima expression. This function converts only at the first level.</LI></UL><P>
<B>Arguments</B>
<TT>aex</TT> requires either zero or one arguments.</P><P><B>Options</B>
<TT>aex</TT> takes options with default values: <TT>adj-&gt;true</TT>.
</P><!--TOC subsection Function: aex_cp-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">3.3</A>  Function: aex_cp<A NAME="sec:aex_cp"></A></H3><!--SEC END --><P>
<A NAME="aex_cp"></A>
<B>aex_cp</B>(<I>e</I> :optional <I>head</I>)</P><P>mext package: aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>aex_cp</B>(<I>e</I>)
Returns an aex form copy of <I>e</I>. <I>e</I> may be in either lex or aex form. Conversion to aex representation occurs only on the first level.</LI></UL><P>
<B>Arguments</B>
<TT>aex_cp</TT> requires either one or two arguments.
The first argument <I>e</I> must be non-atomic.</P><P><B>Options</B>
<TT>aex_cp</TT> takes options with default values: <TT>adj-&gt;true</TT>.
</P><!--TOC subsection Function: aex_get-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">3.4</A>  Function: aex_get<A NAME="sec:aex_get"></A></H3><!--SEC END --><P>
<A NAME="aex_get"></A></P><P>mext package: aex</P><P>
<B>Description</B>
Returns the <I>n-1</I>th part of aexpr <I>e</I>. A value of <I>n</I> less than 0 is not allowed. This is more efficient than <A HREF="#aexg"><TT>aexg</TT></A>, which returns the head of the expression when <I>n</I> is equal to zero.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : aex([5,6,7]), aex_get(a,2);
(%o1) 7
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: aex_new-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">3.5</A>  Function: aex_new<A NAME="sec:aex_new"></A></H3><!--SEC END --><P>
<A NAME="aex_new"></A>
<B>aex_new</B>(<I>n</I> :optional <I>head</I>)</P><P>mext package: aex</P><P>
<B>Arguments</B>
<TT>aex_new</TT> requires either one or two arguments.
The first argument <I>n</I> must be a non-negative integer.</P><!--TOC subsection Function: aex_set-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc15">3.6</A>  Function: aex_set<A NAME="sec:aex_set"></A></H3><!--SEC END --><P>
<A NAME="aex_set"></A></P><P>mext package: aex</P><P>
<B>Description</B>
Destructively sets the <I>n</I>th part of aexpr <I>e</I> to value <I>v</I>. A value of 0 for <I>n</I> is not allowed. This is more efficient than <A HREF="#aexs"><TT>aexs</TT></A>. No argument checking is done.</P><P><B>Examples</B></P><P>Destructively assign to a part of an expression.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : aex([1,2,3]), aex_set(a,1,x), a;
(%o1) &lt;[1,x,3]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#aexs"><TT>aexs</TT></A> and <A HREF="#ipart"><TT>ipart</TT></A>.</P><!--TOC subsection Function: aex_shift-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc16">3.7</A>  Function: aex_shift<A NAME="sec:aex_shift"></A></H3><!--SEC END --><P>
<A NAME="aex_shift"></A>
<B>aex_shift</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
destructively removes an element from the end of <I>e</I>. For array representation of expressions we use the words ‘push’ and ‘pop’ for the beginning of and expression, and ‘shift’ and ‘unshift’ for the end of an expression, whether the representation is an array or a list. This is consistent with 
maxima, but the reverse of the meaning of the terms in perl.</P><P><B>Arguments</B>
<TT>aex_shift</TT> requires one argument <I>e</I>, which must be an adjustable array expression.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : lrange(10,ot-&gt;ar);
(%o1) &lt;[1,2,3,4,5,6,7,8,9,10]&gt;
(%i1) b : aex_shift(a);
(%o1) 10
(%i2) a;
(%o2) &lt;[1,2,3,4,5,6,7,8,9]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: aex_unshift-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc17">3.8</A>  Function: aex_unshift<A NAME="sec:aex_unshift"></A></H3><!--SEC END --><P>
<A NAME="aex_unshift"></A>
<B>aex_unshift</B>(<I>v</I>, <I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Destructively pushes an element <I>v</I> onto the end of <I>e</I>. The return value is <I>v</I>. For array representation of expressions we use the words ‘push’ and ‘pop’ for the beginning of and expression, and ‘shift’ and ‘unshift’ for the end of an expression, whether the representation is an array 
or a list. This is consistent with maxima, but the reverse of the meaning of the terms in perl.</P><P><B>Arguments</B>
<TT>aex_unshift</TT> requires two arguments.
The second argument <I>e</I> must be an adjustable array expression.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : lrange(10,ot-&gt;ar), aex_unshift("dog",a), a;
(%o1) &lt;[1,2,3,4,5,6,7,8,9,10,"dog"]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: aexg-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">3.9</A>  Function: aexg<A NAME="sec:aexg"></A></H3><!--SEC END --><P>
<A NAME="aexg"></A></P><P>mext package: aex</P><P>
<B>Description</B>
aexg(e,n) returns the nth part of aexpr e. If n is 0, the head of e is returned. No argument checking is performed.</P><P><B>See also</B>
<A HREF="#aex_get"><TT>aex_get</TT></A>, <A HREF="#ipart"><TT>ipart</TT></A>, <A HREF="#inpart"><TT>inpart</TT></A>, and <A HREF="#part"><TT>part</TT></A>.</P><!--TOC subsection Function: aexs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc19">3.10</A>  Function: aexs<A NAME="sec:aexs"></A></H3><!--SEC END --><P>
<A NAME="aexs"></A></P><P>mext package: aex</P><P>
<B>Description</B>
destructively sets the <I>n</I>th part of aexpr <I>e</I> to value <I>v</I>. A value of 0 for <I>n</I> returns the head (or op) of <I>e</I>.</P><!--TOC subsection Function: copy_aex_type-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">3.11</A>  Function: copy_aex_type<A NAME="sec:copy_aex_type"></A></H3><!--SEC END --><P>
<A NAME="copy_aex_type"></A>
<B>copy_aex_type</B>(<I>ein</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Create a new aex with same head,length,adjustability,etc. but contents of expression are not copied.</P><P><B>Arguments</B>
<TT>copy_aex_type</TT> requires one argument <I>ein</I>, which must be an array-representation expression.</P><!--TOC subsection Function: deep_copy-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc21">3.12</A>  Function: deep_copy<A NAME="sec:deep_copy"></A></H3><!--SEC END --><P>
<A NAME="deep_copy"></A>
<B>deep_copy</B>(<I>expr</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Note: it appears that the core maxima function <TT>copy</TT> acheives the same result as <A HREF="#deep_copy"><TT>deep_copy</TT></A>, so that the latter is redundant. It will probably be removed. <A HREF="#deep_copy"><TT>deep_copy</TT></A> returns a copy of expression <I>expr</I> which may be of mixed lex/aex 
representation. An exact copy is made; that is, the representation is preserved at all levels. <A HREF="#deep_copy"><TT>deep_copy</TT></A> is similar to <TT>copylist</TT>, except that it can copy some expressions that <TT>copylist</TT> cannot. For instance, if <I>expr</I> is of aex representation at the top 
level.</P><P><B>Arguments</B>
<TT>deep_copy</TT> requires one argument.</P><!--TOC subsection Function: faex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc22">3.13</A>  Function: faex<A NAME="sec:faex"></A></H3><!--SEC END --><P>
<A NAME="faex"></A>
<B>faex</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
deep copy <I>e</I> converting to aex representation at all levels.</P><P><B>Arguments</B>
<TT>faex</TT> requires one argument.</P><!--TOC subsection Function: flex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc23">3.14</A>  Function: flex<A NAME="sec:flex"></A></H3><!--SEC END --><P>
<A NAME="flex"></A>
<B>flex</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
deep copy <I>e</I> converting to lex representation at all levels.</P><P><B>Arguments</B>
<TT>flex</TT> requires one argument.</P><!--TOC subsection Function: iapply-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc24">3.15</A>  Function: iapply<A NAME="sec:iapply"></A></H3><!--SEC END --><P>
<A NAME="iapply"></A>
<B>iapply</B>(<I>fun</I>, <I>arg</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
<A HREF="#iapply"><TT>iapply</TT></A> is like maxima <TT>apply</TT>, but it supports aex lists. <I>arg</I> is converted to an ml if it is an aex expression. By default, output is ml regardless of the input representation.</P><P><B>Arguments</B>
<TT>iapply</TT> requires two arguments.
The first argument <I>fun</I> must be a map-able function.
The second argument <I>arg</I> must be non-atomic.</P><P><B>Options</B>
<TT>iapply</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) iapply(%%ff,lrange(4));
(%o1) %%ff(1,2,3,4)
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) iapply(%%ff,lrange(4,[ot-&gt;ar]));
(%o1) %%ff(&lt;[1,2,3,4]&gt;)
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) iapply(%%ff,lrange(4,[ot-&gt;ar]), [ot-&gt;ar] );
(%o1) %%ff&lt;&lt;[1,2,3,4]&gt;&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) iapply(%%ff,lrange(4), [ot-&gt;ar] );
(%o1) %%ff&lt;1,2,3,4&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: iargs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">3.16</A>  Function: iargs<A NAME="sec:iargs"></A></H3><!--SEC END --><P>
<A NAME="iargs"></A>
<B>iargs</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
returns a list of the arguments of <I>e</I>, which may be either a lex or aex expression. This works like <TT>args</TT>, but is more general.</P><P><B>Arguments</B>
<TT>iargs</TT> requires one argument <I>e</I>, which must be a subscripted variable or non-atomic.</P><P><B>Options</B>
<TT>iargs</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><!--TOC subsection Function: ilength-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">3.17</A>  Function: ilength<A NAME="sec:ilength"></A></H3><!--SEC END --><P>
<A NAME="ilength"></A>
<B>ilength</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Returns the length of the expression <I>e</I>. This is like maxima <TT>length</TT>, but here, <I>e</I> can be either an aex or a lex.</P><P><B>Arguments</B>
<TT>ilength</TT> requires one argument <I>e</I>, which must be a subscripted variable or non-atomic.</P><!--TOC subsection Function: iop-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">3.18</A>  Function: iop<A NAME="sec:iop"></A></H3><!--SEC END --><P>
<A NAME="iop"></A>
<B>iop</B>(<I>expr</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
returns the main operator of the expression <I>expr</I>, which may be either a lex or aex expression. This works like ‘op’, but is more general.</P><P><B>Arguments</B>
<TT>iop</TT> requires one argument <I>expr</I>, which must be a subscripted variable or non-atomic.</P><!--TOC subsection Function: ipart-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">3.19</A>  Function: ipart<A NAME="sec:ipart"></A></H3><!--SEC END --><P>
<A NAME="ipart"></A></P><P>mext package: aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>ipart</B>(<I>e</I>, <I>ind1</I>, <I>ind2</I>, <I>...</I>)
Returns the part of expression <I>e</I> specified by indices. <I>e</I> may be a mixed (lex and aex) representation expression. When used as an lvalue, ipart can be used to assign to a part of an expression. If an index is negative, then it counts from the end of the list. If <I>e</I> is an ordinary 
maxima list (lex), then using a negative index is potentially slower than using a positive index because the entire list must first be traversed in order to determine it’s length. If <I>e</I> is in aex representation, then this inefficiency is not present.</LI></UL><P>
<B>Examples</B></P><P>Destructively assign to a part of an exression.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) (a : [1,2,3], ipart(a,1) : 7, a);
(%o1) [7,2,3]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>Implementation</B>
Some tests were performed with large lists of numbers. If we set <CODE>a:lrange(10^7)</CODE>, then the times required for <CODE>ipart(a,10^7)</CODE>, <CODE>ipart(a,-1)</CODE>, <CODE>inpart(a,10^7)</CODE>, and <CODE>part(a,10^7)</CODE> were 30, 60, 90, and 90 ms.</P><!--TOC subsection Function: ipart_set-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">3.20</A>  Function: ipart_set<A NAME="sec:ipart_set"></A></H3><!--SEC END --><P>
<A NAME="ipart_set"></A></P><P>mext package: aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>ipart_set</B>(<I>e</I>, <I>val</I>, <I>ind1</I>, <I>ind2</I>, <I>...</I>)
Set part of <I>e</I> specified by the final arguments to <I>val</I>. <I>e</I> is a mixed representation expression.</LI></UL><!--TOC subsection Function: ireverse-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">3.21</A>  Function: ireverse<A NAME="sec:ireverse"></A></H3><!--SEC END --><P>
<A NAME="ireverse"></A>
<B>ireverse</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
ireverse is like maxima reverse, but is works on both aex and list objects. ireverse is tries to be identical to maxima reverse for a non-aex argument.</P><P><B>Arguments</B>
<TT>ireverse</TT> requires one argument <I>e</I>, which must be non-atomic.</P><P><B>Options</B>
<TT>ireverse</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) ireverse(lrange(4));
(%o1) [4,3,2,1]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) ireverse(lrange(4), [ot-&gt;ar] );
(%o1) &lt;[4,3,2,1]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) ireverse(lrange(4, [ot-&gt;ar]) );
(%o1) [&lt;[1,2,3,4]&gt;]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) ireverse(lrange(4, [ot-&gt;ar]), [ot-&gt;ml] );
(%o1) [&lt;[1,2,3,4]&gt;]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: lex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc31">3.22</A>  Function: lex<A NAME="sec:lex"></A></H3><!--SEC END --><P>
<A NAME="lex"></A></P><P>mext package: aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>lex</B>(<I>e</I>)
converts the aex expression <I>e</I> to lex. If <I>e</I> is not an aex expression, <I>e</I> is returned. Conversion is only done on the first level.</LI></UL><!--TOC subsection Function: raex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc32">3.23</A>  Function: raex<A NAME="sec:raex"></A></H3><!--SEC END --><P>
<A NAME="raex"></A>
<B>raex</B>(<I>e</I> :optional <I>spec</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Convert <I>e</I> to aex representation at the specified levels.</P><P><B>Arguments</B>
<TT>raex</TT> requires either one or two arguments.</P><!--TOC subsection Function: rlex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">3.24</A>  Function: rlex<A NAME="sec:rlex"></A></H3><!--SEC END --><P>
<A NAME="rlex"></A>
<B>rlex</B>(<I>e</I> :optional <I>spec</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Deep copy, converting <I>e</I> to lex representation at the specified levels.</P><P><B>Arguments</B>
<TT>rlex</TT> requires either one or two arguments.</P><!--TOC section Functions and Variables for Combinatorics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc34">4</A>  Functions and Variables for Combinatorics</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#inverse_permutation"><TT>inverse_permutation</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#perm_to_transpositions"><TT>perm_to_transpositions</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#permutation_p"><TT>permutation_p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#permutation_p1"><TT>permutation_p1</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#random_cycle"><TT>random_cycle</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#signature_permutation"><TT>signature_permutation</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#transpositions_to_perm"><TT>transpositions_to_perm</TT></A>
</LI></UL><!--TOC subsection Function: ae_random_permutation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc35">4.1</A>  Function: ae_random_permutation<A NAME="sec:ae_random_permutation"></A></H3><!--SEC END --><P>
<A NAME="ae_random_permutation"></A>
<B>ae_random_permutation</B>(<I>a</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
returns <I>a</I> with subexpressions permuted randomly.</P><P><B>Arguments</B>
<TT>ae_random_permutation</TT> requires one argument <I>a</I>, which must be non-atomic.</P><P><B>Options</B>
<TT>ae_random_permutation</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><!--TOC subsection Function: cycles_to_perm-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">4.2</A>  Function: cycles_to_perm<A NAME="sec:cycles_to_perm"></A></H3><!--SEC END --><P>
<A NAME="cycles_to_perm"></A>
<B>cycles_to_perm</B>(<I>cycles</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns a permutation from its cycle decomposition <I>cycles</I>, which is a list of lists. Here ‘permutation’ means a permutation of a list of the integers from 1 to some number <I>n</I>. The default output representation is aex.</P><P><B>Arguments</B>
<TT>cycles_to_perm</TT> requires one argument <I>cycles</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>cycles_to_perm</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, and <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>.</P><!--TOC subsection Function: inverse_permutation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc37">4.3</A>  Function: inverse_permutation<A NAME="sec:inverse_permutation"></A></H3><!--SEC END --><P>
<A NAME="inverse_permutation"></A>
<B>inverse_permutation</B>(<I>perm</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the inverse permutation of <I>perm</I>.</P><P><B>Arguments</B>
<TT>inverse_permutation</TT> requires one argument <I>perm</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>inverse_permutation</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) inverse_permutation([5,1,4,2,6,8,7,3,10,9]);
(%o1) &lt;[2,4,8,3,1,5,7,6,10,9]&gt;
(%i1) inverse_permutation(inverse_permutation([5,1,4,2,6,8,7,3,10,9]),ot-&gt;ml);
(%o1) [5,1,4,2,6,8,7,3,10,9]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: perm_to_cycles-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">4.4</A>  Function: perm_to_cycles<A NAME="sec:perm_to_cycles"></A></H3><!--SEC END --><P>
<A NAME="perm_to_cycles"></A>
<B>perm_to_cycles</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns a cycle decomposition of the input permutation <I>ain</I>. The input must be a permutation of <I>n</I> integers from 1 through <I>n</I>.</P><P><B>Arguments</B>
<TT>perm_to_cycles</TT> requires one argument <I>ain</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>perm_to_cycles</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) perm_to_cycles([5,4,3,2,1,10,6,7,8,9]);
(%o1) [[7,8,9,10,6],[3],[4,2],[5,1]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><!--TOC subsection Function: perm_to_transpositions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">4.5</A>  Function: perm_to_transpositions<A NAME="sec:perm_to_transpositions"></A></H3><!--SEC END --><P>
<A NAME="perm_to_transpositions"></A>
<B>perm_to_transpositions</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns a list representing the permutation <I>ain</I> as a product of transpositions. The output representation type is applied at both levels.</P><P><B>Arguments</B>
<TT>perm_to_transpositions</TT> requires one argument <I>ain</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>perm_to_transpositions</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><!--TOC subsection Function: permutation_p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">4.6</A>  Function: permutation_p<A NAME="sec:permutation_p"></A></H3><!--SEC END --><P>
<A NAME="permutation_p"></A>
<B>permutation_p</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>permutation_p</B>(<I>list</I>)
Returns true if the list <I>list</I> of length <I>n</I> is a permutation of the integers from 1 through <I>n</I>. Otherwise returns false.</LI></UL><P>
<B>Arguments</B>
<TT>permutation_p</TT> requires one argument.</P><P><B>Implementation</B>
Separate routines for aex and lex input are used.</P><!--TOC subsection Function: permutation_p1-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc41">4.7</A>  Function: permutation_p1<A NAME="sec:permutation_p1"></A></H3><!--SEC END --><P>
<A NAME="permutation_p1"></A>
<B>permutation_p1</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
This is the same as <A HREF="#permutation_p"><TT>permutation_p</TT></A>, but, if the input is a list, it assumes all elements in the input list are fixnum integers, while <A HREF="#permutation_p"><TT>permutation_p</TT></A> does not.</P><P><B>Arguments</B>
<TT>permutation_p1</TT> requires one argument.</P><P><B>Implementation</B>
Some variables are declared fixnum, but this does not seem to improve performance with respect to <A HREF="#permutationp"><TT>permutationp</TT></A>.</P><!--TOC subsection Function: random_cycle-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">4.8</A>  Function: random_cycle<A NAME="sec:random_cycle"></A></H3><!--SEC END --><P>
<A NAME="random_cycle"></A>
<B>random_cycle</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>random_cycle</B>(<I>n</I>)
Returns a random cycle of length <I>n</I>. The return value is a list of the integers from 1 through <I>n</I>, representing an element of the symmetric group <I>S</I><SUB><I>n</I></SUB> that is a cycle.</LI></UL><P>
<B>Arguments</B>
<TT>random_cycle</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P>The first argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>random_cycle</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><P><B>Implementation</B>
This function uses Sattolo’s algorithm.</P><!--TOC subsection Function: random_permutation_sym-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc43">4.9</A>  Function: random_permutation_sym<A NAME="sec:random_permutation_sym"></A></H3><!--SEC END --><P>
<A NAME="random_permutation_sym"></A>
<B>random_permutation_sym</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>random_permutation_sym</B>(<I>n</I>)
Returns a random permutation of the integers from 1 through <I>n</I>. This represents a random element of the symmetric group <I>S</I><SUB><I>n</I></SUB>.</LI></UL><P>
<B>Arguments</B>
<TT>random_permutation_sym</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P>The first argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>random_permutation_sym</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><!--TOC subsection Function: signature_permutation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc44">4.10</A>  Function: signature_permutation<A NAME="sec:signature_permutation"></A></H3><!--SEC END --><P>
<A NAME="signature_permutation"></A>
<B>signature_permutation</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>signature_permutation</B>(<I>list</I>)
returns the sign, or signature, of the symmetric permutation <I>list</I>, which must be represented by a permuation the integers from 1 through <I>n</I>, where <I>n</I> is the length of the list.</LI></UL><P>
<B>Arguments</B>
<TT>signature_permutation</TT> requires one argument <I>ain</I>, which must be a list (lex or aex).</P><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><!--TOC subsection Function: transpositions_to_perm-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc45">4.11</A>  Function: transpositions_to_perm<A NAME="sec:transpositions_to_perm"></A></H3><!--SEC END --><P>
<A NAME="transpositions_to_perm"></A>
<B>transpositions_to_perm</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the permutation specified by the list of transpositions <I>ain</I>.</P><P><B>Arguments</B>
<TT>transpositions_to_perm</TT> requires one argument <I>ain</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>transpositions_to_perm</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Implementation</B>
Input is converted to lex on both levels. Default output is aex.</P><!--TOC section Functions and Variables for Documentation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc46">5</A>  Functions and Variables for Documentation</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#doc_system_list"><TT>doc_system_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#doc_system_set"><TT>doc_system_set</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#error_code"><TT>error_code</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#maxdoc"><TT>maxdoc</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#maxdoc_author"><TT>maxdoc_author</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#maxdoc_copyright"><TT>maxdoc_copyright</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#maxdoc_examples"><TT>maxdoc_examples</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#maxdoc_set_cur_sec"><TT>maxdoc_set_cur_sec</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#maxdoc_set_mext_package"><TT>maxdoc_set_mext_package</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#maxdoc_split_text"><TT>maxdoc_split_text</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_package_record"><TT>mext_package_record</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#pager_command"><TT>pager_command</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_authors"><TT>print_authors</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_copyrights"><TT>print_copyrights</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_entry_latex"><TT>print_entry_latex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_implementation"><TT>print_implementation</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_maxdoc_entry"><TT>print_maxdoc_entry</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_maxdoc_sections"><TT>print_maxdoc_sections</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_sections_latex"><TT>print_sections_latex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#read_docs_with_pager"><TT>read_docs_with_pager</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>
</LI></UL><!--TOC subsection Variable: doc_system_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">5.1</A>  Variable: doc_system_list<A NAME="sec:doc_system_list"></A></H3><!--SEC END --><P>
<A NAME="doc_system_list"></A></P><P>mext package: maxdoc</P><P>
default value <CODE>false</CODE>.</P><P><B>Description</B>
A list of the documenatation systems (as strings) that will be searched by ? and ??. This can be set to all avaliable systems with the function <A HREF="#doc_system_set_all"><TT>doc_system_set_all</TT></A>. If this variable is false, then all documentation is enabled.</P><!--TOC subsection Function: doc_system_set-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">5.2</A>  Function: doc_system_set<A NAME="sec:doc_system_set"></A></H3><!--SEC END --><P>
<A NAME="doc_system_set"></A>
<B>doc_system_set</B>( :optional <I>systems</I>)</P><P>mext package: maxdoc</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>doc_system_set</B>()
Enables all available documentation systems.</LI><LI CLASS="li-itemize"> <B>doc_system_set</B>(’all )
Enables all available documentation systems.</LI><LI CLASS="li-itemize"> <B>doc_system_set</B>(’maxima )
Enables only stock maxima systems.</LI><LI CLASS="li-itemize"> <B>doc_system_set</B>(’nonmaxima )
Enables only documentation systems that are not in the stock maxima distribution.</LI><LI CLASS="li-itemize"> <B>doc_system_set</B>(<I>system</I>)
Enables only the documentation system <I>system</I>.</LI><LI CLASS="li-itemize"> <B>doc_system_set</B>([<I>system1</I>, <I>system2</I>])
Enables two documentation systems. The arguments may be "maxima" "nonmaxima", etc.</LI></UL><P>
<B>Description</B>
Set the list of documentation systems that will be searched by describe, ? and ??. This sets <I>doc_system_list</I>, which can also be set by any other means.</P><P><B>Arguments</B>
<TT>doc_system_set</TT> requires either zero or one arguments. If present, the argument <I>systems</I> must be a a string, a symbol, or a list of strings or symbols.</P><!--TOC subsection Variable: error_code-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc49">5.3</A>  Variable: error_code<A NAME="sec:error_code"></A></H3><!--SEC END --><P>
<A NAME="error_code"></A></P><P>mext package: defmfun1</P><P>
default value <CODE>false</CODE>.</P><P><B>Description</B>
This is an error code set by <CODE>merror1</CODE>.</P><!--TOC subsection Function: maxdoc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc50">5.4</A>  Function: maxdoc<A NAME="sec:maxdoc"></A></H3><!--SEC END --><P>
<A NAME="maxdoc"></A>
<B>maxdoc</B>(<I>name</I>, <I>docs</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Add maxdoc documentation entry for item <I>name</I> specified by <I>docs</I>.</P><P><B>Arguments</B>
<TT>maxdoc</TT> requires two arguments.
The first argument <I>name</I> must be a string.</P><P><B>Options</B>
<TT>maxdoc</TT> takes options with default values: <TT>package-&gt;false</TT>, <TT>source_filename-&gt;false</TT>.
</P><P><B>Attributes</B>
maxdoc has attributes: [hold_all]</P><!--TOC subsection Function: maxdoc_author-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc51">5.5</A>  Function: maxdoc_author<A NAME="sec:maxdoc_author"></A></H3><!--SEC END --><P>
<A NAME="maxdoc_author"></A>
<B>maxdoc_author</B>(<I>name</I>, <I>author</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Set the author(s) for the documentation item <I>name</I>.</P><P><B>Arguments</B>
<TT>maxdoc_author</TT> requires two arguments.
The first argument <I>name</I> must be a string.
The second argument <I>author</I> must be a string or a list of strings.</P><P>The first argument threads (distributes) over lists.</P><!--TOC subsection Function: maxdoc_copyright-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc52">5.6</A>  Function: maxdoc_copyright<A NAME="sec:maxdoc_copyright"></A></H3><!--SEC END --><P>
<A NAME="maxdoc_copyright"></A>
<B>maxdoc_copyright</B>(<I>name</I>, <I>copyright</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Set the copyright information for the documentation item <I>name</I>. <I>copyright</I> should typically be a list whose first element is an integer (the year), with the remaining strings naming the copyright holder. This copyright information will not be printed with documentation, unless <I>print_copyrights</I> is true.</P><P><B>Arguments</B>
<TT>maxdoc_copyright</TT> requires two arguments.
The first argument <I>name</I> must be a string.</P><P>The first argument threads (distributes) over lists.</P><!--TOC subsection Function: maxdoc_examples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc53">5.7</A>  Function: maxdoc_examples<A NAME="sec:maxdoc_examples"></A></H3><!--SEC END --><P>
<A NAME="maxdoc_examples"></A>
<B>maxdoc_examples</B>(<I>name</I> :rest <I>examples</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Add maxdoc examples entry for item <I>name</I> specified by <I>examples</I>.</P><P><B>Arguments</B>
<TT>maxdoc_examples</TT> requires one or more arguments. The first argument <I>name</I> must be a string.</P><P><B>Attributes</B>
maxdoc_examples has attributes: [hold_all]</P><!--TOC subsection Function: maxdoc_set_cur_sec-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">5.8</A>  Function: maxdoc_set_cur_sec<A NAME="sec:maxdoc_set_cur_sec"></A></H3><!--SEC END --><P>
<A NAME="maxdoc_set_cur_sec"></A>
<B>maxdoc_set_cur_sec</B>(<I>shortname</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Set the current section for maxdoc to <I>shortname</I>. This section will be used by functions such as <A HREF="#maxdoc"><TT>maxdoc</TT></A>, and <A HREF="#maxdoc_author"><TT>maxdoc_author</TT></A>.</P><P><B>Arguments</B>
<TT>maxdoc_set_cur_sec</TT> requires one argument <I>shortname</I>, which must be a string.</P><!--TOC subsection Function: maxdoc_set_mext_package-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">5.9</A>  Function: maxdoc_set_mext_package<A NAME="sec:maxdoc_set_mext_package"></A></H3><!--SEC END --><P>
<A NAME="maxdoc_set_mext_package"></A>
<B>maxdoc_set_mext_package</B>(<I>packagename</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Set the current mext package name for maxdoc to <I>packagename</I>. This name will be used by functions specifying documentation for functions until the name is set to another value. When documenting functions written in maxima code, calling <A HREF="#mext_record_package"><TT>mext_record_package</TT></A> is probably more useful.</P><P><B>Arguments</B>
<TT>maxdoc_set_mext_package</TT> requires one argument <I>packagename</I>, which must be a string.</P><!--TOC subsection Function: maxdoc_split_text-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc56">5.10</A>  Function: maxdoc_split_text<A NAME="sec:maxdoc_split_text"></A></H3><!--SEC END --><P>
<A NAME="maxdoc_split_text"></A>
<B>maxdoc_split_text</B>(<I>text</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Split the string <I>text</I> into a list of strings, using a sequence of one or more spaces as the delimeter. Single newlines are removed.</P><P><B>Arguments</B>
<TT>maxdoc_split_text</TT> requires one argument <I>text</I>, which must be a string.</P><P>The first argument threads (distributes) over lists.</P><!--TOC subsection Function: mext_package_record-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc57">5.11</A>  Function: mext_package_record<A NAME="sec:mext_package_record"></A></H3><!--SEC END --><P>
<A NAME="mext_package_record"></A>
<B>mext_package_record</B>(<I>docitems</I>, <I>packagename</I> :optional <I>source-filename</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Set the mext packagename for the function or variable (or list of them) <I>docitems</I> to <I>packagename</I>.This name will be used when displaying documentation.The function <A HREF="#maxdoc_set_mext_package"><TT>maxdoc_set_mext_package</TT></A> is useful for setting the package name of a group of 
functions, but there is currently no maxima hook for doing this.</P><P><B>Arguments</B>
<TT>mext_package_record</TT> requires either two or three arguments.
The first argument <I>docitems</I> must be a string, a symbol, or a list of strings or symbols.
The second argument <I>packagename</I> must be a string.
The third argument <I>source-filename</I> must be a string.</P><!--TOC subsection Variable: pager_command-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc58">5.12</A>  Variable: pager_command<A NAME="sec:pager_command"></A></H3><!--SEC END --><P>
<A NAME="pager_command"></A></P><P>mext package: defmfun1</P><P>
default value <CODE>/usr/bin/less</CODE>.</P><P><B>Description</B>
The pathname to the system command used for paged output, for instance, for reading documentation.</P><!--TOC subsection Variable: print_authors-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc59">5.13</A>  Variable: print_authors<A NAME="sec:print_authors"></A></H3><!--SEC END --><P>
<A NAME="print_authors"></A></P><P>mext package: defmfun1</P><P>
default value <CODE>true</CODE>.</P><P><B>Description</B>
If true, then print the names of the authors with maxdoc documentation.</P><!--TOC subsection Variable: print_copyrights-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc60">5.14</A>  Variable: print_copyrights<A NAME="sec:print_copyrights"></A></H3><!--SEC END --><P>
<A NAME="print_copyrights"></A></P><P>mext package: defmfun1</P><P>
default value <CODE>false</CODE>.</P><P><B>Description</B>
If true, then print copyright information with maxdoc documentation.</P><!--TOC subsection Function: print_entry_latex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc61">5.15</A>  Function: print_entry_latex<A NAME="sec:print_entry_latex"></A></H3><!--SEC END --><P>
<A NAME="print_entry_latex"></A>
<B>print_entry_latex</B>(<I>item</I>)</P><P>mext package: maxdoc</P><P>
<B>Arguments</B>
<TT>print_entry_latex</TT> requires one argument <I>item</I>, which must be a string.</P><P>The first argument threads (distributes) over lists.</P><!--TOC subsection Variable: print_implementation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc62">5.16</A>  Variable: print_implementation<A NAME="sec:print_implementation"></A></H3><!--SEC END --><P>
<A NAME="print_implementation"></A></P><P>mext package: defmfun1</P><P>
default value <CODE>true</CODE>.</P><P><B>Description</B>
If true, then print implementation information with maxdoc documentation.</P><!--TOC subsection Function: print_maxdoc_entry-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc63">5.17</A>  Function: print_maxdoc_entry<A NAME="sec:print_maxdoc_entry"></A></H3><!--SEC END --><P>
<A NAME="print_maxdoc_entry"></A>
<B>print_maxdoc_entry</B>(<I>item</I>)</P><P>mext package: maxdoc</P><P>
<B>Arguments</B>
<TT>print_maxdoc_entry</TT> requires one argument <I>item</I>, which must be a string.</P><P>The first argument threads (distributes) over lists.</P><!--TOC subsection Function: print_maxdoc_sections-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc64">5.18</A>  Function: print_maxdoc_sections<A NAME="sec:print_maxdoc_sections"></A></H3><!--SEC END --><P>
<A NAME="print_maxdoc_sections"></A>
<B>print_maxdoc_sections</B>()</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Print all sections of maxdoc documentation. This does not include other documentation databases, such as the main maxima documentation.</P><P><B>Arguments</B>
<TT>print_maxdoc_sections</TT> requires zero arguments.</P><!--TOC subsection Function: print_sections_latex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc65">5.19</A>  Function: print_sections_latex<A NAME="sec:print_sections_latex"></A></H3><!--SEC END --><P>
<A NAME="print_sections_latex"></A>
<B>print_sections_latex</B>( :optional <I>filename</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Print all sections of maxdoc documentation currently loaded in latex format to the file <I>filename</I>. This does not include other documentation databases, such as the main maxima documentation.</P><P><B>Arguments</B>
<TT>print_sections_latex</TT> requires either zero or one arguments. If present, the argument <I>filename</I> must be a a string.</P><!--TOC subsection Variable: read_docs_with_pager-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc66">5.20</A>  Variable: read_docs_with_pager<A NAME="sec:read_docs_with_pager"></A></H3><!--SEC END --><P>
<A NAME="read_docs_with_pager"></A></P><P>mext package: maxdoc</P><P>
default value <CODE>false</CODE>.</P><P><B>Description</B>
If true, then documenation printed by <TT>describe</TT> or ? or ?? is sent through the pager specified by <A HREF="#pager_command"><TT>pager_command</TT></A>. This will most likely only work with a command line interface under linux/unix with certain lisp implementations.</P><!--TOC subsection Function: simple_doc_add-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">5.21</A>  Function: simple_doc_add<A NAME="sec:simple_doc_add"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_add"></A>
<B>simple_doc_add</B>(<I>name</I>, <I>content</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Adds documentation string <I>content</I> for item <I>name</I>. These documentation strings are accessible via ’?’ and ’??’.</P><P><B>Arguments</B>
<TT>simple_doc_add</TT> requires two arguments.
The first argument <I>name</I> must be a string.
The second argument <I>content</I> must be a string.</P><P><B>See also</B>
<A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>, <A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>, <A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>, and <A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>.</P><!--TOC subsection Function: simple_doc_delete-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc68">5.22</A>  Function: simple_doc_delete<A NAME="sec:simple_doc_delete"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_delete"></A>
<B>simple_doc_delete</B>(<I>name</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Deletes the simple_doc documentation string for item <I>name</I>.</P><P><B>Arguments</B>
<TT>simple_doc_delete</TT> requires one argument <I>name</I>, which must be a string.</P><P><B>See also</B>
<A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>, <A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>, <A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>, and <A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>.</P><!--TOC subsection Function: simple_doc_get-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc69">5.23</A>  Function: simple_doc_get<A NAME="sec:simple_doc_get"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_get"></A>
<B>simple_doc_get</B>(<I>name</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Returns the simple_doc documentation string for item <I>name</I>.</P><P><B>Arguments</B>
<TT>simple_doc_get</TT> requires one argument <I>name</I>, which must be a string.</P><P><B>See also</B>
<A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>, <A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>, <A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>, and <A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>.</P><!--TOC subsection Function: simple_doc_init-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">5.24</A>  Function: simple_doc_init<A NAME="sec:simple_doc_init"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_init"></A>
<B>simple_doc_init</B>()</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Initialize the simple_doc documentation database.</P><P><B>Arguments</B>
<TT>simple_doc_init</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>, <A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>, <A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>, and <A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>.</P><!--TOC subsection Function: simple_doc_print-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">5.25</A>  Function: simple_doc_print<A NAME="sec:simple_doc_print"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_print"></A>
<B>simple_doc_print</B>(<I>name</I>)</P><P>mext package: maxdoc</P><P>
<B>Description</B>
Prints the simple_doc documentation string for item <I>name</I>.</P><P><B>Arguments</B>
<TT>simple_doc_print</TT> requires one argument <I>name</I>, which must be a string.</P><P><B>See also</B>
<A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>, <A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>, <A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>, and <A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>.</P><!--TOC section Functions and Variables for Equations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc72">6</A>  Functions and Variables for Equations</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#alt_eigen"><TT>alt_eigen</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nelder_mead"><TT>nelder_mead</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#to_poly_clean"><TT>to_poly_clean</TT></A>
</LI></UL><!--TOC subsection Function: alt_eigen-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc73">6.1</A>  Function: alt_eigen<A NAME="sec:alt_eigen"></A></H3><!--SEC END --><P>
<A NAME="alt_eigen"></A></P><P>mext package: alt_eigen</P><P>
<B>Description</B>
<CODE>alt_eigen(mat, ['var=x, 'maxdegree=n, 'orthogonal=boolean])</CODE> </P><P>Express the eigenvectors of the matrix <I>mat</I> as a polynomial in the eigenvalue <I>var</I>. When the degree of a factor of the characteristic polynomial has degree <I>maxdegree</I> or less, the code attempts to find all the roots of the factor. The optional variables <I>var</I>, <I>maxdegree</I> 
(default 1), and <I>orthogonal</I> (default false) can be in any order. When the dimension of an eigenspace is greater than one and <I>orthogonal</I> is true, the list of eigenvectors is orthogonal.</P><P><B>Examples</B>
The eigenvectors of <CODE>matrix([1,2],[4,5])</CODE>, are </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) alt_eigen(matrix([1,2],[4,5]),'var=z);
(%o1) [z^2=6*z+3,[matrix([2],[z-1])]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Substituting the two roots of <CODE>z^2=6*z+3</CODE> in to the column vector <CODE>matrix([2],[z-1])</CODE> gives the two eigenvectors. To find explicit expressions for these eigenvectors, set <I>maxdegree</I> to 2; thus</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i2) alt_eigen(matrix([1,2],[4,5]),'var=z, 'maxdegree=2);
(%o2) [z=2*sqrt(3)+3,[matrix([2],[2*sqrt(3)+2])],z=3-2*sqrt(3),
    [matrix([2],[2-2*sqrt(3)])]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Here is a matrix with a degenerate eigenvalue:</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i3) m : matrix([5,6,5,6,5,6],[6,5,6,5,6,5],[5,6,5,6,5,6],[6,5,6,5,6,5],
   [5,6,5,6,5,6],[6,5,6,5,6,5])$
(%i4) alt_eigen(m,'var=z);
(%o4) [z=-3,[matrix([-1],[1],[-1],[1],[-1],[1])],z=0,[matrix([0],[-1],[0],[1],[0],[0]),
     matrix([0],[0],[0],[-1],[0],[1]), matrix([0],[0],[1],[0],[-1],[0]),
     matrix([1],[0],[-1],[0],[0],[0])],z=33,[matrix([-1],[-1],[-1],[-1],[-1],[-1])]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>There are four eigenvectors with eigenvalue 0. To find an orthogonal basis for this eigenspace, set the optional variable <I>orthogonal</I> to true; thus</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i5) alt_eigen(m,'var=z, 'orthogonal=true);
(%o5) [z=-3,[matrix([-1],[1],[-1],[1],[-1],[1])],z=0,[matrix([1],[0],[-1/2],[0],
    [-1/2],[0]), matrix([0],[0],[1],[0],[-1],[0]),matrix([0],[-1/2],[0],[-1/2],[0],[1]),
    matrix([0],[-1],[0],[1],[0],[0])],z=33,[matrix([-1],[-1],[-1],[-1],[-1],[-1])]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>Author</B>
Barton Willis.</P><!--TOC subsection Function: nelder_mead-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc74">6.2</A>  Function: nelder_mead<A NAME="sec:nelder_mead"></A></H3><!--SEC END --><P>
<A NAME="nelder_mead"></A>
<B>nelder_mead</B>(<I>expr</I>, <I>vars</I>, <I>init</I>)</P><P>mext package: nelder_mead</P><P>
<B>Description</B>
The Nelder-Mead optimization algorithm.</P><P><B>Arguments</B>
<TT>nelder_mead</TT> requires three arguments.
The second argument <I>vars</I> must be a list of symbols.
The third argument <I>init</I> must be a list of numbers.</P><P><B>Examples</B></P><P>Find the minimum of a function at a non-analytic point.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) nelder_mead(if x&lt;0 then -x else x^2, [x], [4]);
(%o1) [x = 9.536387892694629e-11]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) f(x) := if x&lt;0 then -x else x^2$
(%i2) nelder_mead(f, [x], [4]);
(%o2) [x = 9.536387892694628e-11]
(%i3) nelder_mead(f(x), [x], [4]);
(%o3) [x = 9.536387892694628e-11]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) nelder_mead(x^4+y^4-2*x*y-4*x-3*y, [x,y], [2,2]);
(%o1) [x = 1.157212489168102,y = 1.099342680267472]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>Author</B>
Mario S. Mommer.</P><!--TOC subsection Function: to_poly_clean-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc75">6.3</A>  Function: to_poly_clean<A NAME="sec:to_poly_clean"></A></H3><!--SEC END --><P>
<A NAME="to_poly_clean"></A>
<B>to_poly_clean</B>()</P><P>mext package: tpsolve</P><P>
<B>Description</B>
Removes the temporary variables created by <TT>to_poly</TT>. These are also created by <TT>to_poly_solve</TT>. They can be created from maxima with <TT>new_variable</TT>. These variables can be found in the infolist <TT>props</TT>. <A HREF="#to_poly_clean"><TT>to_poly_clean</TT></A> returns the number of 
variables removed.</P><P><B>Arguments</B>
<TT>to_poly_clean</TT> requires zero arguments.</P><!--TOC section Functions and Variables for Function Definition-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc76">7</A>  Functions and Variables for Function Definition</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#comp_load"><TT>comp_load</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#compile_file1"><TT>compile_file1</TT></A>
</LI></UL><!--TOC subsection Function: comp_load-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc77">7.1</A>  Function: comp_load<A NAME="sec:comp_load"></A></H3><!--SEC END --><P>
<A NAME="comp_load"></A>
<B>comp_load</B>(<I>fname</I> :optional <I>pathlist</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Compile and load a lisp file. Maxima does not load it by default with <TT>compile_file</TT>. If the input filename does not end with “.lisp”, it will be appended. If <I>pathlist</I> is specified, then <I>fname</I> is only searched for in directories in <I>pathlist</I>.</P><P><B>Arguments</B>
<TT>comp_load</TT> requires either one or two arguments.
The first argument <I>fname</I> must be a string.
The second argument <I>pathlist</I> must be a string or a list of strings.</P><!--TOC subsection Function: compile_file1-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc78">7.2</A>  Function: compile_file1<A NAME="sec:compile_file1"></A></H3><!--SEC END --><P>
<A NAME="compile_file1"></A>
<B>compile_file1</B>(<I>input-file</I> :optional <I>bin-file</I>, <I>translation-output-file</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
This is copied from maxima <TT>compile_file</TT>, with changes. Sometimes a loadable binary file is apparently compiled, but an error flag is set and <TT>compile_file</TT> returns false for the output binary filename. Here we return the binary filename in any case.</P><P><B>Arguments</B>
<TT>compile_file1</TT> requires between one and three arguments.
The first argument <I>input-file</I> must be a string.</P><!--TOC section Functions and Variables for Input and Output-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc79">8</A>  Functions and Variables for Input and Output</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#pager_string"><TT>pager_string</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#restore"><TT>restore</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#restore_fast"><TT>restore_fast</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#store"><TT>store</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#store_fast"><TT>store_fast</TT></A>
</LI></UL><!--TOC subsection Function: pager_string-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc80">8.1</A>  Function: pager_string<A NAME="sec:pager_string"></A></H3><!--SEC END --><P>
<A NAME="pager_string"></A>
<B>pager_string</B>(<I>s</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Read the string <I>s</I> in the pager given by the maxima variable <CODE>pager_command</CODE>.This works at least with gcl under linux.</P><P><B>Arguments</B>
<TT>pager_string</TT> requires one argument <I>s</I>, which must be a string.</P><!--TOC subsection Function: restore-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">8.2</A>  Function: restore<A NAME="sec:restore"></A></H3><!--SEC END --><P>
<A NAME="restore"></A>
<B>restore</B>(<I>file</I>)</P><P>mext package: store</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>restore</B>(<I>file</I>)
Reads and returns expressions from the file <I>file</I>.</LI></UL><P>
<B>Description</B>
Reads maxima expressions from file <I>file</I> created by the function <A HREF="#store"><TT>store</TT></A>.</P><P><B>Arguments</B>
<TT>restore</TT> requires one argument <I>file</I>, which must be a string.</P><P>The first argument threads (distributes) over lists.</P><P><B>See also</B>
<A HREF="#store"><TT>store</TT></A>, <A HREF="#store_fast"><TT>store_fast</TT></A>, and <A HREF="#restore_fast"><TT>restore_fast</TT></A>.</P><!--TOC subsection Function: restore_fast-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc82">8.3</A>  Function: restore_fast<A NAME="sec:restore_fast"></A></H3><!--SEC END --><P>
<A NAME="restore_fast"></A>
<B>restore_fast</B>(<I>file</I>)</P><P>mext package: store</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>restore_fast</B>(<I>file</I>)
Reads and returns expressios from the file <I>file</I>. No checking for circular references is done.</LI></UL><P>
<B>Description</B>
Reads maxima expressions from file <I>file</I> created by the function <A HREF="#store"><TT>store</TT></A>, or <A HREF="#store_fast"><TT>store_fast</TT></A>. No checks for circular references are done.</P><P><B>Arguments</B>
<TT>restore_fast</TT> requires one argument <I>file</I>, which must be a string.</P><P>The first argument threads (distributes) over lists.</P><P><B>See also</B>
<A HREF="#store"><TT>store</TT></A>, <A HREF="#restore"><TT>restore</TT></A>, and <A HREF="#store_fast"><TT>store_fast</TT></A>.</P><!--TOC subsection Function: store-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc83">8.4</A>  Function: store<A NAME="sec:store"></A></H3><!--SEC END --><P>
<A NAME="store"></A>
<B>store</B>(<I>file</I> :rest <I>exprs</I>)</P><P>mext package: store</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>store</B>(<I>file</I>, <I>expr1</I>, <I>expr2</I>, <I>...</I>)
stores the expressions to the file <I>file</I>.</LI></UL><P>
<B>Description</B>
Stores maxima expressions <I>exprs</I> in <I>file</I> in binary format. Many types of lisp expressions and subexpressions are supported: numbers,strings,list,arrays,hashtables,structures,....</P><P><B>Arguments</B>
<TT>store</TT> requires one or more arguments. The first argument <I>file</I> must be a string.</P><P><B>Examples</B></P><P>Save a graph to a file. This cannot be done with the command 
&lt;save&gt;.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) load(graphs)$
(%i2) c : petersen_graph();
(%o2) GRAPH(10 vertices, 15 edges)
(%i3) factor(graph_charpoly(c,x));
(%o3) (x-3)*(x-1)^5*(x+2)^4
(%i4) store("graph.cls",c)$
(%i5) factor(graph_charpoly( restore("graph.cls"), x));
(%o5) (x-3)*(x-1)^5*(x+2)^4
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#restore"><TT>restore</TT></A>, <A HREF="#store_fast"><TT>store_fast</TT></A>, and <A HREF="#restore_fast"><TT>restore_fast</TT></A>.</P><P><B>Implementation</B>
store uses the cl-store library. See the cl-store documentation for more information.</P><!--TOC subsection Function: store_fast-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc84">8.5</A>  Function: store_fast<A NAME="sec:store_fast"></A></H3><!--SEC END --><P>
<A NAME="store_fast"></A>
<B>store_fast</B>(<I>file</I> :rest <I>exprs</I>)</P><P>mext package: store</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>store_fast</B>(<I>file</I>, <I>expr1</I>, <I>expr2</I>, <I>...</I>)
stores the expressions to the file <I>file</I>. No checking for circular references is done.</LI></UL><P>
<B>Description</B>
Stores maxima expressions <I>exprs</I> in <I>file</I> in binary format. This is like <A HREF="#store"><TT>store</TT></A>, except that no checks for circular references are done.</P><P><B>Arguments</B>
<TT>store_fast</TT> requires one or more arguments. The first argument <I>file</I> must be a string.</P><P><B>See also</B>
<A HREF="#store"><TT>store</TT></A>, <A HREF="#restore"><TT>restore</TT></A>, and <A HREF="#restore_fast"><TT>restore_fast</TT></A>.</P><!--TOC section Functions and Variables for Lists-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc85">9</A>  Functions and Variables for Lists</H2><!--SEC END --><P>These functions manipulate lists. They build lists, take them apart, select elements, etc.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#aelistp"><TT>aelistp</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#constant_list"><TT>constant_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#count"><TT>count</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#drop_while"><TT>drop_while</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#every1"><TT>every1</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#fold"><TT>fold</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#fold_list"><TT>fold_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#icons"><TT>icons</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#imap"><TT>imap</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#length_while"><TT>length_while</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#lrange"><TT>lrange</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nest"><TT>nest</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nest_list"><TT>nest_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nest_while"><TT>nest_while</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nreverse"><TT>nreverse</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#partition_list"><TT>partition_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#select"><TT>select</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#sequence specifier"><TT>sequence specifier</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#table"><TT>table</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#take"><TT>take</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#take_while"><TT>take_while</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#tuples"><TT>tuples</TT></A>
</LI></UL><!--TOC subsection Function: aelistp-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc86">9.1</A>  Function: aelistp<A NAME="sec:aelistp"></A></H3><!--SEC END --><P>
<A NAME="aelistp"></A></P><P>mext package: lists_aex</P><P>
<B>Description</B>
Returns true if <I>e</I> is a list, either ml or ar representation.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) aelistp([1,2,3]);
(%o1) true
(%i1) aelistp( aex([1,2,3]));
(%o1) true
(%i2) aelistp(3);
(%o2) false
(%i3) aelistp(x);
(%o3) false
(%i4) x:lrange(10),aelistp(x);
(%o4) true
(%i5) aelistp(%%f(y));
(%o5) false
(%i6) aelistp( aex( %%f(y) ));
(%o6) false
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: constant_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc87">9.2</A>  Function: constant_list<A NAME="sec:constant_list"></A></H3><!--SEC END --><P>
<A NAME="constant_list"></A>
<B>constant_list</B>(<I>c</I>, <I>spec</I> :optional <I>head</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Returns a list of <I>n</I> elements, each of which is an independent copy of expr. <CODE>constant_list(expr,[n,m,..])</CODE> returns a nested list of dimensions <I>n</I>,<I>m</I>,…where each leaf is an independent copy of expr and the copies of each list at each level are independent. If a third argument 
is given, then it is used as the op, rather than ‘list’, at every level. The third argument may also be a list of heads to apply, one at each leve.</P><P><B>Arguments</B>
<TT>constant_list</TT> requires either two or three arguments.
The second argument <I>spec</I> must be a positive integer or a list of positive integers.</P><P><B>Options</B>
<TT>constant_list</TT> takes options with default values: <TT>match-&gt;false</TT>, <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><!--TOC subsection Function: count-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">9.3</A>  Function: count<A NAME="sec:count"></A></H3><!--SEC END --><P>
<A NAME="count"></A>
<B>count</B>(<I>expr</I>, <I>item</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Counts the number of items in <I>expr</I> matching <I>item</I>. If <I>item</I> is a lambda function then <I>compile</I> must be true.</P><P><B>Arguments</B>
<TT>count</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and either aex or represented by a lisp list.</P><P>The second argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>count</TT> takes options with default values: <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) count([1,2,"dog"], 'numberp);
(%o1) 2
(%i1) count([1,2,"dog"], "dog");
(%o1) 1
(%i2) count(lrange(10^4), lambda([x], is(mod(x,3) = 0)));
(%o2) 3333
(%i3) count( %%ff(1,2,"dog"), "dog");
(%o3) 1
(%i4) count(lrange(100,ot-&gt;ar), 'evenp);
(%o4) 50
(%i5) count(lrange(10^5), 'primep);
(%o5) 9592
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: drop_while-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">9.4</A>  Function: drop_while<A NAME="sec:drop_while"></A></H3><!--SEC END --><P>
<A NAME="drop_while"></A>
<B>drop_while</B>(<I>expr</I>, <I>test</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>drop_while</B>(<I>expr</I>, <I>test</I>)
Tests the elements of <I>expr</I> in order, dropping them until <I>test</I> fails. The remaining elements are returned in an expression with the same op as that <I>expr</I>.</LI></UL><P>
<B>Arguments</B>
<TT>drop_while</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.</P><P>The second argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>drop_while</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Drop elements as long as they are negative.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) drop_while([-3,-10,-1,3,6,7,-4], lambda([x], is(x&lt;0)));
(%o1) [3,6,7,-4]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: every1-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc90">9.5</A>  Function: every1<A NAME="sec:every1"></A></H3><!--SEC END --><P>
<A NAME="every1"></A>
<B>every1</B>(<I>expr</I>, <I>test</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>every1</B>(<I>expr</I>, <I>test</I>)
Returns true if <I>test</I> is true for each element in <I>expr</I>. Otherwise, false is returned. This is like <CODE>every</CODE> but allow a test that takes only one argument. For some inputs, every1 is much faster than every.</LI></UL><P>
<B>Arguments</B>
<TT>every1</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.</P><P>The second argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>every1</TT> takes options with default values: <TT>compile-&gt;true</TT>.
</P><!--TOC subsection Function: fold-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc91">9.6</A>  Function: fold<A NAME="sec:fold"></A></H3><!--SEC END --><P>
<A NAME="fold"></A></P><P>mext package: lists_aex</P><P>
<B>Description</B>
<CODE>fold(f,x,[a,b,c])</CODE> returns <CODE> f(f(f(x,a),b),c).</CODE></P><P><B>Arguments</B>
<TT>fold</TT> requires three arguments.
The third argument <I>v</I> must be non-atomic.</P><P>The first argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>fold</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>See also</B>
<A HREF="#fold_list"><TT>fold_list</TT></A> and <A HREF="#nest"><TT>nest</TT></A>.</P><!--TOC subsection Function: fold_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc92">9.7</A>  Function: fold_list<A NAME="sec:fold_list"></A></H3><!--SEC END --><P>
<A NAME="fold_list"></A></P><P>mext package: lists_aex</P><P>
<B>Description</B>
fold_list(f,x,[a,b,c]) returns [f(x,a),f(f(x,a),b),f(f(f(x,a),b),c)].</P><P><B>Arguments</B>
<TT>fold_list</TT> requires three arguments.
The third argument <I>v</I> must be non-atomic.</P><P>The first argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>fold_list</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>See also</B>
<A HREF="#fold"><TT>fold</TT></A> and <A HREF="#nest"><TT>nest</TT></A>.</P><!--TOC subsection Function: icons-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc93">9.8</A>  Function: icons<A NAME="sec:icons"></A></H3><!--SEC END --><P>
<A NAME="icons"></A>
<B>icons</B>(<I>x</I>, <I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
<A HREF="#icons"><TT>icons</TT></A> is like maxima <TT>cons</TT>, but less general, and much, much faster. <I>x</I> is a maxima object. <I>e</I> is a maxima list or list-like object, such as <CODE>[a]</CODE>, or <CODE>f(a)</CODE>. It is suitable at a minimum, for pushing a number or list or string onto a list of 
numbers, or strings or lists. If you find <A HREF="#icons"><TT>icons</TT></A> gives buggy behavior that you are not interested in investigating, use <TT>cons</TT> instead.</P><P><B>Implementation</B>
In a function that mostly only does icons in a loop, icons defined with defmfun rather than defmfun1 runs almost twice as fast. So icons is defined with defmfun rather than defmfun1. icons does no argument checking.</P><!--TOC subsection Function: imap-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">9.9</A>  Function: imap<A NAME="sec:imap"></A></H3><!--SEC END --><P>
<A NAME="imap"></A>
<B>imap</B>(<I>f</I>, <I>expr</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Maps functions of a single argument. I guess that <TT>map</TT> handles more types of input without error. But <A HREF="#imap"><TT>imap</TT></A> can be much faster for some inputs. This is especially true if a lambda function is passed to imap, as it can be compiled.</P><P><B>Arguments</B>
<TT>imap</TT> requires two arguments.
The second argument <I>expr</I> must be non-atomic.</P><P><B>Options</B>
<TT>imap</TT> takes options with default values: <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Map sqrt efficiently over a list of floats</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) (a : lrange(1.0,4),
        imap(lambda([x],modedeclare(x,float),sqrt(x)),a));
(%o1) [1.0,1.414213562373095,1.732050807568877,2.0]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>With aex expression, no conversions to lex are done.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) (a : lrange(1.0,4,ot-&gt;ar),
          imap(lambda([x],modedeclare(x,float),sqrt(x)),a));
(%o1) &lt;[1.0,1.414213562373095,1.732050807568877,2.0]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: length_while-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc95">9.10</A>  Function: length_while<A NAME="sec:length_while"></A></H3><!--SEC END --><P>
<A NAME="length_while"></A>
<B>length_while</B>(<I>expr</I>, <I>test</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Computes the length of <I>expr</I> while <I>test</I> is true.</P><P><B>Arguments</B>
<TT>length_while</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.</P><P>The second argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>length_while</TT> takes options with default values: <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) length_while([-3,-10,-1,3,6,7,-4], lambda([x], is(x&lt;0)));
(%o1) 3
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: lrange-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc96">9.11</A>  Function: lrange<A NAME="sec:lrange"></A></H3><!--SEC END --><P>
<A NAME="lrange"></A></P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>lrange</B>(<I>stop</I>)
returns a list of numbers from 1 through <I>stop</I>.</LI><LI CLASS="li-itemize"> <B>lrange</B>(<I>start</I>, <I>stop</I>)
returns a list of expressions from <I>start</I> through <I>stop</I>.</LI><LI CLASS="li-itemize"> <B>lrange</B>(<I>start</I>, <I>stop</I>, <I>incr</I>)
returns a list of expressions from <I>start</I> through <I>stop</I> in steps of <I>incr</I>.</LI></UL><P>
<B>Description</B>
lrange is much more efficient than makelist for creating ranges, particularly for large lists (e.g. 10<SUP>5</SUP> or more items.) Functions for creating a list of numbers, in order of decreasing speed, are: <A HREF="#lrange"><TT>lrange</TT></A>, <A HREF="#table"><TT>table</TT></A>, <TT>create_list</TT>,<TT>makelist</TT>.</P><P><B>Arguments</B>
<TT>lrange</TT> requires between one and three arguments.
The third argument <I>incr</I> must be an expression that is not zero.</P><P>The first, second, and third arguments thread (distribute) over lists.</P><P><B>Options</B>
<TT>lrange</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) lrange(6);
(%o1) [1,2,3,4,5,6]
(%i1) lrange(2,6);
(%o1) [2,3,4,5,6]
(%i2) lrange(2,6,2);
(%o2) [2,4,6]
(%i3) lrange(6,1,-1);
(%o3) [6,5,4,3,2,1]
(%i4) lrange(6,1,-2);
(%o4) [6,4,2]
(%i5) lrange(6,ot-&gt;ar);
(%o5) &lt;[1,2,3,4,5,6]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The type of the first element and increment determine the type of 
the elements.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) lrange(1.0,6);
(%o1) [1.0,2.0,3.0,4.0,5.0,6.0]
(%i1) lrange(1.0b0,6);
(%o1) [1.0b0,2.0b0,3.0b0,4.0b0,5.0b0,6.0b0]
(%i2) lrange(1/2,6);
(%o2) [1/2,3/2,5/2,7/2,9/2,11/2]
(%i3) lrange(6.0,1,-1);
(%o3) [6.0,5.0,4.0,3.0,2.0,1.0]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Symbols can be used for limits or increments.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) lrange(x,x+4);
(%o1) [x,x+1,x+2,x+3,x+4]
(%i1) lrange(x,x+4*a,a);
(%o1) [x,x+a,x+2*a,x+3*a,x+4*a]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#makelist"><TT>makelist</TT></A>, <A HREF="#table"><TT>table</TT></A>, and <A HREF="#constant_list"><TT>constant_list</TT></A>.</P><!--TOC subsection Function: nest-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc97">9.12</A>  Function: nest<A NAME="sec:nest"></A></H3><!--SEC END --><P>
<A NAME="nest"></A></P><P>mext package: lists_aex</P><P>
<B>Description</B>
nest(f,x,n) returns f(...f(f(f(x)))...) where there are n nested calls of f.</P><P><B>Arguments</B>
<TT>nest</TT> requires three arguments.
The first argument <I>f</I> must be a map-able function.
The third argument <I>n</I> must be a non-negative integer.</P><P>The first and third arguments thread (distribute) over lists.</P><P><B>Options</B>
<TT>nest</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><!--TOC subsection Function: nest_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc98">9.13</A>  Function: nest_list<A NAME="sec:nest_list"></A></H3><!--SEC END --><P>
<A NAME="nest_list"></A>
<B>nest_list</B>(<I>f</I>, <I>x</I>, <I>n</I>)</P><P>mext package: lists_aex</P><P>
<B>Arguments</B>
<TT>nest_list</TT> requires three arguments.
The third argument <I>n</I> must be a non-negative integer.</P><P>The first and third arguments thread (distribute) over lists.</P><P><B>Options</B>
<TT>nest_list</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Find the first 10 primes after 100.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) nest_list(next_prime,100,10);
(%o1) [101,103,107,109,113,127,131,137,139,149]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#nest"><TT>nest</TT></A>, <A HREF="#fold"><TT>fold</TT></A>, and <A HREF="#fold_list"><TT>fold_list</TT></A>.</P><!--TOC subsection Function: nest_while-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc99">9.14</A>  Function: nest_while<A NAME="sec:nest_while"></A></H3><!--SEC END --><P>
<A NAME="nest_while"></A>
<B>nest_while</B>(<I>f</I>, <I>x</I>, <I>test</I> :optional <I>min</I>, <I>max</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>nest_while</B>(<I>f</I>, <I>x</I>, <I>test</I>)
applies <I>f</I> to <I>x</I> until <I>test</I> fails to return true when called on the nested result.</LI><LI CLASS="li-itemize"> <B>nest_while</B>(<I>f</I>, <I>x</I>, <I>test</I>, <I>min</I>)
applies <I>f</I> at least <I>min</I> times.</LI><LI CLASS="li-itemize"> <B>nest_while</B>(<I>f</I>, <I>x</I>, <I>test</I>, <I>min</I>, <I>max</I>)
applies <I>f</I> not more than <I>max</I> times.</LI></UL><P>
<B>Arguments</B>
<TT>nest_while</TT> requires between three and five arguments.
The fourth argument <I>min</I> must be a non-negative integer.
The fifth argument <I>max</I> must be a non-negative integer.</P><P>The first and third arguments thread (distribute) over lists.</P><P><B>Options</B>
<TT>nest_while</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Implementation</B>
This should be modified to allow applying test to more than just the most recent result.</P><!--TOC subsection Function: nreverse-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc100">9.15</A>  Function: nreverse<A NAME="sec:nreverse"></A></H3><!--SEC END --><P>
<A NAME="nreverse"></A>
<B>nreverse</B>(<I>e</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Destructively reverse the arguments of expression <I>e</I>. This is more efficient than using reverse.</P><P><B>Arguments</B>
<TT>nreverse</TT> requires one argument <I>e</I>, which must be non-atomic.</P><P><B>Examples</B></P><P>Be careful not to use <I>a</I> after applying nreverse. Do assign 
the result to another variable.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : lrange(10), b : nreverse(a);
(%o1) [10,9,8,7,6,5,4,3,2,1]
(%i1) a : lrange(10,ot-&gt;ar), b : nreverse(a);
(%o1) &lt;[10,9,8,7,6,5,4,3,2,1]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#reverse"><TT>reverse</TT></A>.</P><!--TOC subsection Function: partition_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc101">9.16</A>  Function: partition_list<A NAME="sec:partition_list"></A></H3><!--SEC END --><P>
<A NAME="partition_list"></A>
<B>partition_list</B>(<I>e</I>, <I>nlist</I> :optional <I>dlist</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>partition_list</B>(<I>e</I>, <I>n</I>)
partitions <I>e</I> into sublists of length <I>n</I></LI><LI CLASS="li-itemize"> <B>partition_list</B>(<I>e</I>, <I>n</I>, <I>d</I>)
partitions <I>e</I> into sublists of length <I>n</I> with offsets <I>d</I>.</LI></UL><P>
<B>Description</B>
Omitting <I>d</I> is equivalent to giving <I>d</I> equal to <I>n</I>. <I>e</I> can be any expression, not only a list. If <I>n</I> is a list, then <A HREF="#partition_list"><TT>partition_list</TT></A> partitions at sucessively deeper levels with elements of <I>n</I>. If <I>n</I> and <I>d</I> are lists, the 
first elementsof <I>n</I> and <I>d</I> apply at the highest level and so on. If <I>n</I> is a list and <I>d</I> is a number, then the offset <I>d</I> is used with each of the <I>n</I>.</P><P><B>Arguments</B>
<TT>partition_list</TT> requires either two or three arguments.
The first argument <I>e</I> must be non-atomic.
The second argument <I>nlist</I> must be an integer or a list of integers.
The third argument <I>dlist</I> must be an integer or a list of integers.</P><P><B>Examples</B></P><P>Partition the numbers from 1 through 10 into pairs.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) partition_list([1,2,3,4,5,6,7,8,9,10],2);
(%o1) [[1,2],[3,4],[5,6],[7,8],[9,10]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: select-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc102">9.17</A>  Function: select<A NAME="sec:select"></A></H3><!--SEC END --><P>
<A NAME="select"></A>
<B>select</B>(<I>expr</I>, <I>test</I> :optional <I>n</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Returns a list of all elements of <I>expr</I> for which <I>test</I> is true. <I>expr</I> may have any op. If <I>n</I> is supplied, then at most <I>n</I> elements are examined. <A HREF="#select"><TT>select</TT></A> is much faster than <TT>sublist</TT>, but may be less generally applicable.</P><P><B>Arguments</B>
<TT>select</TT> requires either two or three arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.
The third argument <I>n</I> must be a positive integer.</P><P>The second argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>select</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Select elements less than 3</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) select([1,2,3,4,5,6,7], lambda([x], is(x&lt;3)));
(%o1) [1,2]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Argument type: sequence specifier-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc103">9.18</A>  Argument type: sequence specifier<A NAME="sec:sequence specifier"></A></H3><!--SEC END --><P>
<A NAME="sequence specifier"></A></P><P>mext package: lists_aex</P><P>
<B>Description</B>
A sequence specification specifies a subsequence of the elements in an expression. A single positive number <I>n</I> means the first <I>n</I> elements. −<I>n</I> means the last <I>n</I> elements. A list of three numbers <CODE>[i1,i2,i3]</CODE> means the <CODE>i1</CODE>th through the <CODE>i2</CODE>th stepping by <CODE>i3</CODE>. If <CODE>i1</CODE> 
or <CODE>i2</CODE> are negative, they count from the end. If <CODE>i3</CODE> is negative, stepping is down and <CODE>i1</CODE> must be greater than or equal to <CODE>i2</CODE>. If <CODE>i3</CODE> is omitted, it is taken to be 1. A sequence specifiier can also be one of ’all ’none or ’reverse, which mean all elements, no 
elements or all elements in reverse order respectively.</P><P><B>See also</B>
<A HREF="#take"><TT>take</TT></A> and <A HREF="#string_take"><TT>string_take</TT></A>.</P><!--TOC subsection Function: table-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc104">9.19</A>  Function: table<A NAME="sec:table"></A></H3><!--SEC END --><P>
<A NAME="table"></A></P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>table</B>(<I>expr</I>, [<I>n</I>])
Evaluates expression <I>number</I> times. If <I>number</I> is not an integer or a floating point number, then <TT>float</TT> is called. If we have a floating point number, it is truncated into an integer. This type of iterator is the fastest, since no variable is bound.</LI><LI CLASS="li-itemize"> <B>table</B>(<I>expr</I>, [<I>variable</I>, <I>initial</I>, <I>end</I>, <I>step</I>])
Returns a list of evaluated expressions where <I>variable</I> (a symbol) is set to a value. The first element of the returned list is <I>expression</I> evaluated with <I>variable</I> set to <I>initial</I>. The <I>i</I>-th element of the returned list is <I>expression</I> evaluated with <I>variable</I> set to 
<I>initial</I> + (<I>i</I>−1) <I>step</I>. The iteration stops once the value is greater (if <I>step</I> is positive) or smaller (if <I>step</I> is negative) than <I>end</I>. Requirement: The difference between <I>end</I> and <I>intial</I> must return a <TT>numberp</TT> number. <I>step</I> must be a nonzero <TT>numberp</TT> number. This allows for iterators of rather general forms like <CODE>[i, %i - 2, %i, 0.1b0] </CODE>…</LI><LI CLASS="li-itemize"> <B>table</B>(<I>expr</I>, [<I>variable</I>, <I>initial</I>, <I>end</I>])
This iterator uses a step of 1 and is equal to [<I>variable</I>,<I>initial</I>,<I>end</I>, 1].</LI></UL><P>
<B>Arguments</B>
<TT>table</TT> requires two or more arguments.
The second argument <I>iterator1</I> must be a list.
Each of the remaining arguments must be a list.</P><P><B>Options</B>
<TT>table</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Attributes</B>
table has attributes: [hold_all]</P><P><B>Examples</B></P><P>Make a list of function values</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) table(sin(x),[x,0,2*%pi,%pi/4]);
(%o1) [0,1/sqrt(2),1,1/sqrt(2),0,-1/sqrt(2),-1,-1/sqrt(2),0]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Make a nested list.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) table( x^y, [x,1,2], [y,1,2]);
(%o1) [[1,1],[2,4]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#makelist"><TT>makelist</TT></A>, <A HREF="#lrange"><TT>lrange</TT></A>, and <A HREF="#constant_list"><TT>constant_list</TT></A>.</P><P><B>Author</B>
Ziga Lenarcic.</P><!--TOC subsection Function: take-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc105">9.20</A>  Function: take<A NAME="sec:take"></A></H3><!--SEC END --><P>
<A NAME="take"></A>
<B>take</B>(<I>e</I> :rest <I>v</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>take</B>(<I>e</I>, <I>n</I>)
returns a list of the first <I>n</I> elements of list or expression <I>e</I>.</LI><LI CLASS="li-itemize"> <B>take</B>(<I>e</I>, [<I>n1</I>, <I>n2</I>])
returns a list of the <I>n1</I>th through <I>n2</I>th elements of list or expression <I>e</I>.</LI><LI CLASS="li-itemize"> <B>take</B>(<I>e</I>, [<I>n1</I>, <I>n2</I>, <I>step</I>])
returns a list of the <I>n1</I>th through <I>n2</I>th elements stepping by <I>step</I> of list or expression <I>e</I>.</LI><LI CLASS="li-itemize"> <B>take</B>(<I>e</I>, -n )
returns the last <I>n</I> elements.</LI><LI CLASS="li-itemize"> <B>take</B>(<I>e</I>, <I>spec1</I>, <I>spec2</I>, <I>...</I>)
applies the sequence specifications at sucessively deeper levels in <I>e</I>.</LI></UL><P>
<B>Description</B>
<I>e</I> can have mixed lex and aex expressions on different levels. If more sequence specifications are given, they apply to sucessively deeper levels in <I>e</I>.</P><P><B>Arguments</B>
<TT>take</TT> requires one or more arguments. The first argument <I>e</I> must be non-atomic.
Each of the remaining arguments must be a sequence specification.</P><P><B>Examples</B></P><P>Take the first 3 elements of a list.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d,e],3);
(%o1) [a,b,c]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the last 3 elements of a list.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d,e],-3);
(%o1) [c,d,e]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the second through third elements of a list.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d,e],[2,3]);
(%o1) [b,c]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the second through tenth elements of a list counting by two.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([1,2,3,4,5,6,7,8,9,10],[2,10,2]);
(%o1) [2,4,6,8,10]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the last through first elements of a list counting backwards 
by one.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d],[-1,1,-1]);
(%o1) [d,c,b,a]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Shorthand for the previous example is ’reverse.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d],'reverse);
(%o1) [d,c,b,a]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the second through third elements at the first level and the 
last 2 elements at the second level.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([[a,b,c], [d,e,f], [g,h,i]], [2,3],-2);
(%o1) [[e,f],[h,i]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: take_while-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc106">9.21</A>  Function: take_while<A NAME="sec:take_while"></A></H3><!--SEC END --><P>
<A NAME="take_while"></A>
<B>take_while</B>(<I>expr</I>, <I>test</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>take_while</B>(<I>expr</I>, <I>test</I>)
collects the elements in <I>expr</I> until <I>test</I> fails on one of them. The op of the returned expression is the same as the op of <I>expr</I>.</LI></UL><P>
<B>Arguments</B>
<TT>take_while</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.</P><P>The second argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>take_while</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Take elements as long as they are negative.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take_while([-3,-10,-1,3,6,7,-4], lambda([x], is(x&lt;0)));
(%o1) [-3,-10,-1]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: tuples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc107">9.22</A>  Function: tuples<A NAME="sec:tuples"></A></H3><!--SEC END --><P>
<A NAME="tuples"></A>
<B>tuples</B>(<I>list-or-lists</I> :optional <I>n</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>tuples</B>(<I>list</I>, <I>n</I>)
Return a list of all lists of length <I>n</I> whose elements are chosen from <I>list</I>.</LI><LI CLASS="li-itemize"> <B>tuples</B>([<I>list1</I>, <I>list2</I>, <I>...</I>])
Return a list of all lists whose <I>i</I>_th element is chosen from <I>listi</I>.</LI></UL><P>
<B>Arguments</B>
<TT>tuples</TT> requires either one or two arguments.
The first argument <I>list-or-lists</I> must be non-atomic and represented by a lisp list.
The second argument <I>n</I> must be a non-negative integer.</P><P><B>Options</B>
<TT>tuples</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><P>Make all three letter words in the alphabet ‘a,b’.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) tuples([a,b],3);
(%o1) [[a,a,a],[a,a,b],[a,b,a],[a,b,b],[b,a,a],[b,a,b],[b,b,a],[b,b,b]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take all pairs chosen from two lists.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) tuples([ [0,1] , [x,y,z] ]);
(%o1) [[0,x],[0,y],[0,z],[1,x],[1,y],[1,z]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>tuples works for expressions other than lists.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) tuples(f(0,1),3);
(%o1) [f(0,0,0),f(0,0,1),f(0,1,0),f(0,1,1),f(1,0,0),f(1,0,1),f(1,1,0),f(1,1,1)]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC section Functions and Variables for Number Theory-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc108">10</A>  Functions and Variables for Number Theory</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#abundant_p"><TT>abundant_p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#amicable_p"><TT>amicable_p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#catalan_number"><TT>catalan_number</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#divisor_function"><TT>divisor_function</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#from_digits"><TT>from_digits</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#integer_digits"><TT>integer_digits</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#integer_string"><TT>integer_string</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#oeis_A092143"><TT>oeis_A092143</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#perfect_p"><TT>perfect_p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#prime_pi"><TT>prime_pi</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#prime_pi_soe"><TT>prime_pi_soe</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#prime_twins"><TT>prime_twins</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#primes1"><TT>primes1</TT></A>
</LI></UL><!--TOC subsection Function: abundant_p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc109">10.1</A>  Function: abundant_p<A NAME="sec:abundant_p"></A></H3><!--SEC END --><P>
<A NAME="abundant_p"></A>
<B>abundant_p</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns true if <I>n</I> is an abundant number. Otherwise, returns false.</P><P><B>Arguments</B>
<TT>abundant_p</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P>The first argument threads (distributes) over lists.</P><P><B>Examples</B></P><P>The abundant numbers between 1 and 100</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) select(lrange(100),abundant_p);
(%o1) [12,18,20,24,30,36,40,42,48,54,56,60,66,70,72,78,80,84,88,90,96,100]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, and <A HREF="#perfect_p"><TT>perfect_p</TT></A>.</P><!--TOC subsection Function: aliquot_sequence-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc110">10.2</A>  Function: aliquot_sequence<A NAME="sec:aliquot_sequence"></A></H3><!--SEC END --><P>
<A NAME="aliquot_sequence"></A>
<B>aliquot_sequence</B>(<I>k</I>, <I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
The aliquot sequence is a recursive sequence in which each term is the sum of the proper divisors of the previous term. This function returns the first <I>n</I> elements (counting from zero) in the aliquot sequence whose first term is <I>k</I>. The sequence is truncated at an element if it is zero or 
repeats the previous element.</P><P><B>Arguments</B>
<TT>aliquot_sequence</TT> requires two arguments.
The first argument <I>k</I> must be a positive integer.
The second argument <I>n</I> must be a non-negative integer.</P><P>The first and second arguments thread (distribute) over lists.</P><P><B>Examples</B></P><P>Perfect numbers give a repeating sequence of period 1.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) imap(lambda([x],aliquot_sequence(x,100)),[6,28,496,8128]);
(%o1) [[6],[28],[496],[8128]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Aspiring numbers are those which are not perfect, but terminate 
with a repeating perfect number.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) imap(lambda([x],aliquot_sequence(x,100)),[25, 95, 119, 143, 417, 445, 565, 608, 650, 652, 675, 685]);
(%o1) [[25,6],[95,25,6],[119,25,6],[143,25,6],[417,143,25,6],[445,95,25,6],[565,119,25,6],[608,652,496],[650,652,496],[652,496],[675,565,119,25,6],[685,143,25,6]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, <A HREF="#perfect_p"><TT>perfect_p</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><!--TOC subsection Function: aliquot_sum-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc111">10.3</A>  Function: aliquot_sum<A NAME="sec:aliquot_sum"></A></H3><!--SEC END --><P>
<A NAME="aliquot_sum"></A>
<B>aliquot_sum</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the aliquot sum of <I>n</I>. The aliquot sum of <I>n</I> is the sum of the proper divisors of <I>n</I>.</P><P><B>Arguments</B>
<TT>aliquot_sum</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P>The first argument threads (distributes) over lists.</P><P><B>Attributes</B>
aliquot_sum has attributes: [match_form]</P><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, <A HREF="#perfect_p"><TT>perfect_p</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><!--TOC subsection Function: amicable_p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc112">10.4</A>  Function: amicable_p<A NAME="sec:amicable_p"></A></H3><!--SEC END --><P>
<A NAME="amicable_p"></A>
<B>amicable_p</B>(<I>n</I>, <I>m</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns true if <I>n</I> and <I>m</I> are amicable, and false otherwise.</P><P><B>Arguments</B>
<TT>amicable_p</TT> requires two arguments.
The first argument <I>n</I> must be a positive integer.
The second argument <I>m</I> must be a positive integer.</P><P>The first and second arguments thread (distribute) over lists.</P><P><B>Examples</B></P><P>The first few amicable pairs.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) map(lambda([x],amicable_p(first(x),second(x))), [[220, 284], 
          [1184, 1210], [2620, 2924], [5020, 5564], [6232, 6368]]);
(%o1) [true,true,true,true,true]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: catalan_number-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc113">10.5</A>  Function: catalan_number<A NAME="sec:catalan_number"></A></H3><!--SEC END --><P>
<A NAME="catalan_number"></A>
<B>catalan_number</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the <I>n</I>th catalan number.</P><P><B>Arguments</B>
<TT>catalan_number</TT> requires one argument.</P><P>The first argument threads (distributes) over lists.</P><P><B>Examples</B></P><P>The catalan number for n from 1 through 12.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) map(catalan_number,lrange(12));
(%o1) [1,2,5,14,42,132,429,1430,4862,16796,58786,208012]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The n’th catalan number.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) catalan_number(n);
(%o1) binomial(2*n,n)/(n+1)
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>OEIS number: A000108.</P><!--TOC subsection Function: divisor_function-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc114">10.6</A>  Function: divisor_function<A NAME="sec:divisor_function"></A></H3><!--SEC END --><P>
<A NAME="divisor_function"></A>
<B>divisor_function</B>(<I>n</I> :optional <I>x</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the divisor function, or sum of positive divisors function </P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">σ<SUB><I>x</I></SUB>(<I>n</I>)=</TD><TD CLASS="dcell"><TABLE CLASS="display"><TR><TD CLASS="dcell" ALIGN="center">&nbsp;</TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><FONT SIZE=6>∑</FONT></TD></TR>
<TR><TD CLASS="dcell" ALIGN="center"><I>d</I>|<I>n</I></TD></TR>
</TABLE></TD><TD CLASS="dcell"> <I>d</I><SUP><I>x</I></SUP>,</TD></TR>
</TABLE><P> where <I>d</I>|<I>x</I> means <I>d</I> divides <I>n</I>. If <I>x</I> is omitted it takes the default value 0. Currently, complex values for x are not supported. After writing this, I noticed that the function is 
implemented in the maxima core and is callled <TT>divsum</TT>.</P><P><B>Arguments</B>
<TT>divisor_function</TT> requires either one or two arguments.
The first argument <I>n</I> must be a non-negative integer.
The second argument <I>x</I> must be a number.</P><P>The first and second arguments thread (distribute) over lists.</P><P><B>Attributes</B>
divisor_function has attributes: [match_form]</P><P>OEIS number: A000005 for x=0 and A000203 for x=1.</P><P><B>See also</B>
<A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, <A HREF="#perfect_p"><TT>perfect_p</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><!--TOC subsection Function: divisor_summatory-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc115">10.7</A>  Function: divisor_summatory<A NAME="sec:divisor_summatory"></A></H3><!--SEC END --><P>
<A NAME="divisor_summatory"></A>
<B>divisor_summatory</B>(<I>x</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the divisor summatory function <I>D</I>(<I>x</I>) for <I>x</I>. The <A HREF="#divisor_function"><TT>divisor_function</TT></A> σ<SUB>0</SUB>(<I>n</I>) counts the number of unique divisors of the natural number <I>n</I>. <I>D</I>(<I>x</I>) is the sum of σ<SUB>0</SUB>(<I>n</I>) over <I>n</I> ≤ <I>x</I>.</P><P><B>Arguments</B>
<TT>divisor_summatory</TT> requires one argument <I>x</I>, which must be a non-negative number.</P><P>The first argument threads (distributes) over lists.</P><P><B>Attributes</B>
divisor_summatory has attributes: [match_form]</P><P><B>Examples</B></P><P>D(n) for n from 1 through 12</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) map(divisor_summatory,lrange(12));
(%o1) [1,3,5,8,10,14,16,20,23,27,29,35]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>OEIS number: A006218.</P><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#perfect_p"><TT>perfect_p</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><!--TOC subsection Function: from_digits-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc116">10.8</A>  Function: from_digits<A NAME="sec:from_digits"></A></H3><!--SEC END --><P>
<A NAME="from_digits"></A>
<B>from_digits</B>(<I>digits</I> :optional <I>base</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>from_digits</B>(<I>digits</I>)
returns the integer represented by the decimal digits in the list or string <I>digits</I>.</LI><LI CLASS="li-itemize"> <B>from_digits</B>(<I>digits</I>, <I>base</I>)
returns the integer represented by the base <I>base</I> digits in the list or string<I>digits</I>.</LI></UL><P>
<B>Description</B>
<I>base</I> need not be number, but may be, for instance, a symbol. If <I>base</I> is a number it must be an integer between 2 and 36. <I>digits</I> may be a string rather than a list.</P><P><B>Arguments</B>
<TT>from_digits</TT> requires either one or two arguments.
The first argument <I>digits</I> must be a list (lex or aex) or a string.</P><P>The second argument threads (distributes) over lists.</P><P><B>See also</B>
<A HREF="#integer_digits"><TT>integer_digits</TT></A> and <A HREF="#integer_string"><TT>integer_string</TT></A>.</P><!--TOC subsection Function: integer_digits-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc117">10.9</A>  Function: integer_digits<A NAME="sec:integer_digits"></A></H3><!--SEC END --><P>
<A NAME="integer_digits"></A>
<B>integer_digits</B>(<I>n</I> :optional <I>base</I>, <I>len</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>integer_digits</B>(<I>n</I>)
returns a list of the base 10 digits of <I>n</I>.</LI><LI CLASS="li-itemize"> <B>integer_digits</B>(<I>n</I>, <I>base</I>)
returns a list of the base <I>base</I> digits of <I>n</I>.</LI><LI CLASS="li-itemize"> <B>integer_digits</B>(<I>n</I>, <I>base</I>, <I>len</I>)
returns a list of the base <I>base</I> digits of <I>n</I> padded with 0’s so that the total length of the list is <I>len</I>.</LI></UL><P>
<B>Arguments</B>
<TT>integer_digits</TT> requires between one and three arguments.
The first argument <I>n</I> must be an integer.
The second argument <I>base</I> must be a valid radix (an integer between 2 and 36).
The third argument <I>len</I> must be a non-negative integer.</P><P><B>Options</B>
<TT>integer_digits</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#from_digits"><TT>from_digits</TT></A> and <A HREF="#integer_string"><TT>integer_string</TT></A>.</P><P><B>Implementation</B>
gcl is much faster than the others. <CODE>integer_digits(2^(10^6))</CODE>: typical times for lisps: </P><P>ecl-12.12.1 0.09s, sbcl-1.1.11 0.5s, clisp-2.49 9s, ccl-1.9 62s, cmucl-20d error, gcl-2.6.(7,8,9) 0.09s, allegro-8.2 = 23s, Mma-3.0 = 5s, Mma-8 = 0.04s.</P><!--TOC subsection Function: integer_string-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc118">10.10</A>  Function: integer_string<A NAME="sec:integer_string"></A></H3><!--SEC END --><P>
<A NAME="integer_string"></A>
<B>integer_string</B>(<I>n</I> :optional <I>base</I>, <I>pad</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>integer_string</B>(<I>n</I>)
returns a string containing the decimal digits of the integer <I>n</I>.</LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, <I>base</I>)
returns a string containing the base <I>base</I> digits of the integer <I>n</I>.</LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, <I>base</I>, <I>pad</I>)
pads the string on the left with 0’s so that the length of the string is <I>pad</I>.</LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, "roman" )
returns a string containing the roman-numeral form of the integer <I>n</I>.</LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, "cardinal" )
returns a string containing the english word form of the integer (cardinal number) <I>n</I>.</LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, "ordinal" )
returns a string containing the english word form of the ordinal (counting) number <I>n</I>.</LI></UL><P>
<B>Arguments</B>
<TT>integer_string</TT> requires between one and three arguments.
The first argument <I>n</I> must be an integer.
The second argument <I>base</I> must be a valid radix (an integer between 2 and 36) or a string.
The third argument <I>pad</I> must be a positive integer.</P><P>The first, second, and third arguments thread (distribute) over lists.</P><P><B>See also</B>
<A HREF="#integer_digits"><TT>integer_digits</TT></A> and <A HREF="#from_digits"><TT>from_digits</TT></A>.</P><!--TOC subsection Function: oeis_A092143-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc119">10.11</A>  Function: oeis_A092143<A NAME="sec:oeis_A092143"></A></H3><!--SEC END --><P>
<A NAME="oeis_A092143"></A>
<B>oeis_A092143</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the cumulative product of all divisors of integers from 1 to <I>n</I>.</P><P><B>Arguments</B>
<TT>oeis_A092143</TT> requires one argument <I>n</I>, which must be a positive integer.</P><!--TOC subsection Function: perfect_p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc120">10.12</A>  Function: perfect_p<A NAME="sec:perfect_p"></A></H3><!--SEC END --><P>
<A NAME="perfect_p"></A>
<B>perfect_p</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns true if <I>n</I> is a perfect number. Otherwise, returns false.</P><P><B>Arguments</B>
<TT>perfect_p</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P>The first argument threads (distributes) over lists.</P><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><P><B>Implementation</B>
This function computes divisors. It would be far more efficient to use a table of known perfect numbers, as very few of them are accessible by current computer hardware.</P><!--TOC subsection Function: prime_pi-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc121">10.13</A>  Function: prime_pi<A NAME="sec:prime_pi"></A></H3><!--SEC END --><P>
<A NAME="prime_pi"></A>
<B>prime_pi</B>(<I>n</I>)</P><P>mext package: prime_pi</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>prime_pi</B>(<I>n</I>)
returns the number of primes less than or equal to <I>n</I>.</LI></UL><P>
<B>Description</B>
Computes the prime counting function. The option <I>threads</I> specifies the maximum number of cpu threads to use. The routine may use fewer threads, depending on the value of <I>n</I>. The value of <I>n</I> is limited to 2<SUP>64</SUP> that is, about 1.84e+18. </P><P>The percent of the calculation that is finished is printed during the calculation if the option <I>status</I> is true. The status will only work under some terminals.</P><P><B>Arguments</B>
<TT>prime_pi</TT> requires one argument <I>n</I>, which must be equivalent to an unsigned 64 bit integer
(that is, an integer between 0 and 2 to the power 64)
(We need to modify the doc system so we can use notation for powers in arg check strings.
.</P><P>The first argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>prime_pi</TT> takes options with default values: <TT>status-&gt;false</TT>, <TT>threads-&gt;1</TT>.
</P><P><B>See also</B>
<A HREF="#prime_pi_soe"><TT>prime_pi_soe</TT></A>, <A HREF="#next_prime"><TT>next_prime</TT></A>, and <A HREF="#prev_prime"><TT>prev_prime</TT></A>.</P><P><B>Implementation</B>
This algorithm is fast, especially for a general purpose mathematics program. It combines a segmented sieve implemented as a C library with tables.</P><P><B>Authors</B>
Kim Walisch (C library), Tomas Oliveira e Silva (tables), and John Lapeyre (lisp).</P><!--TOC subsection Function: prime_pi_soe-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc122">10.14</A>  Function: prime_pi_soe<A NAME="sec:prime_pi_soe"></A></H3><!--SEC END --><P>
<A NAME="prime_pi_soe"></A>
<B>prime_pi_soe</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
The prime counting function. The algorithm is the sieve of Eratosthenes. Internally an array of <I>n</I> bits is used.</P><P><B>Arguments</B>
<TT>prime_pi_soe</TT> requires one argument <I>n</I>, which must be a non-negative integer.</P><P><B>See also</B>
<A HREF="#prime_pi"><TT>prime_pi</TT></A>, <A HREF="#next_prime"><TT>next_prime</TT></A>, and <A HREF="#prev_prime"><TT>prev_prime</TT></A>.</P><P><B>Implementation</B>
This is not the most efficient way to compute primes.</P><!--TOC subsection Function: prime_twins-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc123">10.15</A>  Function: prime_twins<A NAME="sec:prime_twins"></A></H3><!--SEC END --><P>
<A NAME="prime_twins"></A>
<B>prime_twins</B>(<I>min</I> :optional <I>max</I>)</P><P>mext package: prime_pi</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>prime_twins</B>(<I>n</I>)
returns the number of prime twins less than or equal to <I>n</I>.</LI><LI CLASS="li-itemize"> <B>prime_twins</B>(<I>nmin</I>, <I>nmax</I>)
returns the number of prime twins between <I>nmin</I> and <I>max</I>.</LI></UL><P>
<B>Description</B>
The option <I>ktuplet</I> counts the <I>ktuplet</I>-constellation rather than the twins. <I>ktuplet</I> must be an integer between 1 and 7.</P><P><B>Arguments</B>
<TT>prime_twins</TT> requires either one or two arguments.
The first argument <I>min</I> must be equivalent to an unsigned 64 bit integer
(that is, an integer between 0 and 2 to the power 64)
(We need to modify the doc system so we can use notation for powers in arg check strings.
.
The second argument <I>max</I> must be equivalent to an unsigned 64 bit integer
(that is, an integer between 0 and 2 to the power 64)
(We need to modify the doc system so we can use notation for powers in arg check strings.
.</P><P>The first and second arguments thread (distribute) over lists.</P><P><B>Options</B>
<TT>prime_twins</TT> takes options with default values: <TT>ktuplet-&gt;2</TT>, <TT>status-&gt;false</TT>, <TT>threads-&gt;1</TT>.
</P><P><B>See also</B>
<A HREF="#prime_pi"><TT>prime_pi</TT></A>, <A HREF="#next_prime"><TT>next_prime</TT></A>, <A HREF="#prev_prime"><TT>prev_prime</TT></A>, and <A HREF="#primep"><TT>primep</TT></A>.</P><P><B>Implementation</B>
No tables are used in this algorithm.</P><!--TOC subsection Function: primes1-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc124">10.16</A>  Function: primes1<A NAME="sec:primes1"></A></H3><!--SEC END --><P>
<A NAME="primes1"></A>
<B>primes1</B>(<I>n1</I> :optional <I>n2</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>primes1</B>(<I>max</I>)
returns a list of the primes less than or equal to <I>max</I>.</LI><LI CLASS="li-itemize"> <B>primes1</B>(<I>min</I>, <I>max</I>)
returns a list of the primes between <I>min</I> and <I>max</I>.</LI></UL><P>
<B>Description</B>
The algorithm is the sieve of Eratosthenes. This is not an efficient algorithm.</P><P><B>Arguments</B>
<TT>primes1</TT> requires either one or two arguments.
The first argument <I>n1</I> must be a non-negative integer.
The second argument <I>n2</I> must be a non-negative integer.</P><P><B>Options</B>
<TT>primes1</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><!--TOC section Functions and Variables for Numerical Computation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc125">11</A>  Functions and Variables for Numerical Computation</H2><!--SEC END --><P>Functions for numerical computations: Numeric integration;
Mathematical functions— cos,sin,etc. —that accept only
numerical arguments. Tests of loops in untranslated code show that these are much
more efficient than using the standard maxima versions. But, for most applications, the
standard Maxima versions are probably ok.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#mquad_qag"><TT>mquad_qag</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mquad_qagi"><TT>mquad_qagi</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mquad_qagp"><TT>mquad_qagp</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mquad_qags"><TT>mquad_qags</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mquad_qawc"><TT>mquad_qawc</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mquad_qawf"><TT>mquad_qawf</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mquad_qawo"><TT>mquad_qawo</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mquad_qaws"><TT>mquad_qaws</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_abs"><TT>n_abs</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_acos"><TT>n_acos</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_acosh"><TT>n_acosh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_asin"><TT>n_asin</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_asinh"><TT>n_asinh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_atan"><TT>n_atan</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_atanh"><TT>n_atanh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_cos"><TT>n_cos</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_cosh"><TT>n_cosh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_exp"><TT>n_exp</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_expt"><TT>n_expt</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_log"><TT>n_log</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_sin"><TT>n_sin</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_sinh"><TT>n_sinh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_sqrt"><TT>n_sqrt</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_tan"><TT>n_tan</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_tanh"><TT>n_tanh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nintegrate"><TT>nintegrate</TT></A>
</LI></UL><!--TOC subsection Function: mquad_qag-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc126">11.1</A>  Function: mquad_qag<A NAME="sec:mquad_qag"></A></H3><!--SEC END --><P>
<A NAME="mquad_qag"></A>
<B>mquad_qag</B>(<I>fun</I>, <I>var</I>, <I>a</I>, <I>b</I>, <I>key</I>)</P><P>mext package: numerical</P><P>
<B>Description</B>
This is an interface to qag that is modified from <TT>quad_qag</TT>.</P><P><B>Arguments</B>
<TT>mquad_qag</TT> requires five arguments.
The second argument <I>var</I> must be a symbol or a subscripted variable.
The third argument <I>a</I> must be an expression that can be converted to a float.
The fourth argument <I>b</I> must be an expression that can be converted to a float.
The fifth argument <I>key</I> must be an integer between 1 and 6.</P><P><B>Options</B>
<TT>mquad_qag</TT> takes options with default values: <TT>match-&gt;false</TT>, <TT>epsrel-&gt;1.e-8</TT>, <TT>epsabs-&gt;0.0</TT>, <TT>limit-&gt;200</TT>.
</P><!--TOC subsection Function: mquad_qagi-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc127">11.2</A>  Function: mquad_qagi<A NAME="sec:mquad_qagi"></A></H3><!--SEC END --><P>
<A NAME="mquad_qagi"></A>
<B>mquad_qagi</B>(<I>fun</I>, <I>var</I>, <I>a</I>, <I>b</I>)</P><P>mext package: numerical</P><P>
<B>Description</B>
This is an interface to qagi that is modified from <TT>quad_qagi</TT>.</P><P><B>Arguments</B>
<TT>mquad_qagi</TT> requires four arguments.
The second argument <I>var</I> must be a symbol or a subscripted variable.
The third argument <I>a</I> must be inf, minf, or an expression that can be converted to a float.
The fourth argument <I>b</I> must be inf, minf, or an expression that can be converted to a float.</P><P><B>Options</B>
<TT>mquad_qagi</TT> takes options with default values: <TT>match-&gt;false</TT>, <TT>epsrel-&gt;1.e-8</TT>, <TT>epsabs-&gt;0.0</TT>, <TT>limit-&gt;200</TT>.
</P><!--TOC subsection Function: mquad_qagp-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc128">11.3</A>  Function: mquad_qagp<A NAME="sec:mquad_qagp"></A></H3><!--SEC END --><P>
<A NAME="mquad_qagp"></A>
<B>mquad_qagp</B>(<I>fun</I>, <I>var</I>, <I>a</I>, <I>b</I>, <I>points</I>)</P><P>mext package: numerical</P><P>
<B>Description</B>
This is an interface to qagp that is modified from <TT>quad_qagp</TT>.</P><P><B>Arguments</B>
<TT>mquad_qagp</TT> requires five arguments.
The second argument <I>var</I> must be a symbol or a subscripted variable.
The third argument <I>a</I> must be an expression that can be converted to a float.
The fourth argument <I>b</I> must be an expression that can be converted to a float.
The fifth argument <I>points</I> must be a list.</P><P><B>Options</B>
<TT>mquad_qagp</TT> takes options with default values: <TT>match-&gt;false</TT>, <TT>epsrel-&gt;1.e-8</TT>, <TT>epsabs-&gt;0.0</TT>, <TT>limit-&gt;200</TT>.
</P><!--TOC subsection Function: mquad_qags-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc129">11.4</A>  Function: mquad_qags<A NAME="sec:mquad_qags"></A></H3><!--SEC END --><P>
<A NAME="mquad_qags"></A>
<B>mquad_qags</B>(<I>fun</I>, <I>var</I>, <I>a</I>, <I>b</I>)</P><P>mext package: numerical</P><P>
<B>Description</B>
This is an interface to qags that is modified from <TT>quad_qags</TT>.</P><P><B>Arguments</B>
<TT>mquad_qags</TT> requires four arguments.
The second argument <I>var</I> must be a symbol or a subscripted variable.
The third argument <I>a</I> must be an expression that can be converted to a float.
The fourth argument <I>b</I> must be an expression that can be converted to a float.</P><P><B>Options</B>
<TT>mquad_qags</TT> takes options with default values: <TT>match-&gt;false</TT>, <TT>epsrel-&gt;1.e-8</TT>, <TT>epsabs-&gt;0.0</TT>, <TT>limit-&gt;200</TT>.
</P><!--TOC subsection Function: mquad_qawc-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc130">11.5</A>  Function: mquad_qawc<A NAME="sec:mquad_qawc"></A></H3><!--SEC END --><P>
<A NAME="mquad_qawc"></A>
<B>mquad_qawc</B>(<I>fun</I>, <I>var</I>, <I>c</I>, <I>a</I>, <I>b</I>)</P><P>mext package: numerical</P><P>
<B>Description</B>
This is an interface to qawc that is modified from <TT>quad_qawc</TT>.</P><P><B>Arguments</B>
<TT>mquad_qawc</TT> requires five arguments.
The second argument <I>var</I> must be a symbol or a subscripted variable.
The third argument <I>c</I> must be an expression that can be converted to a float.
The fourth argument <I>a</I> must be an expression that can be converted to a float.
The fifth argument <I>b</I> must be an expression that can be converted to a float.</P><P><B>Options</B>
<TT>mquad_qawc</TT> takes options with default values: <TT>match-&gt;false</TT>, <TT>epsrel-&gt;1.e-8</TT>, <TT>epsabs-&gt;0.0</TT>, <TT>limit-&gt;200</TT>.
</P><!--TOC subsection Function: mquad_qawf-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc131">11.6</A>  Function: mquad_qawf<A NAME="sec:mquad_qawf"></A></H3><!--SEC END --><P>
<A NAME="mquad_qawf"></A>
<B>mquad_qawf</B>(<I>fun</I>, <I>var</I>, <I>a</I>, <I>omega</I>, <I>trig</I>)</P><P>mext package: numerical</P><P>
<B>Description</B>
This is an interface to qawf that is modified from <TT>quad_qawf</TT>.</P><P><B>Arguments</B>
<TT>mquad_qawf</TT> requires five arguments.
The second argument <I>var</I> must be a symbol or a subscripted variable.
The third argument <I>a</I> must be an expression that can be converted to a float.
The fourth argument <I>omega</I> must be an expression that can be converted to a float.
The fifth argument <I>trig</I> must be one of ’($COS 1 </P><P><B>Options</B>
<TT>mquad_qawf</TT> takes options with default values: <TT>match-&gt;false</TT>, <TT>limlst-&gt;10</TT>, <TT>maxp1-&gt;100</TT>, <TT>epsabs-&gt;1.e-10</TT>, <TT>limit-&gt;200</TT>.
</P><!--TOC subsection Function: mquad_qawo-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc132">11.7</A>  Function: mquad_qawo<A NAME="sec:mquad_qawo"></A></H3><!--SEC END --><P>
<A NAME="mquad_qawo"></A>
<B>mquad_qawo</B>(<I>fun</I>, <I>var</I>, <I>a</I>, <I>b</I>, <I>omega</I>, <I>trig</I>)</P><P>mext package: numerical</P><P>
<B>Description</B>
This is an interface to qawo that is modified from <TT>quad_qawo</TT>.</P><P><B>Arguments</B>
<TT>mquad_qawo</TT> requires six arguments.
The second argument <I>var</I> must be a symbol or a subscripted variable.
The third argument <I>a</I> must be an expression that can be converted to a float.
The fourth argument <I>b</I> must be an expression that can be converted to a float.
The fifth argument <I>omega</I> must be an expression that can be converted to a float.
The sixth argument <I>trig</I> must be one of ’($COS 1 </P><P><B>Options</B>
<TT>mquad_qawo</TT> takes options with default values: <TT>match-&gt;false</TT>, <TT>epsrel-&gt;1.e-8</TT>, <TT>epsabs-&gt;0.0</TT>, <TT>limit-&gt;200</TT>, <TT>maxp1-&gt;100</TT>.
</P><!--TOC subsection Function: mquad_qaws-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc133">11.8</A>  Function: mquad_qaws<A NAME="sec:mquad_qaws"></A></H3><!--SEC END --><P>
<A NAME="mquad_qaws"></A>
<B>mquad_qaws</B>(<I>fun</I>, <I>var</I>, <I>a</I>, <I>b</I>, <I>alfa</I>, <I>beta</I>, <I>wfun</I>)</P><P>mext package: numerical</P><P>
<B>Description</B>
This is an interface to qaws that is modified from <TT>quad_qaws</TT>.</P><P><B>Arguments</B>
<TT>mquad_qaws</TT> requires seven arguments.
The second argument <I>var</I> must be a symbol or a subscripted variable.
The third argument <I>a</I> must be an expression that can be converted to a float.
The fourth argument <I>b</I> must be an expression that can be converted to a float.
The fifth argument <I>alfa</I> must be an expression that can be converted to a float.
The sixth argument <I>beta</I> must be an expression that can be converted to a float.
The seventh argument <I>wfun</I> must be an integer between 1 and 4.</P><P><B>Options</B>
<TT>mquad_qaws</TT> takes options with default values: <TT>match-&gt;false</TT>, <TT>epsrel-&gt;1.e-8</TT>, <TT>epsabs-&gt;0.0</TT>, <TT>limit-&gt;200</TT>.
</P><!--TOC subsection Function: n_abs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc134">11.9</A>  Function: n_abs<A NAME="sec:n_abs"></A></H3><!--SEC END --><P>
<A NAME="n_abs"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_abs calls the lisp numeric function ?abs. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_abs may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_acos-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc135">11.10</A>  Function: n_acos<A NAME="sec:n_acos"></A></H3><!--SEC END --><P>
<A NAME="n_acos"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_acos calls the lisp numeric function ?acos. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_acos may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_acosh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc136">11.11</A>  Function: n_acosh<A NAME="sec:n_acosh"></A></H3><!--SEC END --><P>
<A NAME="n_acosh"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_acosh calls the lisp numeric function ?acosh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_acosh may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_asin-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc137">11.12</A>  Function: n_asin<A NAME="sec:n_asin"></A></H3><!--SEC END --><P>
<A NAME="n_asin"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_asin calls the lisp numeric function ?asin. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_asin may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_asinh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc138">11.13</A>  Function: n_asinh<A NAME="sec:n_asinh"></A></H3><!--SEC END --><P>
<A NAME="n_asinh"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_asinh calls the lisp numeric function ?asinh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_asinh may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_atan-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc139">11.14</A>  Function: n_atan<A NAME="sec:n_atan"></A></H3><!--SEC END --><P>
<A NAME="n_atan"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_atan calls the lisp numeric function ?atan. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_atan may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_atanh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc140">11.15</A>  Function: n_atanh<A NAME="sec:n_atanh"></A></H3><!--SEC END --><P>
<A NAME="n_atanh"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_atanh calls the lisp numeric function ?atanh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_atanh may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_cos-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc141">11.16</A>  Function: n_cos<A NAME="sec:n_cos"></A></H3><!--SEC END --><P>
<A NAME="n_cos"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_cos calls the lisp numeric function ?cos. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_cos may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_cosh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc142">11.17</A>  Function: n_cosh<A NAME="sec:n_cosh"></A></H3><!--SEC END --><P>
<A NAME="n_cosh"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_cosh calls the lisp numeric function ?cosh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_cosh may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_exp-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc143">11.18</A>  Function: n_exp<A NAME="sec:n_exp"></A></H3><!--SEC END --><P>
<A NAME="n_exp"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_exp calls the lisp numeric function ?exp. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_exp may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_expt-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc144">11.19</A>  Function: n_expt<A NAME="sec:n_expt"></A></H3><!--SEC END --><P>
<A NAME="n_expt"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_expt calls the lisp numeric function ?expt. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_expt may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_log-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc145">11.20</A>  Function: n_log<A NAME="sec:n_log"></A></H3><!--SEC END --><P>
<A NAME="n_log"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_log calls the lisp numeric function ?log. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_log may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_sin-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc146">11.21</A>  Function: n_sin<A NAME="sec:n_sin"></A></H3><!--SEC END --><P>
<A NAME="n_sin"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_sin calls the lisp numeric function ?sin. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_sin may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_sinh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc147">11.22</A>  Function: n_sinh<A NAME="sec:n_sinh"></A></H3><!--SEC END --><P>
<A NAME="n_sinh"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_sinh calls the lisp numeric function ?sinh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_sinh may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_sqrt-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc148">11.23</A>  Function: n_sqrt<A NAME="sec:n_sqrt"></A></H3><!--SEC END --><P>
<A NAME="n_sqrt"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_sqrt calls the lisp numeric function ?sqrt. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_sqrt may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_tan-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc149">11.24</A>  Function: n_tan<A NAME="sec:n_tan"></A></H3><!--SEC END --><P>
<A NAME="n_tan"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_tan calls the lisp numeric function ?tan. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_tan may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: n_tanh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc150">11.25</A>  Function: n_tanh<A NAME="sec:n_tanh"></A></H3><!--SEC END --><P>
<A NAME="n_tanh"></A></P><P>mext package: aex</P><P>
<B>Description</B>
n_tanh calls the lisp numeric function ?tanh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_tanh may be considerably faster in some code, particularly untranslated code.</P><!--TOC subsection Function: nintegrate-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc151">11.26</A>  Function: nintegrate<A NAME="sec:nintegrate"></A></H3><!--SEC END --><P>
<A NAME="nintegrate"></A>
<B>nintegrate</B>(<I>expr</I>, <I>varspec</I> :optional <I>singlist</I>)</P><P>mext package: numerical</P><P>
<B>Description</B>
Numerically integrate <I>expr</I>, with the variable and limits supplied in the list <I>varspec</I> as [<I>var</I>,<I>lo</I>,<I>hi</I>]. Only one-dimensional integrals are implemented. <A HREF="#nintegrate"><TT>nintegrate</TT></A> automatically chooses and combines <TT>qags</TT>,<TT>qagp</TT>, and <TT>qagi</TT>. Some 
support for complex numbers is implemented. Some integrable singularities are found automatically. </P><P>If the option <I>call</I> is true, then calls made to quadpack are also returned in a list. If <I>call</I> is <I>short</I>, then only the name of the quadpack routine is included. </P><P>By default, information on the integration is returned with the results. If the option <I>info</I> is false, then only the result of the integration is returned. </P><P>If the option <I>sing</I> is false, then <A HREF="#nintegrate"><TT>nintegrate</TT></A> will not search for internal singularities, but user supplied singularities will still be used. </P><P>This function is not well tested and may give incorrect results. </P><P>See the Maxima documentation for quadpack.</P><P><B>Arguments</B>
<TT>nintegrate</TT> requires either two or three arguments.
The second argument <I>varspec</I> must be a list.
The third argument <I>singlist</I> must be a list.</P><P>The first argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>nintegrate</TT> takes options with default values: <TT>epsrel-&gt;1.e-8</TT>, <TT>epsabs-&gt;0</TT>, <TT>subint-&gt;200</TT>, <TT>info-&gt;true</TT>, <TT>words-&gt;true</TT>, <TT>calls-&gt;false</TT>, <TT>sing-&gt;true</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) nintegrate([x,x^2,x^3], [x,0,1], info-&gt;false);
(%o1) [0.5,.3333333333333334,0.25]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i2) nintegrate(sin(sin(x)), [x,0,2]);
(%o2) [1.24706, 1.38451e-14, 21, no problems]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Integrate over a semi-infinite interval with an internal singularity. The location of the singularity is
supplied. This cannot be done with a single call to quadpack routines.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i3) nintegrate(1/sqrt(abs(1-x))*exp(-x),[x,0,inf], [1] );
(%o3) [1.72821, 1.87197e-10, 660, no problems]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>If a list of possible singular points is not supplied, then they will be searched for using <TT>solve</TT>.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i4) nintegrate(1/sqrt(abs(1-x))*exp(-x),[x,0,inf]);
(%o4) [1.72821, 1.87197e-10, 660, no problems]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>In some cases, complex numbers are treated correctly. (The simplifier replaces <CODE>cos(%i*x)</CODE> with <CODE>cosh(x)</CODE> before the routine is called. So this works with <TT>quad_qags</TT> as well.)</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i5) nintegrate( cos(%i*x), [x,0,1]);
(%o5) [1.1752, 1.30474e-14, 21, no problems]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i6) sinh(1.0);
(%o6) 1.1752
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>But, the quadpack routines cannot handle the complex numbers in this example.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i7) nintegrate(exp(%i*x) * exp(-x*x), [x,0,inf]);
(%o7) [.424436 %i + .690194, 4.988325e-9, 300, no problems]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Return quadpack error code rather than error text.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i8) nintegrate(sin(sin(x)), [x,0,2], words-&gt;false);
(%o8) [1.24706, 1.38451e-14, 21, 0]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Request a relative error.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i9) nintegrate(exp(%i*x) * exp(-x*x), [x,0,inf], epsrel -&gt; 1e-12);
(%o9) [.424436 %i + .690194, 1.06796e-13, 480, no problems]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Trying to do the integral with too few sub-intervals fails.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i10) nintegrate(1/(1+x^2), [x, 0, inf], subint -&gt; 2, epsrel -&gt; 1e-10);
(%o10) [1.5708, 2.57779e-10, 45, too many sub-intervals]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>This integral is not handled well. Giving limits of <CODE>minf</CODE> and <CODE>inf</CODE> fails.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i11) nintegrate(exp(%i*x*x),[x,-200,200],subint-&gt;10000);
(%o11) [1.25170114 %i + 1.25804682, 2.507635982e-8, 760578, no problems]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i12) integrate(exp(%i*x*x),x,minf,inf);
(%o12) sqrt(%pi)*(%i/sqrt(2)+1/sqrt(2))
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i13) rectform(float(%));
(%o13) 1.25331414*%i+1.25331414
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Return a list of calls made to quadpack.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i14) nintegrate(1/sqrt(abs(1-x)) * exp(-x),[x,0,inf], calls-&gt;true);
(%o14) [1.72821,1.87197e-10,660, no problems,
 [quad_qagi(%e^-x/sqrt(abs(x-1)),x,1.0,inf,epsrel = 1.e-8,epsabs = 0,limit = 200),
  quad_qagp(%e^-x/sqrt(abs(x-1)),x,0,1.0,[],epsrel = 1.e-8,epsabs = 0,limit = 200)]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Here we must supply the roots of <CODE>sin(x)</CODE> within the range of integration.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i15) nintegrate(1/(sqrt(sin(x))),[x,0,10], [%pi,2*%pi,3*%pi]);
(%o15) [10.48823021716687 - 6.769465521725385 %i, 9.597496930524585e-8, 1596, no problems]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#quad_qags"><TT>quad_qags</TT></A>, <A HREF="#quad_qagi"><TT>quad_qagi</TT></A>, and <A HREF="#quad_qagp"><TT>quad_qagp</TT></A>.</P><!--TOC section Functions and Variables for Numerics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc152">12</A>  Functions and Variables for Numerics</H2><!--SEC END --><P>These are mathematical functions— cos,sin,etc. —that accept only
numerical arguments. Tests of loops in untranslated code show that these are much
more efficient than using the standard maxima versions. But, for most applications, the
standard maxima versions are probably ok.
</P><!--TOC section Functions and Variables for Predicates-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc153">13</A>  Functions and Variables for Predicates</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#aex_p"><TT>aex_p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#cmplength"><TT>cmplength</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#length0p"><TT>length0p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#length1p"><TT>length1p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#length_eq"><TT>length_eq</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#type_of"><TT>type_of</TT></A>
</LI></UL><!--TOC subsection Function: aex_p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc154">13.1</A>  Function: aex_p<A NAME="sec:aex_p"></A></H3><!--SEC END --><P>
<A NAME="aex_p"></A>
<B>aex_p</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Returns true if <I>e</I> is an aex expression, otherwise false.</P><P><B>Arguments</B>
<TT>aex_p</TT> requires one argument.</P><!--TOC subsection Function: cmplength-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc155">13.2</A>  Function: cmplength<A NAME="sec:cmplength"></A></H3><!--SEC END --><P>
<A NAME="cmplength"></A>
<B>cmplength</B>(<I>e</I>, <I>n</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
return the smaller of <I>n</I> and <CODE>length(e)</CODE>. This is useful if <I>e</I> is very large and <I>n</I> is small, so that computing the entire length of <I>e</I> is inefficient. Expression <I>e</I> can be either a lex of aex expression.</P><P><B>Arguments</B>
<TT>cmplength</TT> requires two arguments.
The second argument <I>n</I> must be a non-negative integer.</P><P><B>See also</B>
<A HREF="#length0p"><TT>length0p</TT></A>, <A HREF="#length_eq"><TT>length_eq</TT></A>, and <A HREF="#length1p"><TT>length1p</TT></A>.</P><P><B>Implementation</B>
cmplength is implemented with defmfun1, which slows things down a bit. So be cautious using it in a tight loop.</P><!--TOC subsection Function: length0p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc156">13.3</A>  Function: length0p<A NAME="sec:length0p"></A></H3><!--SEC END --><P>
<A NAME="length0p"></A>
<B>length0p</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Returns true if &lt;e&gt; is of length 0, false otherwise. This implementation traverse no more elements of &lt;e&gt; than necessary to return the result.</P><P><B>Arguments</B>
<TT>length0p</TT> requires one argument <I>e</I>, which must be a string or non-atomic.</P><P><B>See also</B>
<A HREF="#cmplength"><TT>cmplength</TT></A>, <A HREF="#length_eq"><TT>length_eq</TT></A>, and <A HREF="#length1p"><TT>length1p</TT></A>.</P><P><B>Implementation</B>
length0p is implemented with defmfun1, which slows things down a bit. So be cautious using it in a tight loop.</P><!--TOC subsection Function: length1p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc157">13.4</A>  Function: length1p<A NAME="sec:length1p"></A></H3><!--SEC END --><P>
<A NAME="length1p"></A>
<B>length1p</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Returns true if <I>e</I> is of length 1, false otherwise. This implementation traverse no more elements of <I>e</I> than necessary to return the result.</P><P><B>Arguments</B>
<TT>length1p</TT> requires one argument <I>e</I>, which must be a string or non-atomic.</P><P><B>See also</B>
<A HREF="#length0p"><TT>length0p</TT></A>, <A HREF="#cmplength"><TT>cmplength</TT></A>, and <A HREF="#length_eq"><TT>length_eq</TT></A>.</P><P><B>Implementation</B>
length1p is implemented with defmfun1, which slows things down a bit. So be cautious using it in a tight loop.</P><!--TOC subsection Function: length_eq-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc158">13.5</A>  Function: length_eq<A NAME="sec:length_eq"></A></H3><!--SEC END --><P>
<A NAME="length_eq"></A>
<B>length_eq</B>(<I>e</I>, <I>n</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Returns true if <I>e</I> is of length <I>n</I>, false otherwise. This implementation traverses no more elements of <I>e</I> than necessary to return the result.</P><P><B>Arguments</B>
<TT>length_eq</TT> requires two arguments.
The first argument <I>e</I> must be a string or non-atomic.
The second argument <I>n</I> must be a non-negative integer.</P><P><B>See also</B>
<A HREF="#length0p"><TT>length0p</TT></A>, <A HREF="#cmplength"><TT>cmplength</TT></A>, and <A HREF="#length1p"><TT>length1p</TT></A>.</P><P><B>Implementation</B>
length_eq is implemented with defmfun1, which slows things down a bit. So be cautious using it in a tight loop.</P><!--TOC subsection Function: type_of-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc159">13.6</A>  Function: type_of<A NAME="sec:type_of"></A></H3><!--SEC END --><P>
<A NAME="type_of"></A>
<B>type_of</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Return something like the ‘type’ of a maxima expression. <A HREF="#type_of"><TT>type_of</TT></A> uses the lisp function <CODE>type-of</CODE>. Currently, <A HREF="#type_of"><TT>type_of</TT></A> is a bit ill-defined; it may be better called ‘what-is-this?’. </P><P>If the option <I>info</I> is true, then more information is returned on properties and the underlying maxima and lisp representations.</P><P><B>Arguments</B>
<TT>type_of</TT> requires one argument.</P><P><B>Options</B>
<TT>type_of</TT> takes options with default values: <TT>info-&gt;false</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) type_of(1);
(%o1) integer
(%i1) type_of(1, info-&gt;true);
(%o1) [integer,lisp_bit]
(%i2) type_of(1.0);
(%o2) lisp_double_float
(%i3) type_of(1.0b0);
(%o3) bfloat
(%i4) type_of(1/3);
(%o4) /
(%i5) type_of(1/3, info-&gt;true);
(%o5) ["/",rat]
(%i6) type_of("dog");
(%o6) string
(%i7) type_of([1,2,3]);
(%o7) [
(%i8) type_of(aex([1,2,3]));
(%o8) [
(%i9) type_of(%e);
(%o9) symbol
(%i10) type_of(%i);
(%o10) symbol
(%i11) type_of(%i+1);
(%o11) +
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>type_of returns the type of the lisp struct corresponding to a 
maxima object.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) load(graphs)$
(%i2) type_of(new_graph());
(%o2)   graph
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC section Functions and Variables for Program Flow-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc160">14</A>  Functions and Variables for Program Flow</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#error_str"><TT>error_str</TT></A>
</LI></UL><!--TOC subsection Function: error_str-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc161">14.1</A>  Function: error_str<A NAME="sec:error_str"></A></H3><!--SEC END --><P>
<A NAME="error_str"></A>
<B>error_str</B>()</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Returns the last error message as a string. This differs from <TT>errormsg</TT>, which prints the error message.</P><P><B>Arguments</B>
<TT>error_str</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#error"><TT>error</TT></A> and <A HREF="#errormsg"><TT>errormsg</TT></A>.</P><!--TOC section Functions and Variables for Quicklisp-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc162">15</A>  Functions and Variables for Quicklisp</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#quicklisp_apropos"><TT>quicklisp_apropos</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#quicklisp_install"><TT>quicklisp_install</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#quicklisp_load"><TT>quicklisp_load</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#quicklisp_start"><TT>quicklisp_start</TT></A>
</LI></UL><!--TOC subsection Function: quicklisp_apropos-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc163">15.1</A>  Function: quicklisp_apropos<A NAME="sec:quicklisp_apropos"></A></H3><!--SEC END --><P>
<A NAME="quicklisp_apropos"></A>
<B>quicklisp_apropos</B>(<I>term</I>)</P><P>mext package: quicklisp</P><P>
<B>Description</B>
Search quicklisp for lisp ‘systems’ (packages) matching <I>term</I>.</P><P><B>Arguments</B>
<TT>quicklisp_apropos</TT> requires one argument <I>term</I>, which must be a string.</P><!--TOC subsection Function: quicklisp_install-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc164">15.2</A>  Function: quicklisp_install<A NAME="sec:quicklisp_install"></A></H3><!--SEC END --><P>
<A NAME="quicklisp_install"></A>
<B>quicklisp_install</B>()</P><P>mext package: quicklisp</P><P>
<B>Description</B>
Download and install quicklisp from the internet. This is usually done automatically as the final step of building and installing the maxima interface to quicklisp.</P><P><B>Arguments</B>
<TT>quicklisp_install</TT> requires zero arguments.</P><!--TOC subsection Function: quicklisp_load-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc165">15.3</A>  Function: quicklisp_load<A NAME="sec:quicklisp_load"></A></H3><!--SEC END --><P>
<A NAME="quicklisp_load"></A>
<B>quicklisp_load</B>(<I>package_name</I>)</P><P>mext package: quicklisp</P><P>
<B>Description</B>
Load the asdf lisp package <I>package_name</I>, or, if not installed, install from the internet and then load.</P><P><B>Arguments</B>
<TT>quicklisp_load</TT> requires one argument <I>package_name</I>, which must be a string.</P><!--TOC subsection Function: quicklisp_start-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc166">15.4</A>  Function: quicklisp_start<A NAME="sec:quicklisp_start"></A></H3><!--SEC END --><P>
<A NAME="quicklisp_start"></A>
<B>quicklisp_start</B>()</P><P>mext package: quicklisp</P><P>
<B>Description</B>
Load (setup) quicklisp. It must already be installed.</P><P><B>Arguments</B>
<TT>quicklisp_start</TT> requires zero arguments.</P><!--TOC section Functions and Variables for Runtime Environment-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc167">16</A>  Functions and Variables for Runtime Environment</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#allow_kill"><TT>allow_kill</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#allow_kill_share"><TT>allow_kill_share</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#chdir"><TT>chdir</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#dir_exists"><TT>dir_exists</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#dirstack"><TT>dirstack</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#dont_kill"><TT>dont_kill</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#dont_kill_share"><TT>dont_kill_share</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#get_dont_kill"><TT>get_dont_kill</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#homedir"><TT>homedir</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#lisp_bin_ext"><TT>lisp_bin_ext</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#lisp_type"><TT>lisp_type</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#lisp_type_symbol"><TT>lisp_type_symbol</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#lisp_version"><TT>lisp_version</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#list_directory"><TT>list_directory</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#maxima_version"><TT>maxima_version</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mcompile_file"><TT>mcompile_file</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_clear"><TT>mext_clear</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_find_package"><TT>mext_find_package</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_info"><TT>mext_info</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_list"><TT>mext_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_list_loaded"><TT>mext_list_loaded</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_list_package"><TT>mext_list_package</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_test"><TT>mext_test</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_verbose"><TT>mext_verbose</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mtranslate_file"><TT>mtranslate_file</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#popdir"><TT>popdir</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#probe_file"><TT>probe_file</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#pwd"><TT>pwd</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#require"><TT>require</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#timing"><TT>timing</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#truename"><TT>truename</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#updir"><TT>updir</TT></A>
</LI></UL><!--TOC subsection Function: allow_kill-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc168">16.1</A>  Function: allow_kill<A NAME="sec:allow_kill"></A></H3><!--SEC END --><P>
<A NAME="allow_kill"></A>
<B>allow_kill</B>( :rest <I>items</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Remove <I>item</I>s from the list of symbols that are not killed by <CODE>kill(all)</CODE>. This facility is part of the maxima core, but is apparantly unused. Maybe putting a property in the symbol’s property list would be better.</P><P><B>Arguments</B>
<TT>allow_kill</TT> requires zero or more arguments.</P><P><B>Attributes</B>
allow_kill has attributes: [hold_all]</P><P><B>See also</B>
<A HREF="#dont_kill"><TT>dont_kill</TT></A>, <A HREF="#dont_kill_share"><TT>dont_kill_share</TT></A>, and <A HREF="#get_dont_kill"><TT>get_dont_kill</TT></A>.</P><!--TOC subsection Function: allow_kill_share-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc169">16.2</A>  Function: allow_kill_share<A NAME="sec:allow_kill_share"></A></H3><!--SEC END --><P>
<A NAME="allow_kill_share"></A>
<B>allow_kill_share</B>(<I>package</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Allow symbols in maxima share package <I>package</I> from being killed by <TT>kill</TT>. This undoes the effect of <A HREF="#dont_kill_share"><TT>dont_kill_share</TT></A>. Currently (if this document is up-to-date) only ‘basic’ and ‘lrats’ are in the database.</P><P><B>Arguments</B>
<TT>allow_kill_share</TT> requires one argument <I>package</I>, which must be a string or a symbol.</P><P>The first argument threads (distributes) over lists.</P><!--TOC subsection Function: chdir-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc170">16.3</A>  Function: chdir<A NAME="sec:chdir"></A></H3><!--SEC END --><P>
<A NAME="chdir"></A>
<B>chdir</B>( :optional <I>dir</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>chdir</B>()
Set the working directory to the value it had when mext was loaded.</LI><LI CLASS="li-itemize"> <B>chdir</B>(<I>dir</I>)
Set the working directory to <I>dir</I>.</LI></UL><P>
<B>Description</B>
Set the working directory for maxima/lisp. With some lisps, such as cmu lisp the system directory is changed as well. This should be made uniform across lisp implementations.</P><P><B>Arguments</B>
<TT>chdir</TT> requires either zero or one arguments. If present, the argument <I>dir</I> must be a a string.</P><P><B>See also</B>
<A HREF="#pwd"><TT>pwd</TT></A>, <A HREF="#popdir"><TT>popdir</TT></A>, <A HREF="#updir"><TT>updir</TT></A>, <A HREF="#dirstack"><TT>dirstack</TT></A>, and <A HREF="#list_directory"><TT>list_directory</TT></A>.</P><!--TOC subsection Function: dir_exists-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc171">16.4</A>  Function: dir_exists<A NAME="sec:dir_exists"></A></H3><!--SEC END --><P>
<A NAME="dir_exists"></A>
<B>dir_exists</B>(<I>dir</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Returns the pathname as a string if <I>dir</I> exists, and <CODE>false</CODE> otherwise.</P><P><B>Arguments</B>
<TT>dir_exists</TT> requires one argument <I>dir</I>, which must be a string.</P><P>The first argument threads (distributes) over lists.</P><!--TOC subsection Function: dirstack-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc172">16.5</A>  Function: dirstack<A NAME="sec:dirstack"></A></H3><!--SEC END --><P>
<A NAME="dirstack"></A>
<B>dirstack</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Return a list of the directories on the directory stack. This list is manipulated with <A HREF="#chdir"><TT>chdir</TT></A>, <A HREF="#updir"><TT>updir</TT></A>, and <A HREF="#popdir"><TT>popdir</TT></A>.</P><P><B>Arguments</B>
<TT>dirstack</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#chdir"><TT>chdir</TT></A>, <A HREF="#pwd"><TT>pwd</TT></A>, <A HREF="#popdir"><TT>popdir</TT></A>, <A HREF="#updir"><TT>updir</TT></A>, and <A HREF="#list_directory"><TT>list_directory</TT></A>.</P><!--TOC subsection Function: dont_kill-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc173">16.6</A>  Function: dont_kill<A NAME="sec:dont_kill"></A></H3><!--SEC END --><P>
<A NAME="dont_kill"></A>
<B>dont_kill</B>( :rest <I>item</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Add the <I>item</I>s to the list of symbols that are not killed by <CODE>kill(all)</CODE>. This facility is part of the maxima core, but is apparantly unused. Maybe putting a property in the symbol’s property list would be better.</P><P><B>Arguments</B>
<TT>dont_kill</TT> requires zero or more arguments.</P><P><B>Attributes</B>
dont_kill has attributes: [hold_all]</P><P><B>See also</B>
<A HREF="#dont_kill_share"><TT>dont_kill_share</TT></A>, <A HREF="#get_dont_kill"><TT>get_dont_kill</TT></A>, and <A HREF="#allow_kill"><TT>allow_kill</TT></A>.</P><!--TOC subsection Function: dont_kill_share-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc174">16.7</A>  Function: dont_kill_share<A NAME="sec:dont_kill_share"></A></H3><!--SEC END --><P>
<A NAME="dont_kill_share"></A>
<B>dont_kill_share</B>(<I>package</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Prevent symbols in maxima share package <I>package</I> from being killed by <TT>kill</TT>. Currently (if this document is up-to-date) only ‘basic’ and ‘lrats’ are in the database.</P><P><B>Arguments</B>
<TT>dont_kill_share</TT> requires one argument <I>package</I>, which must be a string or a symbol.</P><P>The first argument threads (distributes) over lists.</P><P><B>See also</B>
<A HREF="#dont_kill"><TT>dont_kill</TT></A>, <A HREF="#get_dont_kill"><TT>get_dont_kill</TT></A>, and <A HREF="#allow_kill"><TT>allow_kill</TT></A>.</P><!--TOC subsection Function: get_dont_kill-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc175">16.8</A>  Function: get_dont_kill<A NAME="sec:get_dont_kill"></A></H3><!--SEC END --><P>
<A NAME="get_dont_kill"></A>
<B>get_dont_kill</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Returns the list of symbols that are not killed by <CODE>kill(all)</CODE>. Items are added to this list with <A HREF="#dont_kill"><TT>dont_kill</TT></A>.</P><P><B>Arguments</B>
<TT>get_dont_kill</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#dont_kill"><TT>dont_kill</TT></A>, <A HREF="#dont_kill_share"><TT>dont_kill_share</TT></A>, and <A HREF="#allow_kill"><TT>allow_kill</TT></A>.</P><!--TOC subsection Variable: homedir-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc176">16.9</A>  Variable: homedir<A NAME="sec:homedir"></A></H3><!--SEC END --><P>
<A NAME="homedir"></A></P><P>mext package: mext_defmfun1</P><P>
default value <CODE>/home/jlapeyre/</CODE>.</P><P><B>Description</B>
The user’s home directory.</P><!--TOC subsection Variable: lisp_bin_ext-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc177">16.10</A>  Variable: lisp_bin_ext<A NAME="sec:lisp_bin_ext"></A></H3><!--SEC END --><P>
<A NAME="lisp_bin_ext"></A></P><P>mext package: mext_defmfun1</P><P>
default value <CODE>fasl</CODE>.</P><P><B>Description</B>
The extension of compiled lisp binaries for the lisp implementation used by Maxima. This should be read-only. Setting it has no effect.</P><!--TOC subsection Variable: lisp_type-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc178">16.11</A>  Variable: lisp_type<A NAME="sec:lisp_type"></A></H3><!--SEC END --><P>
<A NAME="lisp_type"></A></P><P>mext package: mext_defmfun1</P><P>
default value <CODE>SBCL</CODE>.</P><P><B>Description</B>
The name of the lisp implementation on which Maxima is running.</P><!--TOC subsection Function: lisp_type_symbol-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc179">16.12</A>  Function: lisp_type_symbol<A NAME="sec:lisp_type_symbol"></A></H3><!--SEC END --><P>
<A NAME="lisp_type_symbol"></A></P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Returns a maxima symbol representing the lisp vendor. For example, gcl, sbcl, clisp, ...</P><!--TOC subsection Variable: lisp_version-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc180">16.13</A>  Variable: lisp_version<A NAME="sec:lisp_version"></A></H3><!--SEC END --><P>
<A NAME="lisp_version"></A></P><P>mext package: mext_defmfun1</P><P>
default value <CODE>1.1.11</CODE>.</P><P><B>Description</B>
The lisp version number of the lisp implementation on which Maxima is running.</P><!--TOC subsection Function: list_directory-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc181">16.14</A>  Function: list_directory<A NAME="sec:list_directory"></A></H3><!--SEC END --><P>
<A NAME="list_directory"></A>
<B>list_directory</B>( :optional <I>dir</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Returns a directory listing for <I>dir</I> or the current directory if no argument is given.</P><P><B>Arguments</B>
<TT>list_directory</TT> requires either zero or one arguments. If present, the argument <I>dir</I> must be a a string.</P><P>The first argument threads (distributes) over lists.</P><P><B>See also</B>
<A HREF="#chdir"><TT>chdir</TT></A>, <A HREF="#pwd"><TT>pwd</TT></A>, <A HREF="#popdir"><TT>popdir</TT></A>, <A HREF="#updir"><TT>updir</TT></A>, and <A HREF="#dirstack"><TT>dirstack</TT></A>.</P><!--TOC subsection Variable: maxima_version-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc182">16.15</A>  Variable: maxima_version<A NAME="sec:maxima_version"></A></H3><!--SEC END --><P>
<A NAME="maxima_version"></A></P><P>mext package: mext_defmfun1</P><P>
default value <CODE>5.31.0</CODE>.</P><P><B>Description</B>
The Maxima version number.</P><!--TOC subsection Function: mcompile_file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc183">16.16</A>  Function: mcompile_file<A NAME="sec:mcompile_file"></A></H3><!--SEC END --><P>
<A NAME="mcompile_file"></A>
<B>mcompile_file</B>(<I>input-file</I> :optional <I>bin_file</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Like <TT>compile_file</TT>, except that the intermediate, translated filename may be specified as an option. If the intermediate filename, <I>is not given, then </I>,it will be written in the same directory as the ouput (binary) file.</P><P><B>Arguments</B>
<TT>mcompile_file</TT> requires either one or two arguments.
The first argument <I>input-file</I> must be a string.
The second argument <I>bin_file</I> must be a string.</P><P>The first argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>mcompile_file</TT> takes options with default values: <TT>tr_file-&gt;false</TT>.
</P><!--TOC subsection Function: mext_clear-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc184">16.17</A>  Function: mext_clear<A NAME="sec:mext_clear"></A></H3><!--SEC END --><P>
<A NAME="mext_clear"></A>
<B>mext_clear</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Clears the list of mext packages that have been loaded with require. Subsequent calls to require will reload the packages.</P><P><B>Arguments</B>
<TT>mext_clear</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#mext_list_loaded"><TT>mext_list_loaded</TT></A>, <A HREF="#mext_list"><TT>mext_list</TT></A>, <A HREF="#mext_info"><TT>mext_info</TT></A>, <A HREF="#mext_list_package"><TT>mext_list_package</TT></A>, and <A HREF="#mext_find_package"><TT>mext_find_package</TT></A>.</P><!--TOC subsection Function: mext_find_package-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc185">16.18</A>  Function: mext_find_package<A NAME="sec:mext_find_package"></A></H3><!--SEC END --><P>
<A NAME="mext_find_package"></A>
<B>mext_find_package</B>( :rest <I>items</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Find mext packages in which the function or variable <I>items</I> are defined. This only works if the package has been loaded, and its symbols registered. If more than one package is found, then all are listed. If the option <I>file</I> is true, then the filename in which the item is defined is also 
returned.</P><P><B>Arguments</B>
<TT>mext_find_package</TT> requires zero or more arguments.
Each of the arguments must be a string or a symbol.</P><P><B>Options</B>
<TT>mext_find_package</TT> takes options with default values: <TT>file-&gt;false</TT>.
</P><P><B>See also</B>
<A HREF="#mext_list_loaded"><TT>mext_list_loaded</TT></A>, <A HREF="#mext_list"><TT>mext_list</TT></A>, <A HREF="#mext_info"><TT>mext_info</TT></A>, <A HREF="#mext_clear"><TT>mext_clear</TT></A>, and <A HREF="#mext_list_package"><TT>mext_list_package</TT></A>.</P><!--TOC subsection Function: mext_info-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc186">16.19</A>  Function: mext_info<A NAME="sec:mext_info"></A></H3><!--SEC END --><P>
<A NAME="mext_info"></A>
<B>mext_info</B>(<I>distname</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Print information about installed mext distribution <I>distname</I>. The list of installed distributions is built by calling <A HREF="#mext_list"><TT>mext_list</TT></A>.</P><P><B>Arguments</B>
<TT>mext_info</TT> requires one argument <I>distname</I>, which must be a string or a symbol.</P><P>The first argument threads (distributes) over lists.</P><P><B>See also</B>
<A HREF="#mext_list_loaded"><TT>mext_list_loaded</TT></A>, <A HREF="#mext_list"><TT>mext_list</TT></A>, <A HREF="#mext_clear"><TT>mext_clear</TT></A>, <A HREF="#mext_list_package"><TT>mext_list_package</TT></A>, and <A HREF="#mext_find_package"><TT>mext_find_package</TT></A>.</P><!--TOC subsection Function: mext_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc187">16.20</A>  Function: mext_list<A NAME="sec:mext_list"></A></H3><!--SEC END --><P>
<A NAME="mext_list"></A>
<B>mext_list</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Returns a list of all installed mext distributions. These are installed, but not neccessarily loaded.</P><P><B>Arguments</B>
<TT>mext_list</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#mext_list_loaded"><TT>mext_list_loaded</TT></A>, <A HREF="#mext_info"><TT>mext_info</TT></A>, <A HREF="#mext_clear"><TT>mext_clear</TT></A>, <A HREF="#mext_list_package"><TT>mext_list_package</TT></A>, and <A HREF="#mext_find_package"><TT>mext_find_package</TT></A>.</P><!--TOC subsection Function: mext_list_loaded-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc188">16.21</A>  Function: mext_list_loaded<A NAME="sec:mext_list_loaded"></A></H3><!--SEC END --><P>
<A NAME="mext_list_loaded"></A>
<B>mext_list_loaded</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Returns a list of mext packages currently loaded.</P><P><B>Arguments</B>
<TT>mext_list_loaded</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#mext_list"><TT>mext_list</TT></A>, <A HREF="#mext_info"><TT>mext_info</TT></A>, <A HREF="#mext_clear"><TT>mext_clear</TT></A>, <A HREF="#mext_list_package"><TT>mext_list_package</TT></A>, and <A HREF="#mext_find_package"><TT>mext_find_package</TT></A>.</P><!--TOC subsection Function: mext_list_package-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc189">16.22</A>  Function: mext_list_package<A NAME="sec:mext_list_package"></A></H3><!--SEC END --><P>
<A NAME="mext_list_package"></A>
<B>mext_list_package</B>(<I>package</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
List functions and variables defined in the mext pacakge <I>package</I>. A mis-feature is that an empty list is returned if the package is not loaded. This function incorrectly returns an empty list for some packages, and may miss some functions.</P><P><B>Arguments</B>
<TT>mext_list_package</TT> requires one argument <I>package</I>, which must be a string or a symbol.</P><P>The first argument threads (distributes) over lists.</P><P><B>See also</B>
<A HREF="#mext_list_loaded"><TT>mext_list_loaded</TT></A>, <A HREF="#mext_list"><TT>mext_list</TT></A>, <A HREF="#mext_info"><TT>mext_info</TT></A>, <A HREF="#mext_clear"><TT>mext_clear</TT></A>, and <A HREF="#mext_find_package"><TT>mext_find_package</TT></A>.</P><!--TOC subsection Function: mext_test-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc190">16.23</A>  Function: mext_test<A NAME="sec:mext_test"></A></H3><!--SEC END --><P>
<A NAME="mext_test"></A>
<B>mext_test</B>( :rest <I>dists</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>mext_test</B>(’loaded )
Run rtests for all loaded mext packages.</LI><LI CLASS="li-itemize"> <B>mext_test</B>(<I>package</I>)
Run rtests for the mext pacakge <I>package</I>.</LI></UL><P>
<B>Description</B>
Run the test suites for a mext distribution or list of distributions. If the argument <CODE>all</CODE> is given, then all tests are run for all installed mext distributions. If the argument <CODE>loaded</CODE> is given, then all tests are run for all loaded mext distributions. If no argument is given, a 
subfolder named <CODE>rtests</CODE> is searched for in the current directory. An item may be a list, in which case, the first element is the package name and the remaining elements are strings specifying the name of the rtests to run. The strings must not include directory or file extension parts. If the 
option <I>list</I> is <TT>true</TT>, then the tests are not performed, but a list of the rtest files is returned. If <I>list</I> is <I>long</I>, then the full pathnames of the rtest files are listed. Note: if the package <A HREF="#mext_defmfun1"><TT>mext_defmfun1</TT></A> is not loaded, then only a 
rudimentary version of <A HREF="#mext_test"><TT>mext_test</TT></A>, which does not accept options, is available.</P><P><B>Arguments</B>
<TT>mext_test</TT> requires zero or more arguments.
Each of the arguments must be a string, a symbol, or a list of strings or symbols.</P><P><B>Options</B>
<TT>mext_test</TT> takes options with default values: <TT>list-&gt;false</TT>.
</P><P><B>Examples</B>
Run regression tests for the packages <A HREF="#aex"><TT>aex</TT></A>, and <A HREF="#lists_aex"><TT>lists_aex</TT></A>.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) mext_test(aex,lists_aex);
(%o1) done
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Run only some of the regression tests.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i2) mext_test([aex, "rtest_aex"],[lists_aex, "rtest_table"]);
(%o2) done
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Only list the test files; do not run them.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i3) mext_test(tpsolve, list-&gt;true);
(%o3) [rtest_to_poly_solve, rtest_to_poly]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Variable: mext_verbose-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc191">16.24</A>  Variable: mext_verbose<A NAME="sec:mext_verbose"></A></H3><!--SEC END --><P>
<A NAME="mext_verbose"></A></P><P>mext package: mext_defmfun1</P><P>
default value <CODE>0</CODE>.</P><P><B>Description</B>
Set this to <CODE>0</CODE> to suppress messages from mext while loading packages, or <CODE>1</CODE> to enable messages.</P><!--TOC subsection Function: mtranslate_file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc192">16.25</A>  Function: mtranslate_file<A NAME="sec:mtranslate_file"></A></H3><!--SEC END --><P>
<A NAME="mtranslate_file"></A>
<B>mtranslate_file</B>(<I>input-file</I> :optional <I>ttymsgsp</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Like <TT>translate_file</TT>, except that the output filename may be specified as an option.</P><P><B>Arguments</B>
<TT>mtranslate_file</TT> requires either one or two arguments.
The first argument <I>input-file</I> must be a string.</P><P>The first argument threads (distributes) over lists.</P><P><B>Options</B>
<TT>mtranslate_file</TT> takes options with default values: <TT>output_file-&gt;false</TT>.
</P><!--TOC subsection Function: popdir-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc193">16.26</A>  Function: popdir<A NAME="sec:popdir"></A></H3><!--SEC END --><P>
<A NAME="popdir"></A>
<B>popdir</B>( :optional <I>n</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Pop a value from the current directory stack and chdir to this value. If <I>n</I> is given, pop <I>n</I> values and chdir to the last value popped.</P><P><B>Arguments</B>
<TT>popdir</TT> requires either zero or one arguments. If present, the argument <I>n</I> must be a a non-negative integer.</P><P><B>See also</B>
<A HREF="#chdir"><TT>chdir</TT></A>, <A HREF="#pwd"><TT>pwd</TT></A>, <A HREF="#updir"><TT>updir</TT></A>, <A HREF="#dirstack"><TT>dirstack</TT></A>, and <A HREF="#list_directory"><TT>list_directory</TT></A>.</P><!--TOC subsection Function: probe_file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc194">16.27</A>  Function: probe_file<A NAME="sec:probe_file"></A></H3><!--SEC END --><P>
<A NAME="probe_file"></A></P><P>mext package: maxdoc</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>probe_file</B>(<I>filespec</I>)
returns a string representing a canonical pathname to the file specified by <I>filespec</I>. False is returned if the file can’t be found.</LI></UL><P>
<B>Description</B>
Probe_File tries to find a canonical pathname for a file specified by the string <I>filespec</I>.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) probe_file("a/b.txt");
(%o1) "/home/username/c/a/b.txt"
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: pwd-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc195">16.28</A>  Function: pwd<A NAME="sec:pwd"></A></H3><!--SEC END --><P>
<A NAME="pwd"></A>
<B>pwd</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Return the current working directory.</P><P><B>Arguments</B>
<TT>pwd</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#chdir"><TT>chdir</TT></A>, <A HREF="#popdir"><TT>popdir</TT></A>, <A HREF="#updir"><TT>updir</TT></A>, <A HREF="#dirstack"><TT>dirstack</TT></A>, and <A HREF="#list_directory"><TT>list_directory</TT></A>.</P><!--TOC subsection Function: require-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc196">16.29</A>  Function: require<A NAME="sec:require"></A></H3><!--SEC END --><P>
<A NAME="require"></A>
<B>require</B>(<I>distname</I> :optional <I>force</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Load the mext pacakge <I>distname</I> and register that it has been loaded. <CODE>require('all)</CODE> will load all installed mext packages. If <I>force</I> is true, then <I>distname</I> is loaded even if it has been loaded previously. <I>distname</I> may also be a list of package names to be loaded.</P><P><B>Arguments</B>
<TT>require</TT> requires either one or two arguments.
The first argument <I>distname</I> must be a string, a symbol, or a list of strings or symbols.</P><!--TOC subsection Function: timing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc197">16.30</A>  Function: timing<A NAME="sec:timing"></A></H3><!--SEC END --><P>
<A NAME="timing"></A>
<B>timing</B>( :rest <I>exprs</I>)</P><P>mext package: runtime</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>timing</B>(<I>exprs</I>)
evaluates each of the expressions <I>exprs</I> and returns a list of the total cpu time and real time in seconds used, together with the result of evaluating the final expression.</LI><LI CLASS="li-itemize"> <B>timing</B>(<I>exprs</I>, print-&gt;true )
returns the result of evaluating the final expression and prints the cpu and real time used.</LI><LI CLASS="li-itemize"> <B>timing</B>(<I>exprs</I>, result-&gt;false )
returns the time in seconds used, and discards all results.</LI><LI CLASS="li-itemize"> <B>timing</B>(<I>exprs</I>, time-&gt;cpu )
Return only the cpu (run) time used and the last result.</LI><LI CLASS="li-itemize"> <B>timing</B>(<I>exprs</I>, time-&gt;real )
Return only the real time used and the last result.</LI><LI CLASS="li-itemize"> <B>timing</B>(<I>exprs</I>, time-&gt;all )
Return both the cpu and real time used and the last result.</LI></UL><P>
<B>Description</B>
<A HREF="#timing"><TT>timing</TT></A> evaluates each of the <I>exprs</I>, and returns a list of the total cpu time in seconds and real time in second used, together the result of the last expression. See also <TT>showtime</TT>.</P><P><B>Arguments</B>
<TT>timing</TT> requires zero or more arguments.</P><P><B>Options</B>
<TT>timing</TT> takes options with default values: <TT>time-&gt;all</TT>, <TT>result-&gt;true</TT>, <TT>print-&gt;false</TT>.
</P><P><B>Attributes</B>
timing has attributes: [hold_all]</P><!--TOC subsection Function: truename-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc198">16.31</A>  Function: truename<A NAME="sec:truename"></A></H3><!--SEC END --><P>
<A NAME="truename"></A></P><P>mext package: maxdoc</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>truename</B>(<I>filespec</I>)
returns a string representing a canonical pathname to the file specified by <I>filespec</I></LI></UL><P>
<B>Description</B>
Truename tries to find a canonical pathanme for a file specified by the string <I>filespec</I>.</P><!--TOC subsection Function: updir-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc199">16.32</A>  Function: updir<A NAME="sec:updir"></A></H3><!--SEC END --><P>
<A NAME="updir"></A>
<B>updir</B>( :optional <I>n</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Change the working directory to be <I>n</I> (or 1 if <I>n</I> is not given) subdirectories higher than the current working directory.</P><P><B>Arguments</B>
<TT>updir</TT> requires either zero or one arguments. If present, the argument <I>n</I> must be a a non-negative integer.</P><P><B>See also</B>
<A HREF="#chdir"><TT>chdir</TT></A>, <A HREF="#pwd"><TT>pwd</TT></A>, <A HREF="#popdir"><TT>popdir</TT></A>, <A HREF="#dirstack"><TT>dirstack</TT></A>, and <A HREF="#list_directory"><TT>list_directory</TT></A>.</P><!--TOC section Functions and Variables for Strings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc200">17</A>  Functions and Variables for Strings</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#string_drop"><TT>string_drop</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#string_reverse"><TT>string_reverse</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#string_take"><TT>string_take</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#with_output_to_string"><TT>with_output_to_string</TT></A>
</LI></UL><!--TOC subsection Function: string_drop-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc201">17.1</A>  Function: string_drop<A NAME="sec:string_drop"></A></H3><!--SEC END --><P>
<A NAME="string_drop"></A>
<B>string_drop</B>(<I>s</I>, <I>spec</I>)</P><P>mext package: lists_aex</P><P>
<B>Arguments</B>
<TT>string_drop</TT> requires two arguments.
The first argument <I>s</I> must be a string.
The second argument <I>spec</I> must be a sequence specification.</P><P>The first argument threads (distributes) over lists.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1)  string_drop("abracadabra",1);
(%o1) bracadabra
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1)  string_drop("abracadabra",-1);
(%o1) abracadabr
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1)  string_drop("abracadabra",[2,10]);
(%o1) aa
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: string_reverse-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc202">17.2</A>  Function: string_reverse<A NAME="sec:string_reverse"></A></H3><!--SEC END --><P>
<A NAME="string_reverse"></A>
<B>string_reverse</B>(<I>s</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>string_reverse</B>(<I>s</I>)
returns a copy of string <I>s</I> with the characters in reverse order.</LI></UL><P>
<B>Arguments</B>
<TT>string_reverse</TT> requires one argument <I>s</I>, which must be a string.</P><P>The first argument threads (distributes) over lists.</P><!--TOC subsection Function: string_take-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc203">17.3</A>  Function: string_take<A NAME="sec:string_take"></A></H3><!--SEC END --><P>
<A NAME="string_take"></A>
<B>string_take</B>(<I>s</I>, <I>spec</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>string_take</B>(<I>s</I>, <I>n</I>)
returns a string of the first <I>n</I> characters of the string <I>s</I>.</LI><LI CLASS="li-itemize"> <B>string_take</B>(<I>s</I>, -n )
returns a string of the last <I>n</I> characters of <I>s</I>.</LI></UL><P>
<B>Arguments</B>
<TT>string_take</TT> requires two arguments.
The first argument <I>s</I> must be a string.
The second argument <I>spec</I> must be a sequence specification.</P><P>The first argument threads (distributes) over lists.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) string_take("dog-goat-pig-zebra",[5,12]);
(%o1) goat-pig
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: with_output_to_string-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc204">17.4</A>  Function: with_output_to_string<A NAME="sec:with_output_to_string"></A></H3><!--SEC END --><P>
<A NAME="with_output_to_string"></A>
<B>with_output_to_string</B>( :rest <I>exprs</I>)</P><P>mext package: runtime</P><P>
<B>Description</B>
Evaluates <I>expr_1</I>, <I>expr_2</I>, <I>expr_3</I>,…and writes any output generated to a string, which is returned.</P><P><B>Arguments</B>
<TT>with_output_to_string</TT> requires zero or more arguments.</P><P><B>Attributes</B>
with_output_to_string has attributes: [hold_all]</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) sreverse(with_output_to_string(for i:5 thru 10 do print("i! for i=",i,i!)));
(%o1) 
 0088263 01 =i rof !i
 088263 9 =i rof !i
 02304 8 =i rof !i
 0405 7 =i rof !i
 027 6 =i rof !i
 021 5 =i rof !i
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC section Miscellaneous Functions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc205">18</A>  Miscellaneous Functions</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#examples"><TT>examples</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#examples_add"><TT>examples_add</TT></A>
</LI></UL><!--TOC subsection Function: examples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc206">18.1</A>  Function: examples<A NAME="sec:examples"></A></H3><!--SEC END --><P>
<A NAME="examples"></A>
<B>examples</B>(<I>item</I>)</P><P>mext package: defmfun1</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>examples</B>(<I>item</I>)
Print examples for the topic <I>item</I>. Note these examples are different from those extracted from the maxima manual with the command <CODE>example</CODE>.</LI></UL><P>
<B>Arguments</B>
<TT>examples</TT> requires one argument <I>item</I>, which must be a string or a symbol.</P><!--TOC subsection Function: examples_add-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc207">18.2</A>  Function: examples_add<A NAME="sec:examples_add"></A></H3><!--SEC END --><P>
<A NAME="examples_add"></A>
<B>examples_add</B>(<I>item</I>, <I>text</I>, <I>protected-var-list</I>, <I>code</I>)</P><P>mext package: defmfun1</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>examples_add</B>(<I>item</I>, <I>text</I>, <I>protected-var-list</I>, <I>code</I>)
Add an example for item <I>item</I>. <I>text</I> will be printed before the example is displayed. <I>protected-var-list</I> is string giving a list of variables such as "[x,y]" that appear in the example code. The example code will be wrapped in a block that makes <I>protected-var-list</I> local. <I>code</I> may be a string or list of strings that is/are the example code.</LI></UL><P>
<B>Arguments</B>
<TT>examples_add</TT> requires four arguments.
The first argument <I>item</I> must be a string or a symbol.
The second argument <I>text</I> must be a string.
The third argument <I>protected-var-list</I> must be a string.
The fourth argument <I>code</I> must be a string or a list of strings.</P><P><B>Examples</B></P><P>Add an example for the function ’last’.</P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) examples_add("last", "Return the last item in a  list.", "[a,b,c,d]", "last([a,b,c,d])") ;
(%o1) done
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC section Miscellaneous utilities-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc208">19</A>  Miscellaneous utilities</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#compile_lambda_verbose"><TT>compile_lambda_verbose</TT></A>
</LI></UL><!--TOC subsection Variable: compile_lambda_verbose-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc209">19.1</A>  Variable: compile_lambda_verbose<A NAME="sec:compile_lambda_verbose"></A></H3><!--SEC END --><P>
<A NAME="compile_lambda_verbose"></A></P><P>mext package: defmfun1</P><P>
default value <CODE>false</CODE>.</P><P><B>Description</B>
If this is true, then print translated code when automatically compiling lambda functions passed as arguments. This is done in the macro option-compile-lambda.</P><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc210">20</A>  Options</H2><!--SEC END --><P>Options to a function in the aex-maxima distribution are passed as follows:</P><P>funcname(x,y, [optname -&gt; optval, optname2 -&gt; optval2])
or
funcname(x,y, optname -&gt; optval, optname2 -&gt; optval2)</P><P>The standard options described in this section are some options that are supported by
many functions in the aex-maxima distribution.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#adj"><TT>adj</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#compile"><TT>compile</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#foptions"><TT>foptions</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ot"><TT>ot</TT></A>
</LI></UL><!--TOC subsection Option: adj-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc211">20.1</A>  Option: adj<A NAME="sec:adj"></A></H3><!--SEC END --><P>
<A NAME="adj"></A></P><P>mext package: maxdoc</P><P>
<B>Description</B>
This option takes values of <CODE>true</CODE> or <CODE> false. If </CODE><CODE>true</CODE>, then the output aex expression is adjustable, that is, the underlying array can be extended in size. If <CODE>false</CODE>, then the output aex expression is not adjustable. The non-adjustable array may have some advantanges in 
efficiency, but I have not observed them, and this may be lisp-implementation dependent.</P><!--TOC subsection Option: compile-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc212">20.2</A>  Option: compile<A NAME="sec:compile"></A></H3><!--SEC END --><P>
<A NAME="compile"></A></P><P>mext package: maxdoc</P><P>
<B>Description</B>
If this option is true, then lambda functions passed as arguments to a function will be automatically translated or compiled. If it is false they will used as interpreted maxima code. Compiling lambda functions usually greatly deceases the execution time of the function if the lambda function is 
called many times.</P><!--TOC subsection Function: foptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc213">20.3</A>  Function: foptions<A NAME="sec:foptions"></A></H3><!--SEC END --><P>
<A NAME="foptions"></A>
<B>foptions</B>(<I>name</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Return a list of allowed options to <CODE>defmfun1</CODE> function <I>name</I>. I would prefer to call this <CODE>options</CODE>, but that name is taken by an unused, undocumented function.</P><P><B>Arguments</B>
<TT>foptions</TT> requires one argument <I>name</I>, which must be a string or a symbol.</P><!--TOC subsection Option: ot-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc214">20.4</A>  Option: ot<A NAME="sec:ot"></A></H3><!--SEC END --><P>
<A NAME="ot"></A></P><P>mext package: maxdoc</P><P>
<B>Description</B>
With a value <CODE>ar</CODE> this option causes the function to return an array-representation expression. With a value <CODE>ml</CODE> a standard lisp list representation is returned. The array-representation is not a maxima array, but rather a more-or-less arbitrary maxima expression that is stored 
internally as an array. For certain operations, such as random access to elements of the expression, an array representation is faster than the standard list representation. One disadvantange of the array representations is that creating an array is relatively slow. For instance, execution time may 
be large if a function returns an expression with many small subexpressions that are in the array-representation. The majority of the maxima system does not understand array-representation, so conversion back to list-representation at may be necessary.</P><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
