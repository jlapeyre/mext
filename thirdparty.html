<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Third-party maxima software
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea ./thirdparty.tex -->
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Third-party maxima software</H1><H3 CLASS="titlerest">John Lapeyre</H3></TD></TR>
</TABLE><!--TOC section Contents-->
<H2 CLASS="section"><!--SEC ANCHOR -->Contents</H2><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">1  Array Representation For Expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc2">2  Attributes</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">2.1  Function: attributes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">2.2  Function: set_match_form</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">2.3  Function: set_nowarn</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">2.4  Function: unset_match_form</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">2.5  Function: unset_nowarn</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">3  Functions and Variables for Array Represention for Expressions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc9">3.1  Function: aeop</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">3.2  Function: aex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">3.3  Function: aex_cp</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">3.4  Function: aex_get</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">3.5  Function: aex_new</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">3.6  Function: aex_set</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">3.7  Function: aex_shift</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">3.8  Function: aex_unshift</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">3.9  Function: aexg</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">3.10  Function: aexs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">3.11  Function: copy_aex_type</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">3.12  Function: iapply</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">3.13  Function: ilength</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">3.14  Function: ipart</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">3.15  Function: ipart_set</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">3.16  Function: ireverse</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">3.17  Function: lex</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">4  Functions and Variables for Combinatorics</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc27">4.1  Function: ae_random_permutation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">4.2  Function: cycles_to_perm</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">4.3  Function: inverse_permutation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">4.4  Function: perm_to_cycles</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">4.5  Function: perm_to_transpositions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc32">4.6  Function: permutation_p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">4.7  Function: permutation_p1</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">4.8  Function: random_cycle</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">4.9  Function: random_permutation_sym</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">4.10  Function: signature_permutation</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">4.11  Function: transpositions_to_perm</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">5  Functions and Variables for Documentation</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc39">5.1  Variable: doc_system_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">5.2  Function: print_entry_latex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">5.3  Function: print_maxdoc_entry</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">5.4  Function: print_maxdoc_sections</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">5.5  Function: print_sections_latex</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">5.6  Option variable: read_docs_with_pager</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">5.7  Function: set_all_doc_systems</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">5.8  Function: simple_doc_add</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">5.9  Function: simple_doc_delete</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">5.10  Function: simple_doc_get</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc49">5.11  Function: simple_doc_init</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">5.12  Function: simple_doc_print</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">6  Functions and Variables for Equations</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc52">6.1  Function: nelder_mead</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">7  Functions and Variables for Function Definition</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc54">7.1  Function: comp_load</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">7.2  Function: compile_file1</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">8  Functions and Variables for Input and Output</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc57">8.1  Option variable: pager_command</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">8.2  Function: pager_string</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">8.3  Function: restore</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">8.4  Function: restore_fast</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">8.5  Function: store</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">8.6  Function: store_fast</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">9  Functions and Variables for Lists</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc64">9.1  Function: aelistp</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">9.2  Function: constant_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">9.3  Function: count</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">9.4  Function: drop_while</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">9.5  Function: every1</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">9.6  Function: fold</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc70">9.7  Function: fold_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">9.8  Function: icons</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">9.9  Function: imap</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc73">9.10  Function: length_while</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc74">9.11  Function: lrange</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">9.12  Function: nest</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">9.13  Function: nest_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc77">9.14  Function: nest_while</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">9.15  Function: nreverse</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">9.16  Function: partition_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc80">9.17  Function: select</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">9.18  Argument type: sequence specifier</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">9.19  Function: table</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">9.20  Function: take</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">9.21  Function: take_while</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">9.22  Function: tuples</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">10  Functions and Variables for Number Theory</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc87">10.1  Function: abundant_p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc88">10.2  Function: aliquot_sequence</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">10.3  Function: aliquot_sum</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">10.4  Function: amicable_p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">10.5  Function: catalan_number</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">10.6  Function: divisor_function</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc93">10.7  Function: divisor_summatory</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">10.8  Function: from_digits</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">10.9  Function: integer_digits</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">10.10  Function: integer_string</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">10.11  Function: oeis_A092143</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">10.12  Function: perfect_p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">10.13  Function: prime_pi</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc100">10.14  Function: prime_pi_soe</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">10.15  Function: prime_twins</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">10.16  Function: primes1</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">11  Functions and Variables for Numerics</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc104">11.1  Function: n_abs</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">11.2  Function: n_acos</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">11.3  Function: n_acosh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">11.4  Function: n_asin</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">11.5  Function: n_asinh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc109">11.6  Function: n_atan</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">11.7  Function: n_atanh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">11.8  Function: n_cos</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">11.9  Function: n_cosh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">11.10  Function: n_exp</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc114">11.11  Function: n_expt</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc115">11.12  Function: n_log</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc116">11.13  Function: n_sin</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">11.14  Function: n_sinh</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">11.15  Function: n_sqrt</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc119">11.16  Function: n_tan</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc120">11.17  Function: n_tanh</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc121">12  Functions and Variables for Predicates</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc122">12.1  Function: cmplength</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">12.2  Function: length0p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc124">12.3  Function: length1p</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">12.4  Function: length_eq</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc126">12.5  Function: type_of</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc127">13  Functions and Variables for Program Flow</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc128">13.1  Function: error_str</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">14  Functions and Variables for Quicklisp</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc130">14.1  Function: quicklisp_apropos</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc131">14.2  Function: quicklisp_install</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc132">14.3  Function: quicklisp_load</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc133">14.4  Function: quicklisp_start</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc134">15  Functions and Variables for Runtime Environment</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc135">15.1  Function: chdir</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc136">15.2  Function: dir_exists</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc137">15.3  Function: dirstack</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc138">15.4  Function: dont_kill</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc139">15.5  Function: dont_kill_share</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc140">15.6  Function: get_dont_kill</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc141">15.7  Function: mext_clear</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc142">15.8  Function: mext_info</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc143">15.9  Function: mext_list</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc144">15.10  Function: mext_test</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc145">15.11  Function: popdir</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc146">15.12  Function: probe_file</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc147">15.13  Function: pwd</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc148">15.14  Function: require</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc149">15.15  Function: truename</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc150">16  Functions and Variables for Strings</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc151">16.1  Function: string_drop</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc152">16.2  Function: string_reverse</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc153">16.3  Function: string_take</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc154">16.4  Function: with_output_to_string</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc155">17  Miscellaneous Functions</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc156">17.1  Function: examples</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc157">17.2  Function: examples_add</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc158">18  Miscellaneous utilities</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc159">19  Options</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc160">19.1  Option: adj</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc161">19.2  Option: compile</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc162">19.3  Function: foptions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc163">19.4  Option: ot</A>
</LI></UL>
</LI></UL><!--TOC section Array Representation For Expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>  Array Representation For Expressions</H2><!--SEC END --><P>Maxima expressions are normally implemented internally as lisp lists,
but they may also be represented by lisp arrays. Each representation has
advantages.
</P><!--TOC section Attributes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>  Attributes</H2><!--SEC END --><P>A function may possess a list of attributes. The attributes control how the arguments
to the function are evaluated and how errors are handled.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#attributes"><TT>attributes</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#set_match_form"><TT>set_match_form</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#set_nowarn"><TT>set_nowarn</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#unset_match_form"><TT>unset_match_form</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>
</LI></UL><!--TOC subsection Function: attributes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">2.1</A>  Function: attributes<A NAME="sec:attributes"></A></H3><!--SEC END --><P>
<A NAME="attributes"></A>
<B>attributes</B>(<I>name</I>)</P><P>
<B>Description</B>
Returns a list of the ‘attributes’ of function <I>name</I>. </P><P><B>Arguments</B>
<TT>attributes</TT> requires one argument <I>name</I>, which must be a string or a symbol.</P><P><B>See also</B>
<A HREF="#unset_match_form"><TT>unset_match_form</TT></A>, <A HREF="#set_match_form"><TT>set_match_form</TT></A>, <A HREF="#set_nowarn"><TT>set_nowarn</TT></A>, and <A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>.</P><!--TOC subsection Function: set_match_form-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">2.2</A>  Function: set_match_form<A NAME="sec:set_match_form"></A></H3><!--SEC END --><P>
<A NAME="set_match_form"></A>
<B>set_match_form</B>(<I>names</I>)</P><P>
<B>Description</B>
Set the ‘match_form’ attribute for function(s) <I>names</I>. If the argument checks for a function call fail, and the attribute ‘match_form’ is set, then rather than signaling an error, the unevaluated form is returned. Furthemore, if the attribute ‘nowarn’ is not set, then a warning message is 
printed. </P><P><B>Arguments</B>
<TT>set_match_form</TT> requires one argument <I>names</I>, which must be a string, a symbol, or a list of strings or symbols.</P><P><B>See also</B>
<A HREF="#unset_match_form"><TT>unset_match_form</TT></A>, <A HREF="#set_nowarn"><TT>set_nowarn</TT></A>, <A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>, and <A HREF="#attributes"><TT>attributes</TT></A>.</P><!--TOC subsection Function: set_nowarn-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">2.3</A>  Function: set_nowarn<A NAME="sec:set_nowarn"></A></H3><!--SEC END --><P>
<A NAME="set_nowarn"></A>
<B>set_nowarn</B>(<I>names</I>)</P><P>
<B>Description</B>
Set the ‘nowarn’ attribute for function(s) <I>names</I>. If the argument checks for a function call fail, and the attribute ‘match_form’ is set, and the attribute ‘nowarn’ is set, then rather than signaling an error, the unevaluated form is returned and no warning message is printed. </P><P><B>Arguments</B>
<TT>set_nowarn</TT> requires one argument <I>names</I>, which must be a string, a symbol, or a list of strings or symbols.</P><P><B>See also</B>
<A HREF="#unset_match_form"><TT>unset_match_form</TT></A>, <A HREF="#set_match_form"><TT>set_match_form</TT></A>, <A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>, and <A HREF="#attributes"><TT>attributes</TT></A>.</P><!--TOC subsection Function: unset_match_form-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc6">2.4</A>  Function: unset_match_form<A NAME="sec:unset_match_form"></A></H3><!--SEC END --><P>
<A NAME="unset_match_form"></A>
<B>unset_match_form</B>(<I>names</I>)</P><P>
<B>Description</B>
Unset the ‘match_form’ attribute for function(s) <I>names</I>. If the argument checks for a function call fail, and the attribute ‘match_form’ is set, then rather than signaling an error, the unevaluated form is returned. Furthemore, if the attribute ‘nowarn’ is not set, then a warning message is 
printed. </P><P><B>Arguments</B>
<TT>unset_match_form</TT> requires one argument <I>names</I>, which must be a string, a symbol, or a list of strings or symbols.</P><P><B>See also</B>
<A HREF="#set_match_form"><TT>set_match_form</TT></A>, <A HREF="#set_nowarn"><TT>set_nowarn</TT></A>, <A HREF="#unset_nowarn"><TT>unset_nowarn</TT></A>, and <A HREF="#attributes"><TT>attributes</TT></A>.</P><!--TOC subsection Function: unset_nowarn-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">2.5</A>  Function: unset_nowarn<A NAME="sec:unset_nowarn"></A></H3><!--SEC END --><P>
<A NAME="unset_nowarn"></A>
<B>unset_nowarn</B>(<I>names</I>)</P><P>
<B>Description</B>
Unset the ‘nowarn’ attribute for function(s) <I>names</I>. If the argument checks for a function call fail, and the attribute ‘match_form’ is set, and the attribute ‘nowarn’ is set, then rather than signaling an error, the unevaluated form is returned and no warning message is printed. </P><P><B>Arguments</B>
<TT>unset_nowarn</TT> requires one argument <I>names</I>, which must be a string, a symbol, or a list of strings or symbols.</P><P><B>See also</B>
<A HREF="#unset_match_form"><TT>unset_match_form</TT></A>, <A HREF="#set_match_form"><TT>set_match_form</TT></A>, <A HREF="#set_nowarn"><TT>set_nowarn</TT></A>, and <A HREF="#attributes"><TT>attributes</TT></A>.</P><!--TOC section Functions and Variables for Array Represention for Expressions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc8">3</A>  Functions and Variables for Array Represention for Expressions</H2><!--SEC END --><P>These functions operate on the the array expression data structure.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#aeop"><TT>aeop</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex"><TT>aex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_cp"><TT>aex_cp</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_get"><TT>aex_get</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_new"><TT>aex_new</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_set"><TT>aex_set</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_shift"><TT>aex_shift</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aex_unshift"><TT>aex_unshift</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aexg"><TT>aexg</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aexs"><TT>aexs</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#copy_aex_type"><TT>copy_aex_type</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#iapply"><TT>iapply</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ilength"><TT>ilength</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ipart"><TT>ipart</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ipart_set"><TT>ipart_set</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ireverse"><TT>ireverse</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#lex"><TT>lex</TT></A>
</LI></UL><!--TOC subsection Function: aeop-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc9">3.1</A>  Function: aeop<A NAME="sec:aeop"></A></H3><!--SEC END --><P>
<A NAME="aeop"></A>
<B>aeop</B>(<I>expr</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
op function for aex. returns op if <I>e</I> is not an aex. </P><P><B>Arguments</B>
<TT>aeop</TT> requires one argument <I>expr</I>, which must be non-atomic.</P><!--TOC subsection Function: aex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc10">3.2</A>  Function: aex<A NAME="sec:aex"></A></H3><!--SEC END --><P>
<A NAME="aex"></A>
<B>aex</B>( :optional <I>x</I>)</P><P>mext package: aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>aex</B>(<I>e</I>)
Converts expression <I>e</I> to an array representation. The input expression <I>e</I> is returned unchanged if it is already an array expression or is a symbol or number or specially represented maxima expression. This function converts only at the first level. </LI></UL><P>
<B>Arguments</B>
<TT>aex</TT> requires either zero or one arguments.
.</P><P><B>Options</B>
<TT>aex</TT> takes options with default values: <TT>adj-&gt;true</TT>.
</P><!--TOC subsection Function: aex_cp-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">3.3</A>  Function: aex_cp<A NAME="sec:aex_cp"></A></H3><!--SEC END --><P>
<A NAME="aex_cp"></A>
<B>aex_cp</B>(<I>e</I> :optional <I>head</I>)</P><P>mext package: aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>aex_cp</B>(<I>e</I>)
Returns an aex form copy of <I>e</I>. <I>e</I> may be in either lex or aex form. Conversion to aex representation occurs only on the first level. </LI></UL><P>
<B>Arguments</B>
<TT>aex_cp</TT> requires either one or two arguments.
The first argument <I>e</I> must be non-atomic.</P><P><B>Options</B>
<TT>aex_cp</TT> takes options with default values: <TT>adj-&gt;true</TT>.
</P><!--TOC subsection Function: aex_get-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">3.4</A>  Function: aex_get<A NAME="sec:aex_get"></A></H3><!--SEC END --><P>
<A NAME="aex_get"></A></P><P>
<B>Description</B>
Returns the <I>n</I>th part of aexpr <I>e</I>. A value of 0 for <I>n</I> is not allowed. This is more efficient than <A HREF="#aexg"><TT>aexg</TT></A>, which allows <I>n</I> equal to zero. </P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : aex([5,6,7]), aex_get(a,2);
(%o1) 7
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: aex_new-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">3.5</A>  Function: aex_new<A NAME="sec:aex_new"></A></H3><!--SEC END --><P>
<A NAME="aex_new"></A>
<B>aex_new</B>(<I>n</I> :optional <I>head</I>)</P><P>mext package: aex</P><P>
<B>Arguments</B>
<TT>aex_new</TT> requires either one or two arguments.
The first argument <I>n</I> must be a non-negative integer.</P><!--TOC subsection Function: aex_set-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">3.6</A>  Function: aex_set<A NAME="sec:aex_set"></A></H3><!--SEC END --><P>
<A NAME="aex_set"></A></P><P>
<B>Description</B>
Destructively sets the <I>n</I>th part of aexpr <I>e</I> to value <I>v</I>. A value of 0 for <I>n</I> is not allowed. This is more efficient than <A HREF="#aexs"><TT>aexs</TT></A>. No argument checking is done. </P><P><B>Examples</B></P><P>Destructively assign to a part of an expression. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : aex([1,2,3]), aex_set(a,1,x), a;
(%o1) &lt;[1,x,3]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#aexs"><TT>aexs</TT></A> and <A HREF="#ipart"><TT>ipart</TT></A>.</P><!--TOC subsection Function: aex_shift-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc15">3.7</A>  Function: aex_shift<A NAME="sec:aex_shift"></A></H3><!--SEC END --><P>
<A NAME="aex_shift"></A>
<B>aex_shift</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
destructively removes an element from the end of <I>e</I>. For array representation of expressions we use the words ‘push’ and ‘pop’ for the beginning of and expression, and ‘shift’ and ‘unshift’ for the end of an expression, whether the representation is an array or a list. This is consistent with 
maxima, but the reverse of the meaning of the terms in perl. </P><P><B>Arguments</B>
<TT>aex_shift</TT> requires one argument <I>e</I>, which must be an adjustable array expression.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : lrange(10,ot-&gt;ar);
(%o1) &lt;[1,2,3,4,5,6,7,8,9,10]&gt;
(%i1) b : aex_shift(a);
(%o1) 10
(%i2) a;
(%o2) &lt;[1,2,3,4,5,6,7,8,9]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: aex_unshift-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc16">3.8</A>  Function: aex_unshift<A NAME="sec:aex_unshift"></A></H3><!--SEC END --><P>
<A NAME="aex_unshift"></A>
<B>aex_unshift</B>(<I>v</I>, <I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Destructively pushes an element <I>v</I> onto the end of <I>e</I>. The return value is <I>v</I>. For array representation of expressions we use the words ‘push’ and ‘pop’ for the beginning of and expression, and ‘shift’ and ‘unshift’ for the end of an expression, whether the representation is an array 
or a list. This is consistent with maxima, but the reverse of the meaning of the terms in perl. </P><P><B>Arguments</B>
<TT>aex_unshift</TT> requires two arguments.
The second argument <I>e</I> must be an adjustable array expression.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : lrange(10,ot-&gt;ar), aex_unshift("dog",a), a;
(%o1) &lt;[1,2,3,4,5,6,7,8,9,10,"dog"]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: aexg-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc17">3.9</A>  Function: aexg<A NAME="sec:aexg"></A></H3><!--SEC END --><P>
<A NAME="aexg"></A></P><P>
<B>Description</B>
aexg(e,n) returns the nth part of aexpr e. If n is 0, the head of e is returned. No argument checking is performed. </P><P><B>See also</B>
<A HREF="#aex_get"><TT>aex_get</TT></A>, <A HREF="#ipart"><TT>ipart</TT></A>, <A HREF="#inpart"><TT>inpart</TT></A>, and <A HREF="#part"><TT>part</TT></A>.</P><!--TOC subsection Function: aexs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">3.10</A>  Function: aexs<A NAME="sec:aexs"></A></H3><!--SEC END --><P>
<A NAME="aexs"></A></P><P>
<B>Description</B>
destructively sets the <I>n</I>th part of aexpr <I>e</I> to value <I>v</I>. A value of 0 for <I>n</I> returns the head (or op) of <I>e</I>. </P><!--TOC subsection Function: copy_aex_type-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc19">3.11</A>  Function: copy_aex_type<A NAME="sec:copy_aex_type"></A></H3><!--SEC END --><P>
<A NAME="copy_aex_type"></A>
<B>copy_aex_type</B>(<I>ein</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Create a new aex with same head,length,adjustability,etc. but contents of expression are not copied. </P><P><B>Arguments</B>
<TT>copy_aex_type</TT> requires one argument <I>ein</I>, which must be an array-representation expression.</P><!--TOC subsection Function: iapply-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">3.12</A>  Function: iapply<A NAME="sec:iapply"></A></H3><!--SEC END --><P>
<A NAME="iapply"></A>
<B>iapply</B>(<I>fun</I>, <I>arg</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
<A HREF="#iapply"><TT>iapply</TT></A> is like maxima <TT>apply</TT>, but it supports aex lists. <I>arg</I> is converted to an ml if it is an aex expression. By default, output is ml regardless of the input representation. </P><P><B>Arguments</B>
<TT>iapply</TT> requires two arguments.
The first argument <I>fun</I> must be a function.
The second argument <I>arg</I> must be non-atomic.</P><P><B>Options</B>
<TT>iapply</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) iapply(%%ff,lrange(4));
(%o1) %%ff(1,2,3,4)
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) iapply(%%ff,lrange(4,[ot-&gt;ar]));
(%o1) %%ff(1,2,3,4)
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) iapply(%%ff,lrange(4,[ot-&gt;ar]), [ot-&gt;ar] );
(%o1) %%ff&lt;1,2,3,4&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) iapply(%%ff,lrange(4), [ot-&gt;ar] );
(%o1) %%ff&lt;1,2,3,4&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: ilength-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc21">3.13</A>  Function: ilength<A NAME="sec:ilength"></A></H3><!--SEC END --><P>
<A NAME="ilength"></A>
<B>ilength</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Returns the length of the expression <I>e</I>. This is like maxima <CODE>length</CODE>, but here, <I>e</I> can be either an aex or a lex. </P><P><B>Arguments</B>
<TT>ilength</TT> requires one argument <I>e</I>, which must be a subscripted variable or non-atomic.</P><!--TOC subsection Function: ipart-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc22">3.14</A>  Function: ipart<A NAME="sec:ipart"></A></H3><!--SEC END --><P>
<A NAME="ipart"></A></P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>ipart</B>(<I>e</I>, <I>ind1</I>, <I>ind2</I>, <I>...</I>)
Returns the part of expression <I>e</I> specified by indices. <I>e</I> may be a mixed (lex and aex) representation expression. When used as an lvalue, ipart can be used to assign to a part of an expression. If an index is negative, then it counts from the end of the list. If <I>e</I> is an ordinary 
maxima list (lex), then using a negative index is potentially slower than using a positive index because the entire list must first be traversed in order to determine it’s length. If <I>e</I> is in aex representation, then this inefficiency is not present. </LI></UL><P>
<B>Examples</B></P><P>Destructively assign to a part of an exression. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) (a : [1,2,3], ipart(a,1) : 7, a);
(%o1) [7,2,3]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>Implementation</B>
Some tests were performed with large lists of numbers. If we set <CODE>a:lrange(10^7)</CODE>, then the times required for <CODE>ipart(a,10^7)</CODE>, <CODE>ipart(a,-1)</CODE>, <CODE>inpart(a,10^7)</CODE>, and <CODE>part(a,10^7)</CODE> were 30, 60, 90, and 90 ms. </P><!--TOC subsection Function: ipart_set-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc23">3.15</A>  Function: ipart_set<A NAME="sec:ipart_set"></A></H3><!--SEC END --><P>
<A NAME="ipart_set"></A></P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>ipart_set</B>(<I>e</I>, <I>val</I>, <I>ind1</I>, <I>ind2</I>, <I>...</I>)
Set part of <I>e</I> specified by the final arguments to <I>val</I>. <I>e</I> is a mixed representation expression. </LI></UL><!--TOC subsection Function: ireverse-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc24">3.16</A>  Function: ireverse<A NAME="sec:ireverse"></A></H3><!--SEC END --><P>
<A NAME="ireverse"></A>
<B>ireverse</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
ireverse is like maxima reverse, but is works on both aex and list objects. ireverse is tries to be identical to maxima reverse for a non-aex argument. </P><P><B>Arguments</B>
<TT>ireverse</TT> requires one argument <I>e</I>, which must be non-atomic.</P><P><B>Options</B>
<TT>ireverse</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) ireverse(lrange(4));
(%o1) [4,3,2,1]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) ireverse(lrange(4), [ot-&gt;ar] );
(%o1) &lt;[4,3,2,1]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) ireverse(lrange(4, [ot-&gt;ar]) );
(%o1) &lt;[4,3,2,1]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) ireverse(lrange(4, [ot-&gt;ar]), [ot-&gt;ml] );
(%o1) [4,3,2,1]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: lex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">3.17</A>  Function: lex<A NAME="sec:lex"></A></H3><!--SEC END --><P>
<A NAME="lex"></A></P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>lex</B>(<I>e</I>)
converts the aex expression <I>e</I> to lex. If <I>e</I> is not an aex expression, <I>e</I> is returned. Conversion is only done on the first level. </LI></UL><!--TOC section Functions and Variables for Combinatorics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">4</A>  Functions and Variables for Combinatorics</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#inverse_permutation"><TT>inverse_permutation</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#perm_to_transpositions"><TT>perm_to_transpositions</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#permutation_p"><TT>permutation_p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#permutation_p1"><TT>permutation_p1</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#random_cycle"><TT>random_cycle</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#signature_permutation"><TT>signature_permutation</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#transpositions_to_perm"><TT>transpositions_to_perm</TT></A>
</LI></UL><!--TOC subsection Function: ae_random_permutation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">4.1</A>  Function: ae_random_permutation<A NAME="sec:ae_random_permutation"></A></H3><!--SEC END --><P>
<A NAME="ae_random_permutation"></A>
<B>ae_random_permutation</B>(<I>a</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
returns <I>a</I> with subexpressions permuted randomly. </P><P><B>Arguments</B>
<TT>ae_random_permutation</TT> requires one argument <I>a</I>, which must be non-atomic.</P><P><B>Options</B>
<TT>ae_random_permutation</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><!--TOC subsection Function: cycles_to_perm-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">4.2</A>  Function: cycles_to_perm<A NAME="sec:cycles_to_perm"></A></H3><!--SEC END --><P>
<A NAME="cycles_to_perm"></A>
<B>cycles_to_perm</B>(<I>cycles</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns a permutation from its cycle decomposition <I>cycles</I>, which is a list of lists. Here ‘permutation’ means a permutation of a list of the integers from 1 to some number <I>n</I>. The default output representation is aex. </P><P><B>Arguments</B>
<TT>cycles_to_perm</TT> requires one argument <I>cycles</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>cycles_to_perm</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, and <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>.</P><!--TOC subsection Function: inverse_permutation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">4.3</A>  Function: inverse_permutation<A NAME="sec:inverse_permutation"></A></H3><!--SEC END --><P>
<A NAME="inverse_permutation"></A>
<B>inverse_permutation</B>(<I>perm</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the inverse permutation of <I>perm</I>. </P><P><B>Arguments</B>
<TT>inverse_permutation</TT> requires one argument <I>perm</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>inverse_permutation</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) inverse_permutation([5,1,4,2,6,8,7,3,10,9]);
(%o1) &lt;[2,4,8,3,1,5,7,6,10,9]&gt;
(%i1) inverse_permutation(inverse_permutation([5,1,4,2,6,8,7,3,10,9]),ot-&gt;ml);
(%o1) [5,1,4,2,6,8,7,3,10,9]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: perm_to_cycles-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">4.4</A>  Function: perm_to_cycles<A NAME="sec:perm_to_cycles"></A></H3><!--SEC END --><P>
<A NAME="perm_to_cycles"></A>
<B>perm_to_cycles</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns a cycle decomposition of the input permutation <I>ain</I>. The input must be a permutation of <I>n</I> integers from 1 through <I>n</I>. </P><P><B>Arguments</B>
<TT>perm_to_cycles</TT> requires one argument <I>ain</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>perm_to_cycles</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) perm_to_cycles([5,4,3,2,1,10,6,7,8,9]);
(%o1) [[7,8,9,10,6],[3],[4,2],[5,1]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><!--TOC subsection Function: perm_to_transpositions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc31">4.5</A>  Function: perm_to_transpositions<A NAME="sec:perm_to_transpositions"></A></H3><!--SEC END --><P>
<A NAME="perm_to_transpositions"></A>
<B>perm_to_transpositions</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns a list representing the permutation <I>ain</I> as a product of transpositions. The output representation type is applied at both levels. </P><P><B>Arguments</B>
<TT>perm_to_transpositions</TT> requires one argument <I>ain</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>perm_to_transpositions</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><!--TOC subsection Function: permutation_p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc32">4.6</A>  Function: permutation_p<A NAME="sec:permutation_p"></A></H3><!--SEC END --><P>
<A NAME="permutation_p"></A>
<B>permutation_p</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>permutation_p</B>(<I>list</I>)
Returns true if the list <I>list</I> of length <I>n</I> is a permutation of the integers from 1 through <I>n</I>. Otherwise returns false. </LI></UL><P>
<B>Arguments</B>
<TT>permutation_p</TT> requires one argument.</P><P><B>Implementation</B>
Separate routines for aex and lex input are used. </P><!--TOC subsection Function: permutation_p1-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">4.7</A>  Function: permutation_p1<A NAME="sec:permutation_p1"></A></H3><!--SEC END --><P>
<A NAME="permutation_p1"></A>
<B>permutation_p1</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
This is the same as <A HREF="#permutation_p"><TT>permutation_p</TT></A>, but, if the input is a list, it assumes all elements in the input list are fixnum integers, while <A HREF="#permutation_p"><TT>permutation_p</TT></A> does not. </P><P><B>Arguments</B>
<TT>permutation_p1</TT> requires one argument.</P><P><B>Implementation</B>
Some variables are declared fixnum, but this does not seem to improve performance with respect to <A HREF="#permutationp"><TT>permutationp</TT></A>. </P><!--TOC subsection Function: random_cycle-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">4.8</A>  Function: random_cycle<A NAME="sec:random_cycle"></A></H3><!--SEC END --><P>
<A NAME="random_cycle"></A>
<B>random_cycle</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>random_cycle</B>(<I>n</I>)
Returns a random cycle of length <I>n</I>. The return value is a list of the integers from 1 through <I>n</I>, representing an element of the symmetric group <I>S</I><SUB><I>n</I></SUB> that is a cycle. </LI></UL><P>
<B>Arguments</B>
<TT>random_cycle</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P><B>Options</B>
<TT>random_cycle</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><P><B>Implementation</B>
This function uses Sattolo’s algorithm. </P><!--TOC subsection Function: random_permutation_sym-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc35">4.9</A>  Function: random_permutation_sym<A NAME="sec:random_permutation_sym"></A></H3><!--SEC END --><P>
<A NAME="random_permutation_sym"></A>
<B>random_permutation_sym</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>random_permutation_sym</B>(<I>n</I>)
Returns a random permutation of the integers from 1 through <I>n</I>. This represents a random element of the symmetric group <I>S</I><SUB><I>n</I></SUB>. </LI></UL><P>
<B>Arguments</B>
<TT>random_permutation_sym</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P><B>Options</B>
<TT>random_permutation_sym</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#signature_permutation"><TT>signature_permutation</TT></A>, <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><!--TOC subsection Function: signature_permutation-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">4.10</A>  Function: signature_permutation<A NAME="sec:signature_permutation"></A></H3><!--SEC END --><P>
<A NAME="signature_permutation"></A>
<B>signature_permutation</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>signature_permutation</B>(<I>list</I>)
returns the sign, or signature, of the symmetric permutation <I>list</I>, which must be represented by a permuation the integers from 1 through <I>n</I>, where <I>n</I> is the length of the list. </LI></UL><P>
<B>Arguments</B>
<TT>signature_permutation</TT> requires one argument <I>ain</I>, which must be a list (lex or aex).</P><P><B>See also</B>
<A HREF="#random_cycle"><TT>random_cycle</TT></A>, <A HREF="#random_permutation_sym"><TT>random_permutation_sym</TT></A>, <A HREF="#ae_random_permutation"><TT>ae_random_permutation</TT></A>, <A HREF="#perm_to_cycles"><TT>perm_to_cycles</TT></A>, and <A HREF="#cycles_to_perm"><TT>cycles_to_perm</TT></A>.</P><!--TOC subsection Function: transpositions_to_perm-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc37">4.11</A>  Function: transpositions_to_perm<A NAME="sec:transpositions_to_perm"></A></H3><!--SEC END --><P>
<A NAME="transpositions_to_perm"></A>
<B>transpositions_to_perm</B>(<I>ain</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the permutation specified by the list of transpositions <I>ain</I>. </P><P><B>Arguments</B>
<TT>transpositions_to_perm</TT> requires one argument <I>ain</I>, which must be a list (lex or aex).</P><P><B>Options</B>
<TT>transpositions_to_perm</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Implementation</B>
Input is converted to lex on both levels. Default output is aex. </P><!--TOC section Functions and Variables for Documentation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc38">5</A>  Functions and Variables for Documentation</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#doc_system_list"><TT>doc_system_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_entry_latex"><TT>print_entry_latex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_maxdoc_entry"><TT>print_maxdoc_entry</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_maxdoc_sections"><TT>print_maxdoc_sections</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#print_sections_latex"><TT>print_sections_latex</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#read_docs_with_pager"><TT>read_docs_with_pager</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#set_all_doc_systems"><TT>set_all_doc_systems</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>
</LI></UL><!--TOC subsection Variable: doc_system_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">5.1</A>  Variable: doc_system_list<A NAME="sec:doc_system_list"></A></H3><!--SEC END --><P>
<A NAME="doc_system_list"></A></P><P>
<B>Description</B>
A list of the documenatation system that will be searched by ? and ??. This can be set to all avaliable systems with the function set_all_doc_systems. Also, if this variable is false, then all documentation is enabled. </P><!--TOC subsection Function: print_entry_latex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">5.2</A>  Function: print_entry_latex<A NAME="sec:print_entry_latex"></A></H3><!--SEC END --><P>
<A NAME="print_entry_latex"></A>
<B>print_entry_latex</B>(<I>item</I>)</P><P>mext package: defmfun1</P><P>
<B>Arguments</B>
<TT>print_entry_latex</TT> requires one argument <I>item</I>, which must be a string.</P><!--TOC subsection Function: print_maxdoc_entry-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc41">5.3</A>  Function: print_maxdoc_entry<A NAME="sec:print_maxdoc_entry"></A></H3><!--SEC END --><P>
<A NAME="print_maxdoc_entry"></A>
<B>print_maxdoc_entry</B>(<I>item</I>)</P><P>mext package: defmfun1</P><P>
<B>Arguments</B>
<TT>print_maxdoc_entry</TT> requires one argument <I>item</I>, which must be a string.</P><!--TOC subsection Function: print_maxdoc_sections-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc42">5.4</A>  Function: print_maxdoc_sections<A NAME="sec:print_maxdoc_sections"></A></H3><!--SEC END --><P>
<A NAME="print_maxdoc_sections"></A>
<B>print_maxdoc_sections</B>()</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Print all sections of maxdoc documentation. This does not include other documentation databases, such as the main maxima documentation. </P><P><B>Arguments</B>
<TT>print_maxdoc_sections</TT> requires zero arguments.</P><!--TOC subsection Function: print_sections_latex-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc43">5.5</A>  Function: print_sections_latex<A NAME="sec:print_sections_latex"></A></H3><!--SEC END --><P>
<A NAME="print_sections_latex"></A>
<B>print_sections_latex</B>( :optional <I>filename</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Print all sections of maxdoc documentation currently loaded in latex format to the file <I>filename</I>. This does not include other documentation databases, such as the main maxima documentation. </P><P><B>Arguments</B>
<TT>print_sections_latex</TT> requires either zero or one arguments.
<I>filename</I>, which must be a string.</P><!--TOC subsection Option variable: read_docs_with_pager-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc44">5.6</A>  Option variable: read_docs_with_pager<A NAME="sec:read_docs_with_pager"></A></H3><!--SEC END --><P>
<A NAME="read_docs_with_pager"></A></P><P>
default value <CODE>true</CODE>.</P><P><B>Description</B>
If read_docs_with_pager is true then documentation printedby describe() or ? or ?? is read with a pager. This will mostlikely only work with a command line interface under linux/unixwith certain lisp implementations. </P><!--TOC subsection Function: set_all_doc_systems-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc45">5.7</A>  Function: set_all_doc_systems<A NAME="sec:set_all_doc_systems"></A></H3><!--SEC END --><P>
<A NAME="set_all_doc_systems"></A>
<B>set_all_doc_systems</B>()</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Enable all documentation databases for describe, ? and ??. This sets doc_system_list to a list of all doc systems. </P><P><B>Arguments</B>
<TT>set_all_doc_systems</TT> requires zero arguments.</P><!--TOC subsection Function: simple_doc_add-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc46">5.8</A>  Function: simple_doc_add<A NAME="sec:simple_doc_add"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_add"></A>
<B>simple_doc_add</B>(<I>name</I>, <I>content</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Adds documentation string <I>content</I> for item <I>name</I>. These documentation strings are accessible via ’?’ and ’??’. </P><P><B>Arguments</B>
<TT>simple_doc_add</TT> requires two arguments.
The first argument <I>name</I> must be a string.
The second argument <I>content</I> must be a string.</P><P><B>See also</B>
<A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>, <A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>, <A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>, and <A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>.</P><!--TOC subsection Function: simple_doc_delete-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">5.9</A>  Function: simple_doc_delete<A NAME="sec:simple_doc_delete"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_delete"></A>
<B>simple_doc_delete</B>(<I>name</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Deletes the simple_doc documentation string for item <I>name</I>. </P><P><B>Arguments</B>
<TT>simple_doc_delete</TT> requires one argument <I>name</I>, which must be a string.</P><P><B>See also</B>
<A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>, <A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>, <A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>, and <A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>.</P><!--TOC subsection Function: simple_doc_get-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">5.10</A>  Function: simple_doc_get<A NAME="sec:simple_doc_get"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_get"></A>
<B>simple_doc_get</B>(<I>name</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Returns the simple_doc documentation string for item <I>name</I>. </P><P><B>Arguments</B>
<TT>simple_doc_get</TT> requires one argument <I>name</I>, which must be a string.</P><P><B>See also</B>
<A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>, <A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>, <A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>, and <A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>.</P><!--TOC subsection Function: simple_doc_init-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc49">5.11</A>  Function: simple_doc_init<A NAME="sec:simple_doc_init"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_init"></A>
<B>simple_doc_init</B>()</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Initialize the simple_doc documentation database. </P><P><B>Arguments</B>
<TT>simple_doc_init</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>, <A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>, <A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>, and <A HREF="#simple_doc_print"><TT>simple_doc_print</TT></A>.</P><!--TOC subsection Function: simple_doc_print-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc50">5.12</A>  Function: simple_doc_print<A NAME="sec:simple_doc_print"></A></H3><!--SEC END --><P>
<A NAME="simple_doc_print"></A>
<B>simple_doc_print</B>(<I>name</I>)</P><P>mext package: defmfun1</P><P>
<B>Description</B>
Prints the simple_doc documentation string for item <I>name</I>. </P><P><B>Arguments</B>
<TT>simple_doc_print</TT> requires one argument <I>name</I>, which must be a string.</P><P><B>See also</B>
<A HREF="#simple_doc_init"><TT>simple_doc_init</TT></A>, <A HREF="#simple_doc_add"><TT>simple_doc_add</TT></A>, <A HREF="#simple_doc_delete"><TT>simple_doc_delete</TT></A>, and <A HREF="#simple_doc_get"><TT>simple_doc_get</TT></A>.</P><!--TOC section Functions and Variables for Equations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc51">6</A>  Functions and Variables for Equations</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#nelder_mead"><TT>nelder_mead</TT></A>
</LI></UL><!--TOC subsection Function: nelder_mead-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc52">6.1</A>  Function: nelder_mead<A NAME="sec:nelder_mead"></A></H3><!--SEC END --><P>
<A NAME="nelder_mead"></A>
<B>nelder_mead</B>(<I>expr</I>, <I>vars</I>, <I>init</I>)</P><P>mext package: nelder_mead</P><P>
<B>Description</B>
The Nelder-Mead optimization algorithm. </P><P><B>Arguments</B>
<TT>nelder_mead</TT> requires three arguments.
The second argument <I>vars</I> must be a list of symbols.
The third argument <I>init</I> must be a list of numbers.</P><P><B>Examples</B></P><P>Find the minimum of a function at a non-analytic point. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) nelder_mead(if x&lt;0 then -x else x^2, [x], [4]);
(%o1) [x = 9.536387892694629e-11]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) f(x) := if x&lt;0 then -x else x^2$
(%i2) nelder_mead(f, [x], [4]);
(%o2) [x = 9.536387892694628e-11]
(%i3) nelder_mead(f(x), [x], [4]);
(%o3) [x = 9.536387892694628e-11]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) nelder_mead(x^4+y^4-2*x*y-4*x-3*y, [x,y], [2,2]);
(%o1) [x = 1.157212489168102,y = 1.099342680267472]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>Author</B>
Mario S. Mommer.</P><!--TOC section Functions and Variables for Function Definition-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc53">7</A>  Functions and Variables for Function Definition</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#comp_load"><TT>comp_load</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#compile_file1"><TT>compile_file1</TT></A>
</LI></UL><!--TOC subsection Function: comp_load-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc54">7.1</A>  Function: comp_load<A NAME="sec:comp_load"></A></H3><!--SEC END --><P>
<A NAME="comp_load"></A>
<B>comp_load</B>(<I>fname</I> :optional <I>pathlist</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Compile and load a lisp file. Maxima does not load it by default with <TT>compile_file</TT>. If the input filename does not end with “.lisp”, it will be appended. If <I>pathlist</I> is specified, then <I>fname</I> is only searched for in directories in <I>pathlist</I>. </P><P><B>Arguments</B>
<TT>comp_load</TT> requires either one or two arguments.
The first argument <I>fname</I> must be a string.
The second argument <I>pathlist</I> must be a string or a list of strings.</P><!--TOC subsection Function: compile_file1-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc55">7.2</A>  Function: compile_file1<A NAME="sec:compile_file1"></A></H3><!--SEC END --><P>
<A NAME="compile_file1"></A>
<B>compile_file1</B>(<I>input-file</I> :optional <I>bin-file</I>, <I>translation-output-file</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
This is copied from maxima <TT>compile_file</TT>, with changes. Sometimes a loadable binary file is apparently compiled, but an error flag is set and <TT>compile_file</TT> returns false for the output binary filename. Here we return the binary filename in any case. </P><P><B>Arguments</B>
<TT>compile_file1</TT> requires between one and three arguments.
The first argument <I>input-file</I> must be a string.</P><!--TOC section Functions and Variables for Input and Output-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc56">8</A>  Functions and Variables for Input and Output</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#pager_command"><TT>pager_command</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#pager_string"><TT>pager_string</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#restore"><TT>restore</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#restore_fast"><TT>restore_fast</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#store"><TT>store</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#store_fast"><TT>store_fast</TT></A>
</LI></UL><!--TOC subsection Option variable: pager_command-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc57">8.1</A>  Option variable: pager_command<A NAME="sec:pager_command"></A></H3><!--SEC END --><P>
<A NAME="pager_command"></A></P><P>
default value <CODE>/usr/bin/less</CODE>.</P><P><B>Description</B>
The pathname to the pager program used for reading paged output, eg for documentation. </P><P><B>See also</B>
<A HREF="#read_docs_with_pager"><TT>read_docs_with_pager</TT></A>.</P><!--TOC subsection Function: pager_string-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc58">8.2</A>  Function: pager_string<A NAME="sec:pager_string"></A></H3><!--SEC END --><P>
<A NAME="pager_string"></A>
<B>pager_string</B>(<I>s</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Read the string <I>s</I> in the pager given by the maxima variable <CODE>pager_command</CODE>.This works at least with gcl under linux. </P><P><B>Arguments</B>
<TT>pager_string</TT> requires one argument <I>s</I>, which must be a string.</P><!--TOC subsection Function: restore-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc59">8.3</A>  Function: restore<A NAME="sec:restore"></A></H3><!--SEC END --><P>
<A NAME="restore"></A>
<B>restore</B>(<I>file</I>)</P><P>mext package: store</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>restore</B>(<I>file</I>)
Reads and returns expressions from the file <I>file</I>. </LI></UL><P>
<B>Description</B>
Reads maxima expressions from file <I>file</I> created by the function <A HREF="#store"><TT>store</TT></A>. </P><P><B>Arguments</B>
<TT>restore</TT> requires one argument <I>file</I>, which must be a string.</P><P><B>See also</B>
<A HREF="#store"><TT>store</TT></A>, <A HREF="#store_fast"><TT>store_fast</TT></A>, and <A HREF="#restore_fast"><TT>restore_fast</TT></A>.</P><!--TOC subsection Function: restore_fast-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc60">8.4</A>  Function: restore_fast<A NAME="sec:restore_fast"></A></H3><!--SEC END --><P>
<A NAME="restore_fast"></A>
<B>restore_fast</B>(<I>file</I>)</P><P>mext package: store</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>restore_fast</B>(<I>file</I>)
Reads and returns expressios from the file <I>file</I>. No checking for circular references is done. </LI></UL><P>
<B>Description</B>
Reads maxima expressions from file <I>file</I> created by the function <A HREF="#store"><TT>store</TT></A>, or <A HREF="#store_fast"><TT>store_fast</TT></A>. No checks for circular references are done. </P><P><B>Arguments</B>
<TT>restore_fast</TT> requires one argument <I>file</I>, which must be a string.</P><P><B>See also</B>
<A HREF="#store"><TT>store</TT></A>, <A HREF="#restore"><TT>restore</TT></A>, and <A HREF="#store_fast"><TT>store_fast</TT></A>.</P><!--TOC subsection Function: store-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc61">8.5</A>  Function: store<A NAME="sec:store"></A></H3><!--SEC END --><P>
<A NAME="store"></A>
<B>store</B>(<I>file</I> :rest <I>exprs</I>)</P><P>mext package: store</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>store</B>(<I>file</I>, <I>expr1</I>, <I>expr2</I>, <I>...</I>)
stores the expressions to the file <I>file</I>. </LI></UL><P>
<B>Description</B>
Stores maxima expressions <I>exprs</I> in <I>file</I> in binary format. Many types of lisp expressions and subexpressions are supported: numbers,strings,list,arrays,hashtables,structures,.... </P><P><B>Arguments</B>
<TT>store</TT> requires one or more arguments. The first argument <I>file</I> must be a string.</P><P><B>Examples</B></P><P>Save a graph to a file. This cannot be done with the command &lt;save&gt;. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) load(graphs)$
(%i2) c : petersen_graph();
(%o2) GRAPH(10 vertices, 15 edges)
(%i3) factor(graph_charpoly(c,x));
(%o3) (x-3)*(x-1)^5*(x+2)^4
(%i4) store("graph.cls",c)$
(%i5) factor(graph_charpoly( restore("graph.cls"), x));
(%o5) (x-3)*(x-1)^5*(x+2)^4
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#restore"><TT>restore</TT></A>, <A HREF="#store_fast"><TT>store_fast</TT></A>, and <A HREF="#restore_fast"><TT>restore_fast</TT></A>.</P><P><B>Implementation</B>
store uses the cl-store library. See the cl-store documentation for more information. </P><!--TOC subsection Function: store_fast-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc62">8.6</A>  Function: store_fast<A NAME="sec:store_fast"></A></H3><!--SEC END --><P>
<A NAME="store_fast"></A>
<B>store_fast</B>(<I>file</I> :rest <I>exprs</I>)</P><P>mext package: store</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>store_fast</B>(<I>file</I>, <I>expr1</I>, <I>expr2</I>, <I>...</I>)
stores the expressions to the file <I>file</I>. No checking for circular references is done. </LI></UL><P>
<B>Description</B>
Stores maxima expressions <I>exprs</I> in <I>file</I> in binary format. This is like <A HREF="#store"><TT>store</TT></A>, except that no checks for circular references are done. </P><P><B>Arguments</B>
<TT>store_fast</TT> requires one or more arguments. The first argument <I>file</I> must be a string.</P><P><B>See also</B>
<A HREF="#store"><TT>store</TT></A>, <A HREF="#restore"><TT>restore</TT></A>, and <A HREF="#restore_fast"><TT>restore_fast</TT></A>.</P><!--TOC section Functions and Variables for Lists-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc63">9</A>  Functions and Variables for Lists</H2><!--SEC END --><P>These functions manipulate lists. They build lists, take them apart, select elements, etc.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#aelistp"><TT>aelistp</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#constant_list"><TT>constant_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#count"><TT>count</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#drop_while"><TT>drop_while</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#every1"><TT>every1</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#fold"><TT>fold</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#fold_list"><TT>fold_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#icons"><TT>icons</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#imap"><TT>imap</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#length_while"><TT>length_while</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#lrange"><TT>lrange</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nest"><TT>nest</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nest_list"><TT>nest_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nest_while"><TT>nest_while</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#nreverse"><TT>nreverse</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#partition_list"><TT>partition_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#select"><TT>select</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#sequence specifier"><TT>sequence specifier</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#table"><TT>table</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#take"><TT>take</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#take_while"><TT>take_while</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#tuples"><TT>tuples</TT></A>
</LI></UL><!--TOC subsection Function: aelistp-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc64">9.1</A>  Function: aelistp<A NAME="sec:aelistp"></A></H3><!--SEC END --><P>
<A NAME="aelistp"></A></P><P>
<B>Description</B>
Returns true if <I>e</I> is a list, either ml or ar representation. </P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) aelistp([1,2,3]);
(%o1) true
(%i1) aelistp( aex([1,2,3]));
(%o1) true
(%i2) aelistp(3);
(%o2) false
(%i3) aelistp(x);
(%o3) false
(%i4) x:lrange(10),aelistp(x);
(%o4) true
(%i5) aelistp(%%f(y));
(%o5) false
(%i6) aelistp( aex( %%f(y) ));
(%o6) false
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: constant_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc65">9.2</A>  Function: constant_list<A NAME="sec:constant_list"></A></H3><!--SEC END --><P>
<A NAME="constant_list"></A>
<B>constant_list</B>(<I>expr</I>, <I>list</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Returns a list of <I>n</I> elements, each of which is an independent copy of expr. <CODE>constant_list(expr,[n,m,..])</CODE> returns a nested list of dimensions <I>n</I>,<I>m</I>,…where each leaf is an independent copy of expr and the copies of each list at each level are independent. If a third argument 
is given, then it is used as the op, rather than ‘list’, at every level. </P><P><B>Arguments</B>
<TT>constant_list</TT> requires either two or three arguments.
The second argument <I>spec</I> must be a positive integer or a list of positive integers.</P><P><B>Options</B>
<TT>constant_list</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#makelist"><TT>makelist</TT></A>, <A HREF="#lrange"><TT>lrange</TT></A>, and <A HREF="#table"><TT>table</TT></A>.</P><!--TOC subsection Function: count-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc66">9.3</A>  Function: count<A NAME="sec:count"></A></H3><!--SEC END --><P>
<A NAME="count"></A>
<B>count</B>(<I>expr</I>, <I>item</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Counts the number of items in <I>expr</I> matching <I>item</I>. If <I>item</I> is a lambda function then <I>compile</I> must be true. </P><P><B>Arguments</B>
<TT>count</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and either aex or represented by a lisp list.</P><P><B>Options</B>
<TT>count</TT> takes options with default values: <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) count([1,2,"dog"], 'numberp);
(%o1) 2
(%i1) count([1,2,"dog"], "dog");
(%o1) 1
(%i2) count(lrange(10^4), lambda([x], is(mod(x,3) = 0)));
(%o2) 3333
(%i3) count( %%ff(1,2,"dog"), "dog");
(%o3) 1
(%i4) count(lrange(100,ot-&gt;ar), 'evenp);
(%o4) 50
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: drop_while-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc67">9.4</A>  Function: drop_while<A NAME="sec:drop_while"></A></H3><!--SEC END --><P>
<A NAME="drop_while"></A>
<B>drop_while</B>(<I>expr</I>, <I>test</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>drop_while</B>(<I>expr</I>, <I>test</I>)
Tests the elements of <I>expr</I> in order, dropping them until <I>test</I> fails. The remaining elements are returned in an expression with the same op as that <I>expr</I>. </LI></UL><P>
<B>Arguments</B>
<TT>drop_while</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.</P><P><B>Options</B>
<TT>drop_while</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Drop elements as long as they are negative. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) drop_while([-3,-10,-1,3,6,7,-4], lambda([x], is(x&lt;0)));
(%o1) [3,6,7,-4]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: every1-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc68">9.5</A>  Function: every1<A NAME="sec:every1"></A></H3><!--SEC END --><P>
<A NAME="every1"></A>
<B>every1</B>(<I>expr</I>, <I>test</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>every1</B>(<I>expr</I>, <I>test</I>)
Returns true if <I>test</I> is true for each element in <I>expr</I>. Otherwise, false is returned. This is like <CODE>every</CODE> but allow a test that takes only one argument. For some inputs, every1 is much faster than every. </LI></UL><P>
<B>Arguments</B>
<TT>every1</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.</P><P><B>Options</B>
<TT>every1</TT> takes options with default values: <TT>compile-&gt;true</TT>.
</P><!--TOC subsection Function: fold-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc69">9.6</A>  Function: fold<A NAME="sec:fold"></A></H3><!--SEC END --><P>
<A NAME="fold"></A></P><P>mext package: lists_aex</P><P>
<B>Description</B>
<CODE>fold(f,x,[a,b,c])</CODE> returns <CODE> f(f(f(x,a),b),c).</CODE> </P><P><B>Arguments</B>
<TT>fold</TT> requires three arguments.
The third argument <I>v</I> must be non-atomic.</P><P><B>Options</B>
<TT>fold</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>See also</B>
<A HREF="#fold_list"><TT>fold_list</TT></A> and <A HREF="#nest"><TT>nest</TT></A>.</P><!--TOC subsection Function: fold_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">9.7</A>  Function: fold_list<A NAME="sec:fold_list"></A></H3><!--SEC END --><P>
<A NAME="fold_list"></A></P><P>mext package: lists_aex</P><P>
<B>Description</B>
fold_list(f,x,[a,b,c]) returns [f(x,a),f(f(x,a),b),f(f(f(x,a),b),c)]. </P><P><B>Arguments</B>
<TT>fold_list</TT> requires three arguments.
The third argument <I>v</I> must be non-atomic.</P><P><B>Options</B>
<TT>fold_list</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>See also</B>
<A HREF="#fold"><TT>fold</TT></A> and <A HREF="#nest"><TT>nest</TT></A>.</P><!--TOC subsection Function: icons-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc71">9.8</A>  Function: icons<A NAME="sec:icons"></A></H3><!--SEC END --><P>
<A NAME="icons"></A>
<B>icons</B>(<I>x</I>, <I>e</I>)</P><P>
<B>Description</B>
<A HREF="#icons"><TT>icons</TT></A> is like maxima <TT>cons</TT>, but less general, and much, much faster. <I>x</I> is a maxima object. <I>e</I> is a maxima list or list-like object, such as <CODE>[a]</CODE>, or <CODE>f(a)</CODE>. It is suitable at a minimum, for pushing a number or list or string onto a list of 
numbers, or strings or lists. If you find <A HREF="#icons"><TT>icons</TT></A> gives buggy behavior that you are not interested in investigating, use <TT>cons</TT> instead. </P><P><B>Implementation</B>
In a function that mostly only does icons in a loop, icons defined with defmfun rather than defmfun1 runs almost twice as fast. So icons is defined with defmfun rather than defmfun1. icons does no argument checking. </P><!--TOC subsection Function: imap-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc72">9.9</A>  Function: imap<A NAME="sec:imap"></A></H3><!--SEC END --><P>
<A NAME="imap"></A>
<B>imap</B>(<I>f</I>, <I>expr</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Maps functions of a single argument. I guess that <TT>map</TT> handles more types of input without error. But <A HREF="#imap"><TT>imap</TT></A> can be much faster for some inputs. </P><P><B>Arguments</B>
<TT>imap</TT> requires two arguments.
The second argument <I>expr</I> must be non-atomic.</P><P><B>Options</B>
<TT>imap</TT> takes options with default values: <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Map sqrt efficiently over a list of floats </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) (a : lrange(1.0,4),
        imap(lambda([x],modedeclare(x,float),sqrt(x)),a));
(%o1) [1.0,1.414213562373095,1.732050807568877,2.0]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>With aex expression, no conversions to lex are done. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) (a : lrange(1.0,4,ot-&gt;ar),
          imap(lambda([x],modedeclare(x,float),sqrt(x)),a));
(%o1) &lt;[1.0,1.414213562373095,1.732050807568877,2.0]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: length_while-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc73">9.10</A>  Function: length_while<A NAME="sec:length_while"></A></H3><!--SEC END --><P>
<A NAME="length_while"></A>
<B>length_while</B>(<I>expr</I>, <I>test</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Computes the length of <I>expr</I> while <I>test</I> is true. </P><P><B>Arguments</B>
<TT>length_while</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.</P><P><B>Options</B>
<TT>length_while</TT> takes options with default values: <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) length_while([-3,-10,-1,3,6,7,-4], lambda([x], is(x&lt;0)));
(%o1) 3
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: lrange-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc74">9.11</A>  Function: lrange<A NAME="sec:lrange"></A></H3><!--SEC END --><P>
<A NAME="lrange"></A></P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>lrange</B>(<I>stop</I>)
returns a list of numbers from 1 through <I>stop</I>. </LI><LI CLASS="li-itemize"> <B>lrange</B>(<I>start</I>, <I>stop</I>)
returns a list of expressions from <I>start</I> through <I>stop</I>. </LI><LI CLASS="li-itemize"> <B>lrange</B>(<I>start</I>, <I>stop</I>, <I>incr</I>)
returns a list of expressions from <I>start</I> through <I>stop</I> in steps of <I>incr</I>. </LI></UL><P>
<B>Description</B>
lrange is much more efficient than makelist for creating ranges, particularly for large lists (e.g. 10<SUP>5</SUP> or more items.) Functions for creating a list of numbers, in order of decreasing speed, are: <A HREF="#lrange"><TT>lrange</TT></A>, <A HREF="#table"><TT>table</TT></A>, <TT>create_list</TT>,<TT>makelist</TT>. </P><P><B>Arguments</B>
<TT>lrange</TT> requires between one and three arguments.
The third argument <I>incr</I> must be an expression that is not zero.</P><P><B>Options</B>
<TT>lrange</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) lrange(6);
(%o1) [1,2,3,4,5,6]
(%i1) lrange(2,6);
(%o1) [2,3,4,5,6]
(%i2) lrange(2,6,2);
(%o2) [2,4,6]
(%i3) lrange(6,1,-1);
(%o3) [6,5,4,3,2,1]
(%i4) lrange(6,1,-2);
(%o4) [6,4,2]
(%i5) lrange(6,ot-&gt;ar);
(%o5) &lt;[1,2,3,4,5,6]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The type of the first element and increment determine the type of the 
elements. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) lrange(1.0,6);
(%o1) [1.0,2.0,3.0,4.0,5.0,6.0]
(%i1) lrange(1.0b0,6);
(%o1) [1.0b0,2.0b0,3.0b0,4.0b0,5.0b0,6.0b0]
(%i2) lrange(1/2,6);
(%o2) [1/2,3/2,5/2,7/2,9/2,11/2]
(%i3) lrange(6.0,1,-1);
(%o3) [6.0,5.0,4.0,3.0,2.0,1.0]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Symbols can be used for limits or increments. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) lrange(x,x+4);
(%o1) [x,x+1,x+2,x+3,x+4]
(%i1) lrange(x,x+4*a,a);
(%o1) [x,x+a,x+2*a,x+3*a,x+4*a]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#makelist"><TT>makelist</TT></A>, <A HREF="#table"><TT>table</TT></A>, and <A HREF="#constant_list"><TT>constant_list</TT></A>.</P><!--TOC subsection Function: nest-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc75">9.12</A>  Function: nest<A NAME="sec:nest"></A></H3><!--SEC END --><P>
<A NAME="nest"></A></P><P>mext package: lists_aex</P><P>
<B>Description</B>
nest(f,x,n) returns f(...f(f(f(x)))...) where there are n nested calls of f. </P><P><B>Arguments</B>
<TT>nest</TT> requires three arguments.
The first argument <I>f</I> must be a function.
The third argument <I>n</I> must be a non-negative integer.</P><P><B>Options</B>
<TT>nest</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><!--TOC subsection Function: nest_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc76">9.13</A>  Function: nest_list<A NAME="sec:nest_list"></A></H3><!--SEC END --><P>
<A NAME="nest_list"></A>
<B>nest_list</B>(<I>f</I>, <I>x</I>, <I>n</I>)</P><P>mext package: lists_aex</P><P>
<B>Arguments</B>
<TT>nest_list</TT> requires three arguments.
The third argument <I>n</I> must be a non-negative integer.</P><P><B>Options</B>
<TT>nest_list</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Find the first 10 primes after 100. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) nest_list(next_prime,100,10);
(%o1) [101,103,107,109,113,127,131,137,139,149]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#nest"><TT>nest</TT></A>, <A HREF="#fold"><TT>fold</TT></A>, and <A HREF="#fold_list"><TT>fold_list</TT></A>.</P><!--TOC subsection Function: nest_while-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc77">9.14</A>  Function: nest_while<A NAME="sec:nest_while"></A></H3><!--SEC END --><P>
<A NAME="nest_while"></A>
<B>nest_while</B>(<I>f</I>, <I>x</I>, <I>test</I> :optional <I>min</I>, <I>max</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>nest_while</B>(<I>f</I>, <I>x</I>, <I>test</I>)
applies <I>f</I> to <I>x</I> until <I>test</I> fails to return true when called on the nested result. </LI><LI CLASS="li-itemize"> <B>nest_while</B>(<I>f</I>, <I>x</I>, <I>test</I>, <I>min</I>)
applies <I>f</I> at least <I>min</I> times. </LI><LI CLASS="li-itemize"> <B>nest_while</B>(<I>f</I>, <I>x</I>, <I>test</I>, <I>min</I>, <I>max</I>)
applies <I>f</I> not more than <I>max</I> times. </LI></UL><P>
<B>Arguments</B>
<TT>nest_while</TT> requires between three and five arguments.
The fourth argument <I>min</I> must be a non-negative integer.
The fifth argument <I>max</I> must be a non-negative integer.</P><P><B>Options</B>
<TT>nest_while</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Implementation</B>
This should be modified to allow applying test to more than just the most recent result. </P><!--TOC subsection Function: nreverse-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc78">9.15</A>  Function: nreverse<A NAME="sec:nreverse"></A></H3><!--SEC END --><P>
<A NAME="nreverse"></A>
<B>nreverse</B>(<I>e</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Destructively reverse the arguments of expression <I>e</I>. This is more efficient than using reverse. </P><P><B>Arguments</B>
<TT>nreverse</TT> requires one argument <I>e</I>, which must be non-atomic.</P><P><B>Examples</B></P><P>Be careful not to use &lt;a&gt; after applying nreverse. Assign the result to 
another variable. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) a : lrange(10), b : nreverse(a);
(%o1) [10,9,8,7,6,5,4,3,2,1]
(%i1) a : lrange(10,ot-&gt;ar), b : nreverse(a);
(%o1) &lt;[10,9,8,7,6,5,4,3,2,1]&gt;
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#reverse"><TT>reverse</TT></A>.</P><!--TOC subsection Function: partition_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc79">9.16</A>  Function: partition_list<A NAME="sec:partition_list"></A></H3><!--SEC END --><P>
<A NAME="partition_list"></A>
<B>partition_list</B>(<I>e</I>, <I>nlist</I> :optional <I>dlist</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>partition_list</B>(<I>e</I>, <I>n</I>)
partitions <I>e</I> into sublists of length <I>n</I> </LI><LI CLASS="li-itemize"> <B>partition_list</B>(<I>e</I>, <I>n</I>, <I>d</I>)
partitions <I>e</I> into sublists of length <I>n</I> with offsets <I>d</I>. </LI></UL><P>
<B>Description</B>
Omitting <I>d</I> is equivalent to giving <I>d</I> equal to <I>n</I>. <I>e</I> can be any expression, not only a list. If <I>n</I> is a list, then <A HREF="#partition_list"><TT>partition_list</TT></A> partitions at sucessively deeper levels with elements of <I>n</I>. If <I>n</I> and <I>d</I> are lists, the 
first elementsof <I>n</I> and <I>d</I> apply at the highest level and so on. If <I>n</I> is a list and <I>d</I> is a number, then the offset <I>d</I> is used with each of the <I>n</I>. </P><P><B>Arguments</B>
<TT>partition_list</TT> requires either two or three arguments.
The first argument <I>e</I> must be non-atomic.
The second argument <I>nlist</I> must be an integer or a list of integers.
The third argument <I>dlist</I> must be an integer or a list of integers.</P><P><B>Examples</B></P><P>Partition the numbers from 1 through 10 into pairs. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) partition_list([1,2,3,4,5,6,7,8,9,10],2);
(%o1) [[1,2],[3,4],[5,6],[7,8],[9,10]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: select-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc80">9.17</A>  Function: select<A NAME="sec:select"></A></H3><!--SEC END --><P>
<A NAME="select"></A>
<B>select</B>(<I>expr</I>, <I>test</I> :optional <I>n</I>)</P><P>mext package: lists_aex</P><P>
<B>Description</B>
Returns a list of all elements of <I>expr</I> for which <I>test</I> is true. <I>expr</I> may have any op. </P><P><B>Arguments</B>
<TT>select</TT> requires either two or three arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.
The third argument <I>n</I> must be a positive integer.</P><P><B>Options</B>
<TT>select</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Select elements less than 3 </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) select([1,2,3,4,5,6,7], lambda([x], is(x&lt;3)));
(%o1) [1,2]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Argument type: sequence specifier-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">9.18</A>  Argument type: sequence specifier<A NAME="sec:sequence specifier"></A></H3><!--SEC END --><P>
<A NAME="sequence specifier"></A></P><P>
<B>Description</B>
A sequence specification specifies a subsequence of the elements in an expression. A single positive number <I>n</I> means the first <I>n</I> elements. −<I>n</I> means the last <I>n</I> elements. A list of three numbers <CODE>[i1,i2,i3]</CODE> means the <CODE>i1</CODE>th through the <CODE>i2</CODE>th stepping by <CODE>i3</CODE>. If <CODE>i1</CODE> 
or <CODE>i2</CODE> are negative, they count from the end. If <CODE>i3</CODE> is negative, stepping is down and <CODE>i1</CODE> must be greater than or equal to <CODE>i2</CODE>. If <CODE>i3</CODE> is omitted, it is taken to be 1. A sequence specifiier can also be one of ’all ’none or ’reverse, which mean all elements, no 
elements or all elements in reverse order respectively. </P><P><B>See also</B>
<A HREF="#take"><TT>take</TT></A> and <A HREF="#string_take"><TT>string_take</TT></A>.</P><!--TOC subsection Function: table-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc82">9.19</A>  Function: table<A NAME="sec:table"></A></H3><!--SEC END --><P>
<A NAME="table"></A></P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>table</B>(<I>expr</I>, [<I>n</I>])
Evaluates expression <I>number</I> times. If <I>number</I> is not an integer or a floating point number, then <TT>float</TT> is called. If we have a floating point number, it is truncated into an integer. This type of iterator is the fastest, since no variable is bound. </LI><LI CLASS="li-itemize"> <B>table</B>(<I>expr</I>, [<I>variable</I>, <I>initial</I>, <I>end</I>, <I>step</I>])
Returns a list of evaluated expressions where <I>variable</I> (a symbol) is set to a value. The first element of the returned list is <I>expression</I> evaluated with <I>variable</I> set to <I>initial</I>. The <I>i</I>-th element of the returned list is <I>expression</I> evaluated with <I>variable</I> set to 
<I>initial</I> + (<I>i</I>−1) <I>step</I>. The iteration stops once the value is greater (if <I>step</I> is positive) or smaller (if <I>step</I> is negative) than <I>end</I>. Requirement: The difference between <I>end</I> and <I>intial</I> must return a <TT>numberp</TT> number. <I>step</I> must be a nonzero <TT>numberp</TT> number. This allows for iterators of rather general forms like <CODE>[i, %i - 2, %i, 0.1b0] </CODE>…</LI><LI CLASS="li-itemize"> <B>table</B>(<I>expr</I>, [<I>variable</I>, <I>initial</I>, <I>end</I>])
This iterator uses a step of 1 and is equal to [<I>variable</I>,<I>initial</I>,<I>end</I>, 1]. </LI></UL><P>
<B>Arguments</B>
<TT>table</TT> requires two or more arguments.
The second argument <I>iterator1</I> must be a list.
Each of the remaining arguments must be a list.</P><P><B>Options</B>
<TT>table</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Attributes</B>
table has attributes: [hold_all]</P><P><B>Examples</B></P><P>Make a list of function values </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) table(sin(x),[x,0,2*%pi,%pi/4]);
(%o1) [0,1/sqrt(2),1,1/sqrt(2),0,-1/sqrt(2),-1,-1/sqrt(2),0]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Make a nested list. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) table( x^y, [x,1,2], [y,1,2]);
(%o1) [[1,1],[2,4]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#makelist"><TT>makelist</TT></A>, <A HREF="#lrange"><TT>lrange</TT></A>, and <A HREF="#constant_list"><TT>constant_list</TT></A>.</P><P><B>Author</B>
Ziga Lenarcic.</P><!--TOC subsection Function: take-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc83">9.20</A>  Function: take<A NAME="sec:take"></A></H3><!--SEC END --><P>
<A NAME="take"></A>
<B>take</B>(<I>e</I> :rest <I>v</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>take</B>(<I>e</I>, <I>n</I>)
returns a list of the first <I>n</I> elements of list or expression <I>e</I>. </LI><LI CLASS="li-itemize"> <B>take</B>(<I>e</I>, [<I>n1</I>, <I>n2</I>])
returns a list of the <I>n1</I>th through <I>n2</I>th elements of list or expression <I>e</I>. </LI><LI CLASS="li-itemize"> <B>take</B>(<I>e</I>, [<I>n1</I>, <I>n2</I>, <I>step</I>])
returns a list of the <I>n1</I>th through <I>n2</I>th elements stepping by <I>step</I> of list or expression <I>e</I>. </LI><LI CLASS="li-itemize"> <B>take</B>(<I>e</I>, -n )
returns the last <I>n</I> elements. </LI><LI CLASS="li-itemize"> <B>take</B>(<I>e</I>, <I>spec1</I>, <I>spec2</I>, <I>...</I>)
applies the sequence specifications at sucessively deeper levels in <I>e</I>. </LI></UL><P>
<B>Description</B>
<I>e</I> can have mixed lex and aex expressions on different levels. If more sequence specifications are given, they apply to sucessively deeper levels in <I>e</I>. </P><P><B>Arguments</B>
<TT>take</TT> requires one or more arguments. The first argument <I>e</I> must be non-atomic.
Each of the remaining arguments must be a sequence specification.</P><P><B>Examples</B></P><P>Take the first 3 elements of a list. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d,e],3);
(%o1) [a,b,c]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the last 3 elements of a list. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d,e],-3);
(%o1) [c,d,e]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the second through third elements of a list. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d,e],[2,3]);
(%o1) [b,c]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the second through tenth elements of a list counting by two. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([1,2,3,4,5,6,7,8,9,10],[2,10,2]);
(%o1) [2,4,6,8,10]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the last through first elements of a list counting backwards by one. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d],[-1,1,-1]);
(%o1) [d,c,b,a]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Shorthand for the previous example is ’reverse. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([a,b,c,d],'reverse);
(%o1) [d,c,b,a]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take the second through third elements at the first level and the last 2 
elements at the second level. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take([[a,b,c], [d,e,f], [g,h,i]], [2,3],-2);
(%o1) [[e,f],[h,i]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: take_while-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc84">9.21</A>  Function: take_while<A NAME="sec:take_while"></A></H3><!--SEC END --><P>
<A NAME="take_while"></A>
<B>take_while</B>(<I>expr</I>, <I>test</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>take_while</B>(<I>expr</I>, <I>test</I>)
collects the elements in <I>expr</I> until <I>test</I> fails on one of them. The op of the returned expression is the same as the op of <I>expr</I>. </LI></UL><P>
<B>Arguments</B>
<TT>take_while</TT> requires two arguments.
The first argument <I>expr</I> must be non-atomic and represented by a lisp list.</P><P><B>Options</B>
<TT>take_while</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>, <TT>compile-&gt;true</TT>.
</P><P><B>Examples</B></P><P>Take elements as long as they are negative. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) take_while([-3,-10,-1,3,6,7,-4], lambda([x], is(x&lt;0)));
(%o1) [-3,-10,-1]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: tuples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc85">9.22</A>  Function: tuples<A NAME="sec:tuples"></A></H3><!--SEC END --><P>
<A NAME="tuples"></A>
<B>tuples</B>(<I>list-or-lists</I> :optional <I>n</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>tuples</B>(<I>list</I>, <I>n</I>)
Return a list of all lists of length <I>n</I> whose elements are chosen from <I>list</I>. </LI><LI CLASS="li-itemize"> <B>tuples</B>([<I>list1</I>, <I>list2</I>, <I>...</I>])
Return a list of all lists whose <I>i</I>_th element is chosen from <I>listi</I>. </LI></UL><P>
<B>Arguments</B>
<TT>tuples</TT> requires either one or two arguments.
The first argument <I>list-or-lists</I> must be non-atomic and represented by a lisp list.
The second argument <I>n</I> must be a non-negative integer.</P><P><B>Options</B>
<TT>tuples</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>Examples</B></P><P>Make all three letter words in the alphabet ‘a,b’. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) tuples([a,b],3);
(%o1) [[a,a,a],[a,a,b],[a,b,a],[a,b,b],[b,a,a],[b,a,b],[b,b,a],[b,b,b]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Take all pairs chosen from two lists. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) tuples([ [0,1] , [x,y,z] ]);
(%o1) [[0,x],[0,y],[0,z],[1,x],[1,y],[1,z]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>tuples works for expressions other than lists. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) tuples(f(0,1),3);
(%o1) [f(0,0,0),f(0,0,1),f(0,1,0),f(0,1,1),f(1,0,0),f(1,0,1),f(1,1,0),f(1,1,1)]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC section Functions and Variables for Number Theory-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc86">10</A>  Functions and Variables for Number Theory</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#abundant_p"><TT>abundant_p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#amicable_p"><TT>amicable_p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#catalan_number"><TT>catalan_number</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#divisor_function"><TT>divisor_function</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#from_digits"><TT>from_digits</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#integer_digits"><TT>integer_digits</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#integer_string"><TT>integer_string</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#oeis_A092143"><TT>oeis_A092143</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#perfect_p"><TT>perfect_p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#prime_pi"><TT>prime_pi</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#prime_pi_soe"><TT>prime_pi_soe</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#prime_twins"><TT>prime_twins</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#primes1"><TT>primes1</TT></A>
</LI></UL><!--TOC subsection Function: abundant_p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc87">10.1</A>  Function: abundant_p<A NAME="sec:abundant_p"></A></H3><!--SEC END --><P>
<A NAME="abundant_p"></A>
<B>abundant_p</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns true if <I>n</I> is an abundant number. Otherwise, returns false. </P><P><B>Arguments</B>
<TT>abundant_p</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P><B>Examples</B></P><P>The abundant numbers between 1 and 100 </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) select(lrange(100),abundant_p);
(%o1) [12,18,20,24,30,36,40,42,48,54,56,60,66,70,72,78,80,84,88,90,96,100]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, and <A HREF="#perfect_p"><TT>perfect_p</TT></A>.</P><!--TOC subsection Function: aliquot_sequence-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc88">10.2</A>  Function: aliquot_sequence<A NAME="sec:aliquot_sequence"></A></H3><!--SEC END --><P>
<A NAME="aliquot_sequence"></A>
<B>aliquot_sequence</B>(<I>k</I>, <I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the first <I>n</I> elements (counting from zero) in the aliquot sequence of <I>k</I>. The sequence is truncated at an element if it is zero or repeats the previous element. </P><P><B>Arguments</B>
<TT>aliquot_sequence</TT> requires two arguments.
The first argument <I>k</I> must be a positive integer.
The second argument <I>n</I> must be a non-negative integer.</P><P><B>Examples</B></P><P>Perfect numbers give a repeating sequence of period 1. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) imap(lambda([x],aliquot_sequence(x,100)),[6,28,496,8128]);
(%o1) [[6],[28],[496],[8128]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>Aspiring numbers are those which are not perfect, but terminate with a 
repeating perfect number. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) imap(lambda([x],aliquot_sequence(x,100)),[25, 95, 119, 143, 417, 445, 565, 608, 650, 652, 675, 685]);
(%o1) [[25,6],[95,25,6],[119,25,6],[143,25,6],[417,143,25,6],[445,95,25,6],[565,119,25,6],[608,652,496],[650,652,496],[652,496],[675,565,119,25,6],[685,143,25,6]]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, <A HREF="#perfect_p"><TT>perfect_p</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><!--TOC subsection Function: aliquot_sum-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">10.3</A>  Function: aliquot_sum<A NAME="sec:aliquot_sum"></A></H3><!--SEC END --><P>
<A NAME="aliquot_sum"></A>
<B>aliquot_sum</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the aliquot sum of <I>n</I>. The aliquot sum of <I>n</I> is the sum of the proper divisors of <I>n</I>. </P><P><B>Arguments</B>
<TT>aliquot_sum</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P><B>Attributes</B>
aliquot_sum has attributes: [match_form]</P><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, <A HREF="#perfect_p"><TT>perfect_p</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><!--TOC subsection Function: amicable_p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc90">10.4</A>  Function: amicable_p<A NAME="sec:amicable_p"></A></H3><!--SEC END --><P>
<A NAME="amicable_p"></A>
<B>amicable_p</B>(<I>n</I>, <I>m</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns true if <I>n</I> and <I>m</I> are amicable, and false otherwise. </P><P><B>Arguments</B>
<TT>amicable_p</TT> requires two arguments.
The first argument <I>n</I> must be a positive integer.
The second argument <I>m</I> must be a positive integer.</P><P><B>Examples</B></P><P>The first few amicable pairs. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) map(lambda([x],amicable_p(first(x),second(x))), [[220, 284], 
        [1184, 1210], [2620, 2924], [5020, 5564], [6232, 6368]]);
(%o1) [true,true,true,true,true]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: catalan_number-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc91">10.5</A>  Function: catalan_number<A NAME="sec:catalan_number"></A></H3><!--SEC END --><P>
<A NAME="catalan_number"></A>
<B>catalan_number</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the <I>n</I>th catalan number. </P><P><B>Arguments</B>
<TT>catalan_number</TT> requires one argument.</P><P><B>Examples</B></P><P>The catalan number for n from 1 through 12. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) map(catalan_number,lrange(12));
(%o1) [1,2,5,14,42,132,429,1430,4862,16796,58786,208012]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>The n’th catalan number. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) catalan_number(n);
(%o1) binomial(2*n,n)/(n+1)
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>OEIS number: A000108.</P><!--TOC subsection Function: divisor_function-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc92">10.6</A>  Function: divisor_function<A NAME="sec:divisor_function"></A></H3><!--SEC END --><P>
<A NAME="divisor_function"></A>
<B>divisor_function</B>(<I>n</I> :optional <I>x</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
The divisor function σ<SUB><I>x</I></SUB>(<I>n</I>). If <I>x</I> is omitted it takes the default value 0. Currently, complex values for x are not supported. </P><P><B>Arguments</B>
<TT>divisor_function</TT> requires either one or two arguments.
The first argument <I>n</I> must be a non-negative integer.
The second argument <I>x</I> must be a number.</P><P><B>Attributes</B>
divisor_function has attributes: [match_form]</P><P>OEIS number: A000005 for x=0 and A000203 for x=1.</P><P><B>See also</B>
<A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, <A HREF="#perfect_p"><TT>perfect_p</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><!--TOC subsection Function: divisor_summatory-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc93">10.7</A>  Function: divisor_summatory<A NAME="sec:divisor_summatory"></A></H3><!--SEC END --><P>
<A NAME="divisor_summatory"></A>
<B>divisor_summatory</B>(<I>x</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the divisor summatory function <I>D</I>(<I>x</I>) for <I>x</I>. The divisor function <I>d</I>(<I>n</I>) counts the number of unique divisors of the natural number <I>n</I>. <I>D</I>(<I>x</I>) is the sum of <I>d</I>(<I>n</I>) over <I>n</I> ≤ <I>x</I> </P><P><B>Arguments</B>
<TT>divisor_summatory</TT> requires one argument <I>x</I>, which must be a non-negative number.</P><P><B>Attributes</B>
divisor_summatory has attributes: [match_form]</P><P><B>Examples</B></P><P>D(n) for n from 1 through 12 </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) map(divisor_summatory,lrange(12));
(%o1) [1,3,5,8,10,14,16,20,23,27,29,35]
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>OEIS number: A006218.</P><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#perfect_p"><TT>perfect_p</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><!--TOC subsection Function: from_digits-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">10.8</A>  Function: from_digits<A NAME="sec:from_digits"></A></H3><!--SEC END --><P>
<A NAME="from_digits"></A>
<B>from_digits</B>(<I>digits</I> :optional <I>base</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>from_digits</B>(<I>digits</I>)
returns the integer represented by the decimal digits in the list <I>digits</I>. </LI><LI CLASS="li-itemize"> <B>from_digits</B>(<I>digits</I>, <I>base</I>)
returns the integer represented by the base <I>base</I> digits in the list <I>digits</I>. </LI></UL><P>
<B>Description</B>
<I>base</I> need not be number, but may be, for instance, a symbol. If <I>base</I> is a number it must be an integer between 2 and 36. <I>digits</I> may be a string rather than a list. </P><P><B>Arguments</B>
<TT>from_digits</TT> requires either one or two arguments.
The first argument <I>digits</I> must be a list (lex or aex) or a string.</P><P><B>See also</B>
<A HREF="#integer_digits"><TT>integer_digits</TT></A> and <A HREF="#integer_string"><TT>integer_string</TT></A>.</P><!--TOC subsection Function: integer_digits-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc95">10.9</A>  Function: integer_digits<A NAME="sec:integer_digits"></A></H3><!--SEC END --><P>
<A NAME="integer_digits"></A>
<B>integer_digits</B>(<I>n</I> :optional <I>base</I>, <I>len</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>integer_digits</B>(<I>n</I>)
returns a list of the base 10 digits of <I>n</I>. </LI><LI CLASS="li-itemize"> <B>integer_digits</B>(<I>n</I>, <I>base</I>)
returns a list of the base <I>base</I> digits of <I>n</I>. </LI><LI CLASS="li-itemize"> <B>integer_digits</B>(<I>n</I>, <I>base</I>, <I>len</I>)
returns a list of the base <I>base</I> digits of <I>n</I> padded with 0’s so that the total length of the list is <I>len</I>. </LI></UL><P>
<B>Arguments</B>
<TT>integer_digits</TT> requires between one and three arguments.
The first argument <I>n</I> must be an integer.
The second argument <I>base</I> must be a valid radix (an integer between 2 and 36).
The third argument <I>len</I> must be a non-negative integer.</P><P><B>Options</B>
<TT>integer_digits</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><P><B>See also</B>
<A HREF="#from_digits"><TT>from_digits</TT></A> and <A HREF="#integer_string"><TT>integer_string</TT></A>.</P><P><B>Implementation</B>
gcl is much faster than the others. <CODE>integer_digits(2^(10^6))</CODE>: typical times for lisps: ccl-1.7-r15184M = 65s, sbcl-1.0.52.0.debian = 1.5s, allegro-8.2 = 23s, Mma-3.0 = 5s, gcl-2.6.7 = 0.11s, Mma-8 = 0.04s. The base is limited to 36 only because we call write-to-string. </P><!--TOC subsection Function: integer_string-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc96">10.10</A>  Function: integer_string<A NAME="sec:integer_string"></A></H3><!--SEC END --><P>
<A NAME="integer_string"></A>
<B>integer_string</B>(<I>n</I> :optional <I>base</I>, <I>pad</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>integer_string</B>(<I>n</I>)
returns a string containing the decimal digits of the integer <I>n</I>. </LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, <I>base</I>)
returns a string containing the base <I>base</I> digits of the integer <I>n</I>. </LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, <I>base</I>, <I>pad</I>)
pads the string on the left with 0’s so that the length of the string is <I>pad</I>. </LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, "roman" )
returns a string containing the roman-numeral form of the integer <I>n</I>. </LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, "cardinal" )
returns a string containing the english word form of the integer (cardinal number) <I>n</I>. </LI><LI CLASS="li-itemize"> <B>integer_string</B>(<I>n</I>, "ordinal" )
returns a string containing the english word form of the ordinal (counting) number <I>n</I>. </LI></UL><P>
<B>Arguments</B>
<TT>integer_string</TT> requires between one and three arguments.
The first argument <I>n</I> must be an integer.
The second argument <I>base</I> must be a valid radix (an integer between 2 and 36) or a string.
The third argument <I>pad</I> must be a positive integer.</P><P><B>See also</B>
<A HREF="#integer_digits"><TT>integer_digits</TT></A> and <A HREF="#from_digits"><TT>from_digits</TT></A>.</P><!--TOC subsection Function: oeis_A092143-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc97">10.11</A>  Function: oeis_A092143<A NAME="sec:oeis_A092143"></A></H3><!--SEC END --><P>
<A NAME="oeis_A092143"></A>
<B>oeis_A092143</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns the cumulative product of all divisors of integers from 1 to <I>n</I>. </P><P><B>Arguments</B>
<TT>oeis_A092143</TT> requires one argument <I>n</I>, which must be a positive integer.</P><!--TOC subsection Function: perfect_p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc98">10.12</A>  Function: perfect_p<A NAME="sec:perfect_p"></A></H3><!--SEC END --><P>
<A NAME="perfect_p"></A>
<B>perfect_p</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
Returns true if <I>n</I> is a perfect number. Otherwise, returns false. </P><P><B>Arguments</B>
<TT>perfect_p</TT> requires one argument <I>n</I>, which must be a positive integer.</P><P><B>See also</B>
<A HREF="#divisor_function"><TT>divisor_function</TT></A>, <A HREF="#aliquot_sum"><TT>aliquot_sum</TT></A>, <A HREF="#aliquot_sequence"><TT>aliquot_sequence</TT></A>, <A HREF="#divisor_summatory"><TT>divisor_summatory</TT></A>, and <A HREF="#abundant_p"><TT>abundant_p</TT></A>.</P><P><B>Implementation</B>
This function computes divisors. It would be far more efficient to use a table of known perfect numbers, as there are very few of them. </P><!--TOC subsection Function: prime_pi-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc99">10.13</A>  Function: prime_pi<A NAME="sec:prime_pi"></A></H3><!--SEC END --><P>
<A NAME="prime_pi"></A>
<B>prime_pi</B>(<I>n</I>)</P><P>mext package: prime_pi</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>prime_pi</B>(<I>n</I>)
returns the number of primes less than or equal to <I>n</I>. </LI></UL><P>
<B>Description</B>
Computes the prime counting function. The option <I>threads</I> specifies the maximum number of cpu threads to use. The routine may use fewer threads, depending on the value of <I>n</I>. The percent of the calculation that is finished is printed during the calculation if the option <I>status</I> is 
true. The status will only work under some terminals. </P><P><B>Arguments</B>
<TT>prime_pi</TT> requires one argument <I>n</I>, which must be equivalent to an unsigned 64 bit integer
(ie an integer between 0 and 2 to the power 64)
(We need to modify the doc system so we can use notation for powers in arg check strings.
.</P><P><B>Options</B>
<TT>prime_pi</TT> takes options with default values: <TT>status-&gt;false</TT>, <TT>threads-&gt;1</TT>.
</P><P><B>See also</B>
<A HREF="#prime_pi_soe"><TT>prime_pi_soe</TT></A>, <A HREF="#next_prime"><TT>next_prime</TT></A>, and <A HREF="#prev_prime"><TT>prev_prime</TT></A>.</P><P><B>Implementation</B>
This algorithm is fast for a general purpose mathematics program. It combines a segmented sieve implemented as a C library with tables. </P><P><B>Authors</B>
Kim Walisch (C library), Tomas Oliveira e Silva (tables), and John Lapeyre (lisp).</P><!--TOC subsection Function: prime_pi_soe-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc100">10.14</A>  Function: prime_pi_soe<A NAME="sec:prime_pi_soe"></A></H3><!--SEC END --><P>
<A NAME="prime_pi_soe"></A>
<B>prime_pi_soe</B>(<I>n</I>)</P><P>mext package: discrete_aex</P><P>
<B>Description</B>
The prime counting function. The algorithm is the sieve of Eratosthenes. Internally an array of <I>n</I> bits is used. </P><P><B>Arguments</B>
<TT>prime_pi_soe</TT> requires one argument <I>n</I>, which must be a non-negative integer.</P><P><B>See also</B>
<A HREF="#prime_pi"><TT>prime_pi</TT></A>, <A HREF="#next_prime"><TT>next_prime</TT></A>, and <A HREF="#prev_prime"><TT>prev_prime</TT></A>.</P><P><B>Implementation</B>
This is not the most efficient way to compute primes. </P><!--TOC subsection Function: prime_twins-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc101">10.15</A>  Function: prime_twins<A NAME="sec:prime_twins"></A></H3><!--SEC END --><P>
<A NAME="prime_twins"></A>
<B>prime_twins</B>(<I>min</I> :optional <I>max</I>)</P><P>mext package: prime_pi</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>prime_twins</B>(<I>n</I>)
returns the number of prime twins less than or equal to <I>n</I>. </LI><LI CLASS="li-itemize"> <B>prime_twins</B>(<I>nmin</I>, <I>nmax</I>)
returns the number of prime twins between <I>nmin</I> and <I>max</I>. </LI></UL><P>
<B>Description</B>
The option <I>ktuplet</I> counts the <I>ktuplet</I>-constellation rather than the twins. <I>ktuplet</I> must be an integer between 1 and 7. </P><P><B>Arguments</B>
<TT>prime_twins</TT> requires either one or two arguments.
The first argument <I>min</I> must be equivalent to an unsigned 64 bit integer
(ie an integer between 0 and 2 to the power 64)
(We need to modify the doc system so we can use notation for powers in arg check strings.
.
The second argument <I>max</I> must be equivalent to an unsigned 64 bit integer
(ie an integer between 0 and 2 to the power 64)
(We need to modify the doc system so we can use notation for powers in arg check strings.
.</P><P><B>Options</B>
<TT>prime_twins</TT> takes options with default values: <TT>ktuplet-&gt;2</TT>, <TT>status-&gt;false</TT>, <TT>threads-&gt;1</TT>.
</P><P><B>See also</B>
<A HREF="#prime_pi"><TT>prime_pi</TT></A>, <A HREF="#next_prime"><TT>next_prime</TT></A>, <A HREF="#prev_prime"><TT>prev_prime</TT></A>, and <A HREF="#primep"><TT>primep</TT></A>.</P><P><B>Implementation</B>
No tables are used in this algorithm. </P><!--TOC subsection Function: primes1-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc102">10.16</A>  Function: primes1<A NAME="sec:primes1"></A></H3><!--SEC END --><P>
<A NAME="primes1"></A>
<B>primes1</B>(<I>n1</I> :optional <I>n2</I>)</P><P>mext package: discrete_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>primes1</B>(<I>max</I>)
returns a list of the primes less than or equal to <I>max</I>. </LI><LI CLASS="li-itemize"> <B>primes1</B>(<I>min</I>, <I>max</I>)
returns a list of the primes between <I>min</I> and <I>max</I>. </LI></UL><P>
<B>Description</B>
The algorithm is the sieve of Eratosthenes. This is not an efficient algorithm. </P><P><B>Arguments</B>
<TT>primes1</TT> requires either one or two arguments.
The first argument <I>n1</I> must be a non-negative integer.
The second argument <I>n2</I> must be a non-negative integer.</P><P><B>Options</B>
<TT>primes1</TT> takes options with default values: <TT>adj-&gt;true</TT>, <TT>ot-&gt;ml</TT>.
</P><!--TOC section Functions and Variables for Numerics-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc103">11</A>  Functions and Variables for Numerics</H2><!--SEC END --><P>These are mathematical functions— cos,sin,etc. —that accept only
numerical arguments. Tests of loops in untranslated code show that these are much
more efficient than using the standard maxima versions. But, for most applications, the
standard maxima versions are probably ok.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#n_abs"><TT>n_abs</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_acos"><TT>n_acos</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_acosh"><TT>n_acosh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_asin"><TT>n_asin</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_asinh"><TT>n_asinh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_atan"><TT>n_atan</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_atanh"><TT>n_atanh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_cos"><TT>n_cos</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_cosh"><TT>n_cosh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_exp"><TT>n_exp</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_expt"><TT>n_expt</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_log"><TT>n_log</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_sin"><TT>n_sin</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_sinh"><TT>n_sinh</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_sqrt"><TT>n_sqrt</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_tan"><TT>n_tan</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#n_tanh"><TT>n_tanh</TT></A>
</LI></UL><!--TOC subsection Function: n_abs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc104">11.1</A>  Function: n_abs<A NAME="sec:n_abs"></A></H3><!--SEC END --><P>
<A NAME="n_abs"></A></P><P>
<B>Description</B>
n_abs calls the lisp numeric function ?abs. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_abs may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_acos-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc105">11.2</A>  Function: n_acos<A NAME="sec:n_acos"></A></H3><!--SEC END --><P>
<A NAME="n_acos"></A></P><P>
<B>Description</B>
n_acos calls the lisp numeric function ?acos. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_acos may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_acosh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc106">11.3</A>  Function: n_acosh<A NAME="sec:n_acosh"></A></H3><!--SEC END --><P>
<A NAME="n_acosh"></A></P><P>
<B>Description</B>
n_acosh calls the lisp numeric function ?acosh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_acosh may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_asin-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc107">11.4</A>  Function: n_asin<A NAME="sec:n_asin"></A></H3><!--SEC END --><P>
<A NAME="n_asin"></A></P><P>
<B>Description</B>
n_asin calls the lisp numeric function ?asin. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_asin may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_asinh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc108">11.5</A>  Function: n_asinh<A NAME="sec:n_asinh"></A></H3><!--SEC END --><P>
<A NAME="n_asinh"></A></P><P>
<B>Description</B>
n_asinh calls the lisp numeric function ?asinh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_asinh may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_atan-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc109">11.6</A>  Function: n_atan<A NAME="sec:n_atan"></A></H3><!--SEC END --><P>
<A NAME="n_atan"></A></P><P>
<B>Description</B>
n_atan calls the lisp numeric function ?atan. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_atan may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_atanh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc110">11.7</A>  Function: n_atanh<A NAME="sec:n_atanh"></A></H3><!--SEC END --><P>
<A NAME="n_atanh"></A></P><P>
<B>Description</B>
n_atanh calls the lisp numeric function ?atanh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_atanh may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_cos-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc111">11.8</A>  Function: n_cos<A NAME="sec:n_cos"></A></H3><!--SEC END --><P>
<A NAME="n_cos"></A></P><P>
<B>Description</B>
n_cos calls the lisp numeric function ?cos. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_cos may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_cosh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc112">11.9</A>  Function: n_cosh<A NAME="sec:n_cosh"></A></H3><!--SEC END --><P>
<A NAME="n_cosh"></A></P><P>
<B>Description</B>
n_cosh calls the lisp numeric function ?cosh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_cosh may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_exp-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc113">11.10</A>  Function: n_exp<A NAME="sec:n_exp"></A></H3><!--SEC END --><P>
<A NAME="n_exp"></A></P><P>
<B>Description</B>
n_exp calls the lisp numeric function ?exp. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_exp may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_expt-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc114">11.11</A>  Function: n_expt<A NAME="sec:n_expt"></A></H3><!--SEC END --><P>
<A NAME="n_expt"></A></P><P>
<B>Description</B>
n_expt calls the lisp numeric function ?expt. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_expt may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_log-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc115">11.12</A>  Function: n_log<A NAME="sec:n_log"></A></H3><!--SEC END --><P>
<A NAME="n_log"></A></P><P>
<B>Description</B>
n_log calls the lisp numeric function ?log. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_log may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_sin-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc116">11.13</A>  Function: n_sin<A NAME="sec:n_sin"></A></H3><!--SEC END --><P>
<A NAME="n_sin"></A></P><P>
<B>Description</B>
n_sin calls the lisp numeric function ?sin. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_sin may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_sinh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc117">11.14</A>  Function: n_sinh<A NAME="sec:n_sinh"></A></H3><!--SEC END --><P>
<A NAME="n_sinh"></A></P><P>
<B>Description</B>
n_sinh calls the lisp numeric function ?sinh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_sinh may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_sqrt-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc118">11.15</A>  Function: n_sqrt<A NAME="sec:n_sqrt"></A></H3><!--SEC END --><P>
<A NAME="n_sqrt"></A></P><P>
<B>Description</B>
n_sqrt calls the lisp numeric function ?sqrt. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_sqrt may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_tan-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc119">11.16</A>  Function: n_tan<A NAME="sec:n_tan"></A></H3><!--SEC END --><P>
<A NAME="n_tan"></A></P><P>
<B>Description</B>
n_tan calls the lisp numeric function ?tan. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_tan may be considerably faster in some code, particularly untranslated code. </P><!--TOC subsection Function: n_tanh-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc120">11.17</A>  Function: n_tanh<A NAME="sec:n_tanh"></A></H3><!--SEC END --><P>
<A NAME="n_tanh"></A></P><P>
<B>Description</B>
n_tanh calls the lisp numeric function ?tanh. This function accepts only float or integer arguments from maxima (lisp complex and rationals, as well.). n_tanh may be considerably faster in some code, particularly untranslated code. </P><!--TOC section Functions and Variables for Predicates-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc121">12</A>  Functions and Variables for Predicates</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#cmplength"><TT>cmplength</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#length0p"><TT>length0p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#length1p"><TT>length1p</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#length_eq"><TT>length_eq</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#type_of"><TT>type_of</TT></A>
</LI></UL><!--TOC subsection Function: cmplength-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc122">12.1</A>  Function: cmplength<A NAME="sec:cmplength"></A></H3><!--SEC END --><P>
<A NAME="cmplength"></A>
<B>cmplength</B>(<I>e</I>, <I>n</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
return the smaller of <I>n</I> and <CODE>length(e)</CODE>. This is useful if <I>e</I> is very large and <I>n</I> is small, so that computing the entire length of <I>e</I> is inefficient. Expression <I>e</I> can be either a list or an array. </P><P><B>Arguments</B>
<TT>cmplength</TT> requires two arguments.
The second argument <I>n</I> must be a non-negative integer.</P><P><B>See also</B>
<A HREF="#length0p"><TT>length0p</TT></A>, <A HREF="#length_eq"><TT>length_eq</TT></A>, and <A HREF="#length1p"><TT>length1p</TT></A>.</P><P><B>Implementation</B>
cmplength is implemented with defmfun1, which slows things down a bit. So be cautious using it in a tight loop. </P><!--TOC subsection Function: length0p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc123">12.2</A>  Function: length0p<A NAME="sec:length0p"></A></H3><!--SEC END --><P>
<A NAME="length0p"></A>
<B>length0p</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Returns true if &lt;e&gt; is of length 0, false otherwise. This implementation traverse no more elements of &lt;e&gt; than necessary to return the result. </P><P><B>Arguments</B>
<TT>length0p</TT> requires one argument <I>e</I>, which must be a string or non-atomic.</P><P><B>See also</B>
<A HREF="#cmplength"><TT>cmplength</TT></A>, <A HREF="#length_eq"><TT>length_eq</TT></A>, and <A HREF="#length1p"><TT>length1p</TT></A>.</P><P><B>Implementation</B>
length0p is implemented with defmfun1, which slows things down a bit. So be cautious using it in a tight loop. </P><!--TOC subsection Function: length1p-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc124">12.3</A>  Function: length1p<A NAME="sec:length1p"></A></H3><!--SEC END --><P>
<A NAME="length1p"></A>
<B>length1p</B>(<I>e</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Returns true if <I>e</I> is of length 1, false otherwise. This implementation traverse no more elements of <I>e</I> than necessary to return the result. </P><P><B>Arguments</B>
<TT>length1p</TT> requires one argument <I>e</I>, which must be a string or non-atomic.</P><P><B>See also</B>
<A HREF="#length0p"><TT>length0p</TT></A>, <A HREF="#cmplength"><TT>cmplength</TT></A>, and <A HREF="#length_eq"><TT>length_eq</TT></A>.</P><P><B>Implementation</B>
length1p is implemented with defmfun1, which slows things down a bit. So be cautious using it in a tight loop. </P><!--TOC subsection Function: length_eq-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc125">12.4</A>  Function: length_eq<A NAME="sec:length_eq"></A></H3><!--SEC END --><P>
<A NAME="length_eq"></A>
<B>length_eq</B>(<I>e</I>, <I>n</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Returns true if <I>e</I> is of length <I>n</I>, false otherwise. This implementation traverses no more elements of <I>e</I> than necessary to return the result. </P><P><B>Arguments</B>
<TT>length_eq</TT> requires two arguments.
The first argument <I>e</I> must be a string or non-atomic.
The second argument <I>n</I> must be a non-negative integer.</P><P><B>See also</B>
<A HREF="#length0p"><TT>length0p</TT></A>, <A HREF="#cmplength"><TT>cmplength</TT></A>, and <A HREF="#length1p"><TT>length1p</TT></A>.</P><P><B>Implementation</B>
length_eq is implemented with defmfun1, which slows things down a bit. So be cautious using it in a tight loop. </P><!--TOC subsection Function: type_of-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc126">12.5</A>  Function: type_of<A NAME="sec:type_of"></A></H3><!--SEC END --><P>
<A NAME="type_of"></A>
<B>type_of</B>(<I>e</I> :optional <I>verbose</I>)</P><P>mext package: aex</P><P>
<B>Description</B>
Return something like the ‘type’ of a maxima expression. This is a bit ill defined currently. <A HREF="#type_of"><TT>type_of</TT></A> uses the lisp function type-of. </P><P><B>Arguments</B>
<TT>type_of</TT> requires either one or two arguments.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) type_of(1);
(%o1) ?bit
(%i1) type_of(1.0);
(%o1) ?double\-float
(%i2) type_of(1.0b0);
(%o2) ?bfloat
(%i3) type_of(1/3);
(%o3) /
(%i4) type_of("dog");
(%o4) ?string
(%i5) type_of([1,2,3]);
(%o5) [
(%i6) type_of(aex([1,2,3]));
(%o6) [
(%i7) type_of(%e);
(%o7) ?symbol
(%i8) type_of(%i);
(%o8) ?symbol
(%i9) type_of(%i+1);
(%o9) +
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P>type_of returns the type of the lisp struct corresponding to a maxima 
object. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) load(graphs)$
(%i2) type_of(new_graph());
(%o2)   graph
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC section Functions and Variables for Program Flow-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc127">13</A>  Functions and Variables for Program Flow</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#error_str"><TT>error_str</TT></A>
</LI></UL><!--TOC subsection Function: error_str-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc128">13.1</A>  Function: error_str<A NAME="sec:error_str"></A></H3><!--SEC END --><P>
<A NAME="error_str"></A>
<B>error_str</B>()</P><P>mext package: aex</P><P>
<B>Description</B>
Returns the last error message as a string. </P><P><B>Arguments</B>
<TT>error_str</TT> requires zero arguments.</P><P><B>See also</B>
<A HREF="#error"><TT>error</TT></A> and <A HREF="#errormsg"><TT>errormsg</TT></A>.</P><!--TOC section Functions and Variables for Quicklisp-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc129">14</A>  Functions and Variables for Quicklisp</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#quicklisp_apropos"><TT>quicklisp_apropos</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#quicklisp_install"><TT>quicklisp_install</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#quicklisp_load"><TT>quicklisp_load</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#quicklisp_start"><TT>quicklisp_start</TT></A>
</LI></UL><!--TOC subsection Function: quicklisp_apropos-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc130">14.1</A>  Function: quicklisp_apropos<A NAME="sec:quicklisp_apropos"></A></H3><!--SEC END --><P>
<A NAME="quicklisp_apropos"></A>
<B>quicklisp_apropos</B>(<I>term</I>)</P><P>mext package: quicklisp</P><P>
<B>Description</B>
Search quicklisp for lisp ’systems’ (packages) matching <I>term</I>. </P><P><B>Arguments</B>
<TT>quicklisp_apropos</TT> requires one argument <I>term</I>, which must be a string.</P><!--TOC subsection Function: quicklisp_install-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc131">14.2</A>  Function: quicklisp_install<A NAME="sec:quicklisp_install"></A></H3><!--SEC END --><P>
<A NAME="quicklisp_install"></A>
<B>quicklisp_install</B>()</P><P>mext package: quicklisp</P><P>
<B>Description</B>
Download and install quicklisp from the internet. This is usually done automatically as the final step of building and installing the maxima interface to quicklisp. </P><P><B>Arguments</B>
<TT>quicklisp_install</TT> requires zero arguments.</P><!--TOC subsection Function: quicklisp_load-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc132">14.3</A>  Function: quicklisp_load<A NAME="sec:quicklisp_load"></A></H3><!--SEC END --><P>
<A NAME="quicklisp_load"></A>
<B>quicklisp_load</B>(<I>package_name</I>)</P><P>mext package: quicklisp</P><P>
<B>Description</B>
Load the asdf lisp package <I>package_name</I>, or, if not installed, install from the internet and then load. </P><P><B>Arguments</B>
<TT>quicklisp_load</TT> requires one argument <I>package_name</I>, which must be a string.</P><!--TOC subsection Function: quicklisp_start-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc133">14.4</A>  Function: quicklisp_start<A NAME="sec:quicklisp_start"></A></H3><!--SEC END --><P>
<A NAME="quicklisp_start"></A>
<B>quicklisp_start</B>()</P><P>mext package: quicklisp</P><P>
<B>Description</B>
Load (setup) quicklisp. It must already be installed. </P><P><B>Arguments</B>
<TT>quicklisp_start</TT> requires zero arguments.</P><!--TOC section Functions and Variables for Runtime Environment-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc134">15</A>  Functions and Variables for Runtime Environment</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#chdir"><TT>chdir</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#dir_exists"><TT>dir_exists</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#dirstack"><TT>dirstack</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#dont_kill"><TT>dont_kill</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#dont_kill_share"><TT>dont_kill_share</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#get_dont_kill"><TT>get_dont_kill</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_clear"><TT>mext_clear</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_info"><TT>mext_info</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_list"><TT>mext_list</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#mext_test"><TT>mext_test</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#popdir"><TT>popdir</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#probe_file"><TT>probe_file</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#pwd"><TT>pwd</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#require"><TT>require</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#truename"><TT>truename</TT></A>
</LI></UL><!--TOC subsection Function: chdir-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc135">15.1</A>  Function: chdir<A NAME="sec:chdir"></A></H3><!--SEC END --><P>
<A NAME="chdir"></A>
<B>chdir</B>( :optional <I>dir</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>chdir</B>()
Set the working directory to the value it had when mext was loaded. </LI><LI CLASS="li-itemize"> <B>chdir</B>(<I>dir</I>)
Set the working directory to <I>dir</I>. </LI></UL><P>
<B>Description</B>
Set the working directory for maxima/lisp. With some lisps, such as cmu lisp the system directory is changed as well. This should be made uniform across lisp implementations. </P><P><B>Arguments</B>
<TT>chdir</TT> requires either zero or one arguments.
<I>dir</I>, which must be a string.</P><!--TOC subsection Function: dir_exists-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc136">15.2</A>  Function: dir_exists<A NAME="sec:dir_exists"></A></H3><!--SEC END --><P>
<A NAME="dir_exists"></A>
<B>dir_exists</B>(<I>dir</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Returns the pathname as a string if <I>dir</I> exists, and <CODE>false</CODE> otherwise. </P><P><B>Arguments</B>
<TT>dir_exists</TT> requires one argument <I>dir</I>, which must be a string.</P><!--TOC subsection Function: dirstack-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc137">15.3</A>  Function: dirstack<A NAME="sec:dirstack"></A></H3><!--SEC END --><P>
<A NAME="dirstack"></A>
<B>dirstack</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Return a list of the directories on the directory stack. This list is manipulated with <A HREF="#chdir"><TT>chdir</TT></A>, <A HREF="#updir"><TT>updir</TT></A>, and <A HREF="#popdir"><TT>popdir</TT></A>. </P><P><B>Arguments</B>
<TT>dirstack</TT> requires zero arguments.</P><!--TOC subsection Function: dont_kill-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc138">15.4</A>  Function: dont_kill<A NAME="sec:dont_kill"></A></H3><!--SEC END --><P>
<A NAME="dont_kill"></A>
<B>dont_kill</B>( :rest <I>item</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Add the <I>items</I>s to the list of symbols that are not killed by <CODE>kill(all)</CODE>. This facility is part of the maxima core, but is apparantly unused. Maybe putting a property in the symbol’s property list would be better. </P><P><B>Arguments</B>
<TT>dont_kill</TT> requires zero or more arguments.</P><P><B>Attributes</B>
dont_kill has attributes: [hold_all]</P><!--TOC subsection Function: dont_kill_share-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc139">15.5</A>  Function: dont_kill_share<A NAME="sec:dont_kill_share"></A></H3><!--SEC END --><P>
<A NAME="dont_kill_share"></A>
<B>dont_kill_share</B>(<I>package</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Prevent symbols in maxima share package <I>package</I> from being killed by <TT>kill</TT>. </P><P><B>Arguments</B>
<TT>dont_kill_share</TT> requires one argument <I>package</I>, which must be a string or a symbol.</P><!--TOC subsection Function: get_dont_kill-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc140">15.6</A>  Function: get_dont_kill<A NAME="sec:get_dont_kill"></A></H3><!--SEC END --><P>
<A NAME="get_dont_kill"></A>
<B>get_dont_kill</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Returns the list of symbols that are not killed by <CODE>kill(all)</CODE>. Items are added to this list with <A HREF="#dont_kill"><TT>dont_kill</TT></A>. </P><P><B>Arguments</B>
<TT>get_dont_kill</TT> requires zero arguments.</P><!--TOC subsection Function: mext_clear-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc141">15.7</A>  Function: mext_clear<A NAME="sec:mext_clear"></A></H3><!--SEC END --><P>
<A NAME="mext_clear"></A>
<B>mext_clear</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Clears the list of mext packages that have been loaded with require. Subsequent calls to require will reload the packages. </P><P><B>Arguments</B>
<TT>mext_clear</TT> requires zero arguments.</P><!--TOC subsection Function: mext_info-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc142">15.8</A>  Function: mext_info<A NAME="sec:mext_info"></A></H3><!--SEC END --><P>
<A NAME="mext_info"></A>
<B>mext_info</B>(<I>distname</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Print information about installed mext distribution <I>distname</I>. The list of installed distributions is built by calling <A HREF="#mext_list"><TT>mext_list</TT></A>. </P><P><B>Arguments</B>
<TT>mext_info</TT> requires one argument <I>distname</I>, which must be a string or a symbol.</P><!--TOC subsection Function: mext_list-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc143">15.9</A>  Function: mext_list<A NAME="sec:mext_list"></A></H3><!--SEC END --><P>
<A NAME="mext_list"></A>
<B>mext_list</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Returns a list of all installed mext distributions. </P><P><B>Arguments</B>
<TT>mext_list</TT> requires zero arguments.</P><!--TOC subsection Function: mext_test-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc144">15.10</A>  Function: mext_test<A NAME="sec:mext_test"></A></H3><!--SEC END --><P>
<A NAME="mext_test"></A>
<B>mext_test</B>( :optional <I>dists</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Run the test suites for a mext distribution or list of distributions. With no argument, a subfolder named <CODE>rtests</CODE> is searched for in the current directory. </P><P><B>Arguments</B>
<TT>mext_test</TT> requires either zero or one arguments.
<I>dists</I>, which must be a string, a symbol, or a list of strings or symbols.</P><!--TOC subsection Function: popdir-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc145">15.11</A>  Function: popdir<A NAME="sec:popdir"></A></H3><!--SEC END --><P>
<A NAME="popdir"></A>
<B>popdir</B>( :optional <I>n</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Pop a value from the current directory stack and chdir to this value. If <I>n</I> is given, pop <I>n</I> values and chdir to the last value popped. </P><P><B>Arguments</B>
<TT>popdir</TT> requires either zero or one arguments.
<I>n</I>, which must be a non-negative integer.</P><!--TOC subsection Function: probe_file-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc146">15.12</A>  Function: probe_file<A NAME="sec:probe_file"></A></H3><!--SEC END --><P>
<A NAME="probe_file"></A></P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>probe_file</B>(<I>filespec</I>)
returns a string representing a canonical pathname to the file specified by <I>filespec</I>. False is returned if the file can’t be found. </LI></UL><P>
<B>Description</B>
Probe_File tries to find a canonical pathname for a filespecified by the string <I>filespec</I>. </P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) probe_file("a/b.txt");
(%o1) "/home/username/c/a/b.txt"
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: pwd-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc147">15.13</A>  Function: pwd<A NAME="sec:pwd"></A></H3><!--SEC END --><P>
<A NAME="pwd"></A>
<B>pwd</B>()</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Return the current working directory. </P><P><B>Arguments</B>
<TT>pwd</TT> requires zero arguments.</P><!--TOC subsection Function: require-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc148">15.14</A>  Function: require<A NAME="sec:require"></A></H3><!--SEC END --><P>
<A NAME="require"></A>
<B>require</B>(<I>distname</I> :optional <I>force</I>)</P><P>mext package: mext_defmfun1</P><P>
<B>Description</B>
Load the mext pacakge <I>distname</I> and register that it has been loaded. <CODE>require('all)</CODE> will load all installed mext packages. If <I>force</I> is true, then <I>distname</I> is loaded even if it has been loaded previously. </P><P><B>Arguments</B>
<TT>require</TT> requires either one or two arguments.
The first argument <I>distname</I> must be a string or a symbol.</P><!--TOC subsection Function: truename-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc149">15.15</A>  Function: truename<A NAME="sec:truename"></A></H3><!--SEC END --><P>
<A NAME="truename"></A></P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>truename</B>(<I>filespec</I>)
returns a string representing a canonical pathname to the file specified by <I>filespec</I> </LI></UL><P>
<B>Description</B>
Truename tries to find a canonical pathanme for a file specified by the string <I>filespec</I>. </P><!--TOC section Functions and Variables for Strings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc150">16</A>  Functions and Variables for Strings</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#string_drop"><TT>string_drop</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#string_reverse"><TT>string_reverse</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#string_take"><TT>string_take</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#with_output_to_string"><TT>with_output_to_string</TT></A>
</LI></UL><!--TOC subsection Function: string_drop-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc151">16.1</A>  Function: string_drop<A NAME="sec:string_drop"></A></H3><!--SEC END --><P>
<A NAME="string_drop"></A>
<B>string_drop</B>(<I>s</I>, <I>spec</I>)</P><P>mext package: lists_aex</P><P>
<B>Arguments</B>
<TT>string_drop</TT> requires two arguments.
The first argument <I>s</I> must be a string.
The second argument <I>spec</I> must be a sequence specification.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1)  string_drop("abracadabra",1);
(%o1) bracadabra
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1)  string_drop("abracadabra",-1);
(%o1) abracadabr
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1)  string_drop("abracadabra",[2,10]);
(%o1) aa
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: string_reverse-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc152">16.2</A>  Function: string_reverse<A NAME="sec:string_reverse"></A></H3><!--SEC END --><P>
<A NAME="string_reverse"></A>
<B>string_reverse</B>(<I>s</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>string_reverse</B>(<I>s</I>)
returns a copy of string <I>s</I> with the characters in reverse order. </LI></UL><P>
<B>Arguments</B>
<TT>string_reverse</TT> requires one argument <I>s</I>, which must be a string.</P><!--TOC subsection Function: string_take-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc153">16.3</A>  Function: string_take<A NAME="sec:string_take"></A></H3><!--SEC END --><P>
<A NAME="string_take"></A>
<B>string_take</B>(<I>s</I>, <I>spec</I>)</P><P>mext package: lists_aex</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>string_take</B>(<I>s</I>, <I>n</I>)
returns a string of the first <I>n</I> characters of the string <I>s</I>. </LI><LI CLASS="li-itemize"> <B>string_take</B>(<I>s</I>, -n )
returns a string of the last <I>n</I> characters of <I>s</I>. </LI></UL><P>
<B>Arguments</B>
<TT>string_take</TT> requires two arguments.
The first argument <I>s</I> must be a string.
The second argument <I>spec</I> must be a sequence specification.</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) string_take("dog-goat-pig-zebra",[5,12]);
(%o1) goat-pig
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC subsection Function: with_output_to_string-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc154">16.4</A>  Function: with_output_to_string<A NAME="sec:with_output_to_string"></A></H3><!--SEC END --><P>
<A NAME="with_output_to_string"></A></P><P>
<B>Description</B>
Evaluates <I>expr_1</I>,<I>expr_2</I>,<I>expr_3</I>,…</P><P><B>Examples</B></P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) sreverse(with_output_to_string(for i:5 thru 10 do print("i! for i=",i,i!)));
(%o1) 
 0088263 01 =i rof !i
 088263 9 =i rof !i
 02304 8 =i rof !i
 0405 7 =i rof !i
 027 6 =i rof !i
 021 5 =i rof !i
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><P><B>See also</B>
<A HREF="#with_stdout"><TT>with_stdout</TT></A>.</P><!--TOC section Miscellaneous Functions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc155">17</A>  Miscellaneous Functions</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#examples"><TT>examples</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#examples_add"><TT>examples_add</TT></A>
</LI></UL><!--TOC subsection Function: examples-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc156">17.1</A>  Function: examples<A NAME="sec:examples"></A></H3><!--SEC END --><P>
<A NAME="examples"></A>
<B>examples</B>(<I>item</I>)</P><P>mext package: defmfun1</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>examples</B>(<I>item</I>)
Print examples for the topic <I>item</I>. Note these examples are different from those extracted from the maxima manual with the command <CODE>example</CODE>. </LI></UL><P>
<B>Arguments</B>
<TT>examples</TT> requires one argument <I>item</I>, which must be a string or a symbol.</P><!--TOC subsection Function: examples_add-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc157">17.2</A>  Function: examples_add<A NAME="sec:examples_add"></A></H3><!--SEC END --><P>
<A NAME="examples_add"></A>
<B>examples_add</B>(<I>item</I>, <I>text</I>, <I>protected-var-list</I>, <I>code</I>)</P><P>mext package: defmfun1</P><P>
<B>Calling</B>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
 <B>examples_add</B>(<I>item</I>, <I>text</I>, <I>protected-var-list</I>, <I>code</I>)
Add an example for item <I>item</I>. <I>text</I> will be printed before the example is displayed. <I>protected-var-list</I> is string giving a list of variables such as "[x,y]" that appear in the example code. The example code will be wrapped in a block that makes <I>protected-var-list</I> local. <I>code</I> may be a string or list of strings that is/are the example code. </LI></UL><P>
<B>Arguments</B>
<TT>examples_add</TT> requires four arguments.
The first argument <I>item</I> must be a string or a symbol.
The second argument <I>text</I> must be a string.
The third argument <I>protected-var-list</I> must be a string.
The fourth argument <I>code</I> must be a string or a list of strings.</P><P><B>Examples</B></P><P>Add an example for the function ’last’. </P><TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><TABLE BORDER=0 CELLPADDING=0
CELLSPACING=0><TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD><TD><TABLE BORDER=0 CELLPADDING="1" CELLSPACING=0><TR><TD><PRE CLASS="verbatim">(%i1) examples_add("last", "Return the last item in a  list.", "[a,b,c,d]", "last([a,b,c,d])") ;
(%o1) done
</PRE></TD></TR>
</TABLE></TD><TD BGCOLOR=black COLSPAN="1"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
<TR><TD BGCOLOR=black COLSPAN="3"><TABLE CELLSPACING="2" CELLPADDING=0 BORDER=0><TR><TD>
</TD></TR>
</TABLE></TD></TR>
</TABLE></TD></TR>
</TABLE><!--TOC section Miscellaneous utilities-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc158">18</A>  Miscellaneous utilities</H2><!--SEC END --><!--TOC section Options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc159">19</A>  Options</H2><!--SEC END --><P>Options to a function in the aex-maxima distribution are passed as follows:</P><P>funcname(x,y, [optname -&gt; optval, optname2 -&gt; optval2])
or
funcname(x,y, optname -&gt; optval, optname2 -&gt; optval2)</P><P>The standard options described in this section are some options that are supported by
many functions in the aex-maxima distribution.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="#adj"><TT>adj</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#compile"><TT>compile</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#foptions"><TT>foptions</TT></A>
</LI><LI CLASS="li-itemize"><A HREF="#ot"><TT>ot</TT></A>
</LI></UL><!--TOC subsection Option: adj-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc160">19.1</A>  Option: adj<A NAME="sec:adj"></A></H3><!--SEC END --><P>
<A NAME="adj"></A></P><P>
<B>Description</B>
This option takes values of <CODE>true</CODE> or <CODE> false. If </CODE><CODE>true</CODE>, then the output aex expression is adjustable, that is, the underlying array can be extended in size. If <CODE>false</CODE>, then the output aex expression is not adjustable. The non-adjustable array may have some advantanges in 
efficiency, but I have not observed them, and this may be lisp-implementation dependent. </P><!--TOC subsection Option: compile-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc161">19.2</A>  Option: compile<A NAME="sec:compile"></A></H3><!--SEC END --><P>
<A NAME="compile"></A></P><P>
<B>Description</B>
If this option is true, then lambda functions passed as arguments to a function will be automatically translated or compiled. If it is false they will used as interpreted maxima code. Compiling lambda functions usually greatly deceases the execution time of the function if the lambda function is 
called many times. </P><!--TOC subsection Function: foptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc162">19.3</A>  Function: foptions<A NAME="sec:foptions"></A></H3><!--SEC END --><P>
<A NAME="foptions"></A>
<B>foptions</B>(<I>name</I>)</P><P>
<B>Description</B>
Return a list of allowed options to <CODE>defmfun1</CODE> function <I>name</I>. I would prefer to call this <CODE>options</CODE>, but that name is taken by an unused, undocumented function. </P><P><B>Arguments</B>
<TT>foptions</TT> requires one argument <I>name</I>, which must be a string or a symbol.</P><!--TOC subsection Option: ot-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc163">19.4</A>  Option: ot<A NAME="sec:ot"></A></H3><!--SEC END --><P>
<A NAME="ot"></A></P><P>
<B>Description</B>
With a value <CODE>ar</CODE> this option causes the function to return an array-representation expression. With a value <CODE>ml</CODE> a standard lisp list representation is returned. The array-representation is not a maxima array, but rather a more-or-less arbitrary maxima expression that is stored 
internally as an array. For certain operations, such as random access to elements of the expression, an array representation is faster than the standard list representation. One disadvantange of the array representations is that creating an array is relatively slow. For instance, execution time may 
be large if a function returns an expression with many small subexpressions that are in the array-representation. The majority of the maxima system does not understand array-representation, so conversion back to list-representation at may be necessary. </P><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
