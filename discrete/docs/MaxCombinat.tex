%%%
%%% za primere: set_display(none)$ linel:60$.
%%%

\documentclass[11pt]{article}

\usepackage[a4paper]{geometry}
\usepackage{graphicx}
\usepackage{fancyvrb}

\usepackage{hyperref}

\usepackage{mathpazo}
\linespread{1.05}

\usepackage{tikz}
\usetikzlibrary{decorations.pathmorphing}
\tikzstyle{every node}=[fill=white,draw=black,shape=circle,inner sep=1mm]

\newcommand{\command}[1]{\texttt{#1}}
\newcommand{\maxima}{\textsc{Maxima}}
\newcommand{\species}[1]{\mathcal{#1}}
\newcommand{\DEF}[1]{{\em #1}}
\newcommand{\LINK}[1]{\href{#1}{#1}}

\newtheorem{theorem}{Theorem}

\DefineVerbatimEnvironment{example}{Verbatim}{%
	frame=leftline,%
	rulecolor=\color{gray},%
	framerule=2pt,%
	framesep=3mm}

\begin{document}

\title{Counting with generating functions in \maxima}
\author{Andrej Vodopivec\\ \texttt{andrej.vodopivec@gmail.com}}
\date{}
\maketitle

\abstract{An implementation of packages for P\'olya theory and
combinatorial species for the computer algebra system
\maxima\ is presented.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

A large part of combinatorics is concerned with counting. Many
counting problems can be efficiently solved by using generating
functions. In this paper we describe implementations of two counting
methods which are based on generating functions for the computer
algebra system \maxima\cite{Max}.

P\'olya theory \cite{P} is an important counting method when some
objects that are being counted have to be considered equal because of
symmetry. The package \command{discrete} provides basic functionality
for working with permutation groups and applications of P\'olya's
theorems. The package also adds some extensions to the maxima
\command{graphs} package and defines functions for other topics in
discrete mathematics, but this functionality will not be described in
this paper.

The package \command{Species} implements methods for working with
combinatorial spe\-cies \cite{J,BLL}. The theory of combinatorial
species can be applied when we are counting objects which are built
from smaller objects using some production rules. The most well known
package for combinatorial species is the \command{combstruct} package
for Maple. Open--source implementations include MuPAD-Combinat
\cite{MCS}, \cite{MC}, Aldor-Combinat \cite{AC} and the species
package of Sage \cite{sage}. The package \command{Species} described
in this paper currently only implements unlabelled species only and
provides functions for counting, listing and random generation of
combinatorial species.

The paper is divided into two parts. The first describes P\'olya
theory and the second combinatorial species. Both parts start with
short theoretical background and then expose the packages with worked
examples in \maxima. The packages require \maxima\ version 5.22 or
above.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{P\'olya theory}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Permutation groups}

The package \command{discrete} provides several functions for working
with permutations. Some basic group theory functions are also
present. The purpose is applications in P\'olya theory.

The function \command{permutation\_product} computes a product of
permutations. By default the product is from left to right.  The order
can be specified with the option variable
\command{permutation\_multiplication} (valid values are
\command{left\_to\_right} and \command{right\_to\_left}. A permutation
power can be efficiently computed with the function
\command{permutation\_power}.

The function \command{permutation\_to\_cycles} transforms a
permutation to the product of disjoint cycles. The reverse can be done
with \command{permutation\_from\_cycles}. There are similar functions
for converting a permutation to a product of transpositions and back.

\begin{example}
(%i1) load(discrete)$
(%i2) a: random_permutation([1,2,3,4,5,6,7,8]);
(%o2) [2,5,8,3,7,4,1,6]
(%i3) permutation_to_cycles(%);
(%o3) [[1,2,5,7],[3,8,6,4]]
(%i4) permutation_from_cycles([[1,2,3,4], [5,6]], 10);
(%o4) [2,3,4,1,6,5,7,8,9,10]
(%i5) permutation_power(a, 10);
(%o5) [5,7,6,8,1,3,2,4]
\end{example}
%
A permutation group is represented as a set of permutation. It can be
generated from a set of generators with the function
\command{group\_from\_generators} (some functions accept a set of
generators instead of the whole group and an optional argument
\command{generators=true}).

\begin{example}
(%i6) group_from_generators({[2,3,4,5,1], [1,5,4,3,2]});
(%o6) {[1,2,3,4,5],[1,5,4,3,2],[2,1,5,4,3],[2,3,4,5,1],
       [3,2,1,5,4],[3,4,5,1,2],[4,3,2,1,5],[4,5,1,2,3],
       [5,1,2,3,4],[5,4,3,2,1]}
\end{example}
%
An important class of problems deal with groups of automorphisms of
graphs. The package \command{discrete} provides a function
\command{graph\_automorphisms} which can generate the group of
automorphisms of the graph or only the generators of the group.
%
\begin{example}
(%i7) g:grid_graph(3,7)$
(%i8) graph_automorphisms(g);
(%o8) {[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21],
       [3,2,1,6,5,4,9,8,7,12,11,10,15,14,13,18,17,16,21,20,19],
       [19,20,21,16,17,18,13,14,15,10,11,12,7,8,9,4,5,6,1,2,3],
       [21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]}
\end{example}
%
For larger graphs an external program called \command{bliss}
\cite{bliss} can be used to find the automorphisms.  The
\command{bliss} program must be installed separately and the path to
the program must be specified in the variable
\command{bliss\_program}.
%
\begin{example}
(%i9) bt4: binary_tree(4)$
(%i10) gens: graph_automorphisms(bt4,program=bliss,generators=true)$
(%i11) group_order(gens);
(%o11) 32768
(%i12) group_orbits(gens, generators=true);
(%o12) {{1,2,4,5,8,9,11,12,16,17,19,20,23,24,26,27},
        {3,6,10,13,18,21,25,28},{7,14,22,29},{15,30},{31}}
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{P\'olya theory}

A \DEF{cycle index} of a permutation $\pi$ is the monomial $Z(\pi;
x_1, \ldots, x_k)=x_1^{n_1}x_2^{n_2}\cdots x_k^{n_k}$ where $n_i$ is
the number of cycles of length $i$ in the representation of $\pi$ as
the product of disjoint cycles.

\begin{example}
(%i1) load(discrete)$
(%i2) pi: random_permutation(int_range(10));
(%o2) [4,9,8,3,5,10,7,1,2,6]
(%i3) permutation_to_cycles(pi);
(%o3) [[1,4,3,8],[2,9],[6,10]]
(%i4) cycle_index_permutation(pi);
(%o4) x[1]^2*x[2]^2*x[4]
\end{example} 
%
The cycle index of a permutation group $G$ is the average of cycle
indexes of permutations in $G$:
$$
Z(G;x_1,\ldots,x_k) = \frac{1}{|G|}\sum_{\pi\in G}Z(\pi; x_1,\ldots,x_k).
$$
There are many functions to compute the cycle index of groups.
\begin{example}
(%i5) s4: symmetric_group(4)$
(%i6) cycle_index_group(s4);
(%o6) (6*x[4]+8*x[1]*x[3]+3*x[2]^2+6*x[1]^2*x[2]+x[1]^4)/24
(%i7) cycle_index_symmetric(4);
(%o7) (6*x[4]+8*x[1]*x[3]+3*x[2]^2+6*x[1]^2*x[2]+x[1]^4)/24
(%i8) cycle_index_dihedral(7);
(%o8) (6*x[7]+x[1]^7)/14+(x[1]*x[2]^3)/2
\end{example}
%
Let $X$ and $Y$ be finite sets and $\mathcal{F}=\{f:X\to Y\}$ the set
of mappings from $X$ to $Y$. Let $G$ be a group acting on $X$. We
define an equivalence relation $\sim_G$ on $\mathcal{F}$ as
$$
f_1 \sim_G f_2 \quad \Longleftrightarrow \quad
\mbox{$\exists g\in G\ \forall x\in X: \ f_1(x)=f_2(x^g)$.}
$$
We say that $f_1$ and $f_2$ differ by the symmetry $g$. We are
interested in the number of equivalence classes of the relation
$\sim_G$. The equivalence classes are called \DEF{patterns}.

\begin{theorem}
\label{thm:polya1}
If the size of the set $Y$ is $|Y|=r$ then the number of equivalence
classes in the relation $\sim_G$ is
$$
Z(G; r,\ldots, r).
$$
\end{theorem}
The can be applied with the \command{subst\_inventory(r, ci)} command.

Suppose further we have a set $W$ of weights and a weight function
$w:Y\to W$. For a pattern $C$ and $f\in C$ we define a \DEF{pattern
  inventory of $C$} as
$$
PI(C) = \prod_{x\in X} w(f(x)).
$$
Note that the choice of $f$ is not important.

A \DEF{pattern inventory of the group $G$} is then defined as
$$
PI(G) = \sum_{n_1+\cdots+n_k=n}\tau(n_1,\ldots, n_k)[w(y_i)]^{n_1}\cdots [w(y_k)]^{n_k}.
$$
where $\tau(n_1,\ldots,n_k)$ is the number of patterns with the
pattern inventory
$$
[w(y_i)]^{n_1}\cdots [w(y_k)]^{n_k}.
$$

\begin{theorem}
\label{thm:polya2}
Let $s_i=[w(y_1)]^i+\cdots+[w(y_r)]^i$. Then
$$
PI(G) = Z(G; s_1,\ldots, s_k).
$$
\end{theorem}
The theorem can be applied with the
\command{subst\_inventory([w(y1),\ldots,w(yk)], ci)} command.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Examples}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Necklaces and bracelets}

A $n$-airy necklace of is composed of $n$ colored beads arranged in a
circle. Two necklaces are the same if we can rotate the first necklace
so that the colors of the beads match the colors of the second
necklace.

\begin{figure}
\begin{center}
\begin{tikzpicture}[style=thick, scale=1.5]
	\draw (0.5,2.5) circle (0.5cm);
		\draw[fill=white]
			(0.5,2) circle (1mm)
			(0,2.5) circle (1mm)
			(1,2.5) circle (1mm)
			(0.5,3) circle (1mm);
	\draw (2.5,2.5) circle (0.5cm);
		\draw[fill=white]
			(2,2.5) circle (1mm)
			(3,2.5) circle (1mm)
			(2.5,2) circle (1mm);
		\draw[fill=black]
			(2.5,3) circle (1mm);
	\draw (4.5,2.5) circle (0.5cm);
		\draw[fill=white]
			(4.5,2) circle (1mm)
			(4,2.5) circle (1mm);
		\draw[fill=black]
			(4.5,3) circle (1mm)
			(5,2.5) circle (1mm);
	\draw (0.5,0.5) circle (0.5cm);
		\draw[fill=black]
			(0.5,0) circle (1mm)
			(0.5,1) circle (1mm);
		\draw[fill=white]
			(1,0.5) circle (1mm)
			(0,0.5) circle (1mm);
	\draw (2.5,0.5) circle (0.5cm);
		\draw[fill=white]
			(2.5,1) circle (1mm);
		\draw[fill=black]
			(3,0.5) circle (1mm)
			(2.5,0) circle (1mm)
			(2,0.5) circle (1mm);
	\draw (4.5,0.5) circle (0.5cm);
		\draw[fill=black]
			(4.5,1) circle (1mm)
			(5,0.5) circle (1mm)
			(4.5,0) circle (1mm)
			(4,0.5) circle (1mm);
\end{tikzpicture}
\end{center}
\caption{4--airy necklaces of with 2 colors.}
\label{fig:necklaces2}
\end{figure}

Let $X$ be the set of $n$ beads arranged on a circle and $Y$ the set
of colors. A $n$-airy necklace is a mapping $f:X\to Y$ which assigns
the color $f(x)$ to each bead $x\in X$. Let $G$ be a cyclic group of
order $n$ acting on the set $X$. Two necklaces $f_1$ and $f_2$ are the
same if there is an element $g\in G$ such that $f_2(x)=f_1(x^g)$ for
all beads $x\in X$. In order to count the number of $n$-airy necklaces
we apply Theorem \ref{thm:polya1}. If we we need to substitute $r=|Y|$
into the cycle index of the group $G$ we obtain the number of $n$-airy
necklaces.

The number of 4-airy necklaces colored with two or four colors can be
computed in \maxima\ as follows.

\begin{example}
(%i1) load(discrete)$
(%i2) ci: cycle_index_cyclic(4);
(%o2) (2*x[4]+x[2]^2+x[1]^4)/4
(%i3) subst_inventory(2, ci);
(%o3) 6
(%i4) subst_inventory(4, ci);
(%o4) 70
\end{example}
%
The necklaces with colors white and black are shown in Figure
\ref{fig:necklaces2}. Using the Theorem \ref{thm:polya2} we can
further divide the numbers according to how many beads are colored
with the color black. We assign weight 1 to the color white and weight
$b$ to the color black. The coefficient at $b^m$ tells us the number
of necklaces with $m$ beads colored with the color black.

\begin{example}
(%i5) subst_inventory([1,b], ci);
(%o5) b^4+b^3+2*b^2+b+1
\end{example}
%
If we are interested in necklaces with four colors in which colors red
and green both appear exactly once, we assign the weights $r$ and $g$
to colors red and green and the weights 1 to the other two colors.

When we substitute the inventory into the cycle index we obtain the
pattern inventory, from which we need to read the coefficient at the
monomial $r g$.

\begin{example}
(%i6) inv: subst_inventory([r,g,1,1], ci);
(%o6) r^4+g*r^3+2*r^3+2*g^2*r^2+6*g*r^2+7*r^2+g^3*r
         +6*g^2*r+12*g*r+8*r+g^4+2*g^3+7*g^2+8*g+6
(%i7) mcoeff(inv,r,1,g,1);
(%o7) 12
\end{example}
%
If we replace the cyclic group with the dihedral group we also do not
distinguish between necklaces if they differ by a reflection.  Such
necklaces are called bracelets.

\begin{figure}[t]
\begin{center}
\begin{tikzpicture}[style=thick, scale=1.5]
\draw (0.5, 0.5) circle (0.5cm);
	\draw[fill=black] (0.5,1) circle (1mm);
	\draw[fill=black, rotate around={60:(0.5, 0.5)}] (0.5,1) circle (1mm);
	\draw[fill=black, rotate around={120:(0.5, 0.5)}] (0.5,1) circle (1mm);
	\draw[fill=white, rotate around={180:(0.5, 0.5)}] (0.5,1) circle (1mm);
	\draw[fill=white, rotate around={240:(0.5, 0.5)}] (0.5,1) circle (1mm);
	\draw[fill=white, rotate around={300:(0.5, 0.5)}] (0.5,1) circle (1mm);
\draw (2.5, 0.5) circle (0.5cm);
	\draw[fill=black] (2.5,1) circle (1mm);
	\draw[fill=black, rotate around={60:(2.5, 0.5)}] (2.5,1) circle (1mm);
	\draw[fill=white, rotate around={120:(2.5, 0.5)}] (2.5,1) circle (1mm);
	\draw[fill=black, rotate around={180:(2.5, 0.5)}] (2.5,1) circle (1mm);
	\draw[fill=white, rotate around={240:(2.5, 0.5)}] (2.5,1) circle (1mm);
	\draw[fill=white, rotate around={300:(2.5, 0.5)}] (2.5,1) circle (1mm);
\draw (4.5, 0.5) circle (0.5cm);
	\draw[fill=black] (4.5,1) circle (1mm);
	\draw[fill=black, rotate around={60:(4.5, 0.5)}] (4.5,1) circle (1mm);
	\draw[fill=white, rotate around={120:(4.5, 0.5)}] (4.5,1) circle (1mm);
	\draw[fill=white, rotate around={180:(4.5, 0.5)}] (4.5,1) circle (1mm);
	\draw[fill=black, rotate around={240:(4.5, 0.5)}] (4.5,1) circle (1mm);
	\draw[fill=white, rotate around={300:(4.5, 0.5)}] (4.5,1) circle (1mm);
\draw (6.5, 0.5) circle (0.5cm);
	\draw[fill=black] (6.5,1) circle (1mm);
	\draw[fill=white, rotate around={60:(6.5, 0.5)}] (6.5,1) circle (1mm);
	\draw[fill=black, rotate around={120:(6.5, 0.5)}] (6.5,1) circle (1mm);
	\draw[fill=white, rotate around={180:(6.5, 0.5)}] (6.5,1) circle (1mm);
	\draw[fill=black, rotate around={240:(6.5, 0.5)}] (6.5,1) circle (1mm);
	\draw[fill=white, rotate around={300:(6.5, 0.5)}] (6.5,1) circle (1mm);
\end{tikzpicture}
\end{center}
\caption{6-airy necklaces colored with three black and three white beads.}
\label{fig:necklaces6}
\end{figure}

We count the necklaces and bracelets of size 6 with three beads
colored black and three beads colored white.
\begin{example}
(%i8) ci: cycle_index_cyclic(6);
(%o8) (2*x[6]+2*x[3]^2+x[2]^3+x[1]^6)/6
(%i9) subst_inventory([1,t], ci);
(%o9) t^6+t^5+3*t^4+4*t^3+3*t^2+t+1
(%i10) coeff(%, t, 3);
(%o10) 4
(%i11) ci: cycle_index_dihedral(6);
(%o11) (2*x[6]+2*x[3]^2+x[2]^3+x[1]^6)/12+(x[2]^3+x[1]^2*x[2]^2)/4
(%i12) subst_inventory([1,t], ci);
(%o12) t^6+t^5+3*t^4+3*t^3+3*t^2+t+1
(%i13) coeff(%, t, 3);
(%o14) 3
\end{example}
%
6-airy necklaces with three black and three white beads are shown in
Figure \ref{fig:necklaces6}. The second and third necklace represent
the same bracelet.

In the last example we show how to obtain the list of 4--airy necklaces
with 2 colors using the \command{group\_orbits} function. We need to
define a set of all colorings of the 4--cycle (represented as a list),
and compute orbit representatives for the group action on the set of
colorings.

The possible colorings are binary sequences of length 4 and are
computed with the \command{bin\_seqs} function. We define the function
\command{permute\_list} which defines the action of the group on the
colorings. Finally we compute the group orbit representatives with the
\command{group\_orbit\_representatives} function. We need to specify
the set on which the group acts and the group action. We also only
wish to see representatives for each orbit. The result should be
compared with Figure \ref{fig:necklaces2}.

\begin{example}
(%i15) bin_seqs(n) :=
         if n=1 then [[1],[0]]
         else block([bs: bin_seqs(n-1)],
           append(
             map(lambda([s], cons(1, s)), bs),
             map(lambda([s], cons(0, s)), bs)))$
(%i16) grp: cyclic_group(4)$
(%i17) group_orbit_representatives(grp,
          set=setify(bin_seqs(4)), action=permute_list);
(%o17) {[0,0,0,0],[0,0,0,1],[0,0,1,1],[0,1,0,1],[0,1,1,1],
        [1,1,1,1]}
(%i18) length(%);
(%o18) 6
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Colorings of graphs}

An important application of P\'olya theory is to molecular graphs
(graphs which represent molecules). An example of such graph
is shown in Figure \ref{fig:mgraph}.

\begin{figure}
\begin{center}
\begin{tikzpicture}[style=thick, scale=0.5]
	\draw (0,0) node (n1)  {} --
		 ++(90:2) node (n2) [] {} --
		 ++(30:2) node (n3) [] {} --
		 ++(-30:2) node (n4) [] {} --
		 ++(30:2) node (n5) [] {} --
		 ++(-30:2) node (n6) [] {} --
		 ++(30:2) node (n7) [] {} --
		 ++(-30:2) node (n8) [] {} --
		 ++(-90:2) node (n9) [] {} --
		 ++(-150:2) node (n10) [] {} --
		 ++(-210:2) node (n11) [] {} --
		 ++(-150:2) node (n12) [] {} --
		 ++(-210:2) node (n13) [] {} --
		 ++(-150:2) node (n14) [] {} -- (n1)
		(n4) -- (n13) (n6) -- (n11);
\end{tikzpicture}
\end{center}
\caption{A molecular graph.}
\label{fig:mgraph}
\end{figure}

In the next example we count 2--colorings of the graph in
Figure \ref{fig:mgraph} if we consider two colorings to be equal when
they differ by an automoprhism of the graph. We also count the number
of 2-colorings in which the first color appears twice. The package
\command{discrete} loads the \command{graphs} package so we can use
its functions to define the graph. We need to work around a technical
issue first. The graphs created with the \command{graphs} package have
vertex ids from 0 to $n-1$. We first relabel the vertices so that the
ids are from 1 to $n$.

\begin{example}
(%i1) load(discrete)$
(%i2) g: cycle_graph(14)$
(%i3) g: relabel_graph_vertices(g, min_id=1)$
(%i4) add_edges([[3,12],[5,10]], g)$
(%i5) grp: graph_automorphisms(g);
(%o5) {[1,2,3,4,5,6,7,8,9,10,11,12,13,14],
       [7,6,5,4,3,2,1,14,13,12,11,10,9,8],
       [8,9,10,11,12,13,14,1,2,3,4,5,6,7],
       [14,13,12,11,10,9,8,7,6,5,4,3,2,1]}
(%i6) ci: cycle_index_group(grp);
(%o6) (2*x[2]^7+x[1]^2*x[2]^6+x[1]^14)/4
(%i7) subst_inventory(2, ci);
(%o7) 4224
(%i8) inv: subst_inventory([1,t], ci);
(%o8) t^14+4*t^13+28*t^12+94*t^11+266*t^10+508*t^9+777*t^8
          +868*t^7+777*t^6+508*t^5+266*t^4+94*t^3+28*t^2
          +4*t+1
(%i9) coeff(inv, t, 2);
(%o9) 28
\end{example}
%
If we wish to count the number of 2--colorings of the edges of the graph,
we need to compute the group action of \command{grp} on the set 
edges of the graph.

\begin{example}
(%i10) edges: fullsetify(edges(g))$
(%i11) grp_e: group_action(grp, edges);
(%o11) {[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16],
        [9,10,7,6,8,4,3,5,1,2,16,15,14,13,12,11],
        [11,10,12,13,8,14,15,5,16,2,1,3,4,6,7,9],
        [16,2,15,14,5,13,12,8,11,10,9,7,6,4,3,1]}
(%i12) ci_e: cycle_index_group(grp_e);
(%o12) (2*x[2]^8+x[1]^4*x[2]^6+x[1]^16)/4
(%i13) subst_inventory([1,t], ci_e);
(%o13) t^16+5*t^15+37*t^14+147*t^13+482*t^12+1113*t^11
           +2059*t^10+2895*t^9+3290*t^8+2895*t^7+2059*t^6
           +1113*t^5+482*t^4+147*t^3+37*t^2+5*t+1
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Graphs generating function}

The \DEF{graph generating function} is defined as
$$
GF_n(t) = \sum_{m=0}^{\frac{n(n+1)}{2}} a_mt^m
$$
where $a_n$ is the number of graphs on $n$ vertices with $m$ edges.
In this example we compute the function $GF_4(t)$.

\begin{figure}
\begin{center}
\begin{tikzpicture}[style=thick, scale=0.5]
	\draw
	 (0,0) node (n1) [] {} --
		  ++(2,0) node [] {} --
		  ++(0,2) node [] {} --
		  ++(-2,0) node [] {} -- (n1)
	(5,0) node (n2) [] {} --
		  ++(2,0) node [] {} --
		  ++(0,2) node [] (n21) {} --
		  ++(-2,0) node [] {} -- (n2) -- (n21)
	(10,0) node (n31) [] {} --
		  ++(2,0) node (n32) [] {} --
		  ++(0,2) node (n33) [] {} --
		  ++(-2,0) node (n34) [] {} -- (n31) (n32) -- (n34) (n31) -- (n33)
	(0,5) node (n4) [] {} --
		  ++(2,0) node [] {} --
		  ++(0,2) node (n41) [] {}
		  ++(-2,0) node [] {}
		  (n4) -- (n41)
	(5,5) node (n5) [] {} --
		  ++(2,0) node (n51) [] {} --
		  ++(0,2) node [] {}
		  ++(-2,0) node (n52) [] {}
		  (n51) -- (n52)
	(10,5) node (n6) [] {} --
		  ++(2,0) node (n61) [] {} --
		  ++(0,2) node [] {} --
		  ++(-2,0) node (n62) [] {}
	(15,5) node (n7) [] {} --
		  ++(2,0) node [] {} --
		  ++(0,2) node (n71) [] {} --
		  ++(-2,0) node [] {}
		  (n7) -- (n71)
	(0,10) node (n8) [] {}
		  ++(2,0) node [] {}
		  ++(0,2) node [] {}
		  ++(-2,0) node [] {}
	(5,10) node (n9) [] {} --
		  ++(2,0) node [] {}
		  ++(0,2) node [] {}
		  ++(-2,0) node [] {}
	(10,10) node (n10) [] {} --
		  ++(2,0) node [] {} --
		  ++(0,2) node [] {}
		  ++(-2,0) node [] {}
	(15,10) node (n11) [] {} --
		  ++(2,0) node [] {}
		  ++(0,2) node [] {} --
		  ++(-2,0) node [] {};
\end{tikzpicture}
\end{center}
\caption{Graphs on 4 vertices.}
\label{fig:graphs4}
\end{figure}

Two graphs are isomorphic if there exists a permutation of vertices of
the first graph which produces the second graph.

We think of a graph $G$ on $n$ vertices as a coloring of the edges of
the complete graph $K_n$ with two colors black and white. The black
edges of $K_n$ are present in the graph $G$ and the white are not. Two
graphs $G$ and $H$ on $n$ vertices are isomorphic if there exists an
automorphism of the graph $K_n$ which changes the coloring of $K_n$
corresponding to $G$ to the coloring corresponding to $H$.  The group
of automorphisms of $K_n$ is the symmetric group $S_n$. We need to
compute the action of $S_n$ on the edges of $K_n$ which are the
2-subsets of the set $\{1,2,\ldots,n\}$. We are now ready to compute a
graphs generating function. Let $n=4$.

\begin{example}
(%i1) load(discrete)$
(%i2) grp_v: symmetric_group(4)$
(%i3) grp_e: group_action(grp_v, powerset({1,2,3,4}, 2))$
(%i4) ci: cycle_index_group(grp_e);
(%o4) (6*x[2]*x[4]+8*x[3]^2+9*x[1]^2*x[2]^2+x[1]^6)/24
(%i5) subst_inventory(2, ci);
(%o5) 11
(%i6) subst_inventory([1,t], ci);
(%o6) t^6+t^5+2*t^4+3*t^3+2*t^2+t+1
\end{example}
%
The list of graphs on 4 vertices is shown in Figure \ref{fig:graphs4}.
The coefficient at $t^m$ in the output \verb|%o6|
gives the number of graphs with $m$ edges on four vertices.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Combinatorial species}

The package \command{Species} has functions for counting, listing and
random selection from combinatorial species. Informally, a
combinatorial species is a class of objects which are either atomic or
are constructed with a production rule from other combinatorial
species. A species is labeled, if atoms of size one are labeled with
integers from 1 up to $n$ and unlabeled if atoms are not labeled.

Atomic objects can be atoms which have size 1 or epsilon objects which
have size 0. Productions rules implemented are disjoint union
(\command{Sum}), Cartesian product (\command{Prod}), sequence
(\command{Seq} or \command{Sequence}), sets with repetition
(\command{Multiset} or \command{MSet}), sets without repetition
(\command{Set}) and cycles (\command{Cycle}). Multisets only appear in
unlabeled species.

A \DEF{specification} for combinatorial species is a list of
production rules. We assume that all symbols which appear in a
specification and do not have production rules are atoms.

For example, the specification
$$
\{S=Prod(X, Y), X=Sum(a, b, c), Y=Sum(e, f)\}
$$
defines three combinatorial species. The elements $a, b, c, e, f$ are
atoms, species $X$ contains elements $a, b$ and $c$, species $Y$
contains elements $e$ and $f$ and finally species $S$ contains
$PROD(a, e)$, $PROD(a, f)$, $PROD(b, e)$, $PROD(b, f)$, $PROD(c, e)$,
$PROD(c, f)$.

The \DEF{size} of an element $e$ from a combinatorial species is the
sum of sizes of all atomic objects which appear in $e$. For production
rules \command{Seq}, \command{Set}, \command{MSet} and \command{Cycle}
we also define the \DEF{cardinality}, which is the number of elements
in the sequence, set, multiset and cycle.

For example in specification $\{A=Sum(x, Prod(x,x)), B=Seq(A)\}$ we
have a species $A$ with elements $x$ and $(x,x)$ and a species $B$ of
sequences of elements of $A$. The element $SEQ(x, x, x, PROD(x,x), x,
PROD(x,x))$ has cardinality 6 and size 8.

There is also a special species production rule called \command{Function}.
The rule accepts one arguments which is a function which returns the
number of elements of given size.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Counting, listing, random generation}

The main functions in the \command{Species} package are
\command{count\_species}, \command{list\_species} and
\command{select\_from\_species}. All take three arguments: the species
$A$, specification $spec$ and the size $n$.  \command{count\_species}
returns the number of elements of the species $S$ defined by $spec$ of
size $n$, \command{list\_species} returns a list of all elements of
the species $S$ of size $n$ and \command{select\_from\_species}
returns a random element from the species $S$.

Random generation is uniform, if the number of elements of size $n$ is
$a_n$, then the probability that a specific element will be generated
is $\frac{1}{a_n}$.

All three functions will remember all partial results computed which
can be used in later computations. In some situations this memory
needs to be cleared. The memory can be cleared with the function
\command{reset\_species\_memory}.

There is also a function \command{nice\_disp} changes elements
obtained from production rules into lists.

\begin{example}
(%i1) load(Species)$
(%i2) count_species(S, spec, 2);
(%o2) 6
(%i3) list_species(S, spec, 2);
(%o3) [PROD(a,e),PROD(a,f),PROD(b,e),PROD(b,f),
       PROD(c,e),PROD(c,f)]
(%i4) select_from_species(S, spec, 2);
(%o4) PROD(a,e)
(%i5) nice_disp(%);
(%o5) [a,e]
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generating functions}

For a combinatorial species $A$ we define its generating function
$A(t)$ as a formal power series
$$
A(t)=\sum_{n=0}^\infty a_nt^n
$$
where $a_n$ is the number of elements of size $n$ in the species $A$.

The function \command{gf\_equations(spec,t)} returns a system of
equations which define the generating functions of species defined by
\command{spec}. If the system is nice the function \command{gf\_solve}
can then be used to compute the generating functions from equations,
or the function \command{gf\_express} can be used to find an equation
for a specific generating function.

\begin{example}
(%i6) spec: [S=Seq(Sum(x, Prod(x,x)))];
(%o6) [S = Seq(Sum(x,Prod(x,x)))]
(%i7) gf_eqs: gf_equations(spec, t);
(%o7) [S(t) = g4323(t)+1,g4323(t) = g4322(t)*S(t),
       g4322(t) = x(t)+g4321(t),g4321(t) = x(t)^2,
       Epsilon(t) = 1,x(t) = t]
(%i8) alg_eq: gf_express(gf_eqs, S(t));
(%o8) (-t^2-t+1)*S(t)-1
(%i9) gf_solve(gf_eqs);
(%o9) [[S(t) = -1/(t^2+t-1),g4323(t) = -(t^2+t)/(t^2+t-1),
        g4322(t) = t^2+t,g4321(t) = t^2,Epsilon(t) = 1,
        x(t) = t]]
\end{example}
%
When the equation for the generating function $A(t)=\sum_{n=0}^\infty
a_nt^n$ is algebraic the function \command{algeq\_to\_rec} (based on
the MuPAD--Combinat function \command{algeqtorec}) can be used to
compute a recurrence relation for the sequence $a_n$. This can be used
to define a function for fast species counting.

\begin{example}
(%i10) rec: algeq_to_rec(alg_eq, S(t));
(%o10) y[n]-y[n-1]-y[n-2]
(%i11) init: makelist(count_species(S, spec, i), i, 1, 2);
(%o11) [1,2]
(%i12) rec_to_function(rec, y[n], init);
(%o12) y_rf[n]:=if n <= 2 then part([1,2],n)
                else y_rf[n-1]+y_rf[n-2]
(%i13) y_rf[30];
(%o13) 1346269
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Examples}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Necklaces}

The number necklaces on four vertices with two colors can be computed
with the Cycle production rule.

\begin{example}
(%i1) load(Species)$
(%i2) spec:[N=Cycle(Sum(w,b))];
(%o2) [N = Cycle(Sum(w,b))]
(%i3) count_species(N, spec, 4);
(%o3) 6
(%i4) list_species(N, spec, 4);
(%o4) [CYCLE(w,w,w,w),CYCLE(b,w,w,w),CYCLE(b,w,b,w),
       CYCLE(b,b,w,w),CYCLE(b,b,b,w),CYCLE(b,b,b,b)]
\end{example}
%
Compare this with the necklace example in the P\'olya theory section.

\subsubsection{Trees}

A \DEF{rooted binary tree} can be defined as a leaf or an internal
node with two binary subtrees (see Figure \ref{fig:btdef}). Binary
trees with $n$ leaves can be counted with the following specification

\begin{figure}
\begin{center}
\begin{tikzpicture}[style=thick,scale=0.66]
\draw (0,5) -- ++ (-1,-3) -- ++ (2, 0) -- ++ (-1, 3)
	(2,5) node [draw=white] {=}
	(4,5) node [fill=black] {}
	(6,5) node [draw=white] {+}
	(10,5) node (r) [] {}
	(r) -- ++ (-45:2) -- ++ (-1,-3) -- ++ (2, 0) -- ++ (-1, 3)
	(r) -- ++ (225:2) -- ++ (-1,-3) -- ++ (2, 0) -- ++ (-1, 3);
\end{tikzpicture}
\end{center}
\caption{Decomposition of a binary tree into smaller binary trees.}
\label{fig:btdef}
\end{figure}

\begin{example}
(%i1) load(Species)$
(%i2) spec: [T=Sum(x, Prod(T, T))];
(%o2) [T = Sum(x,Prod(T,T))]
(%i3) makelist(count_species(T, spec, i), i, 1, 10);
(%o3) [1,1,2,5,14,42,132,429,1430,4862]
\end{example}
%
The generating functions can be used to efficiently count
the binary trees for large number of leaves.

\begin{example}
(%i4) gf_equations(spec, t);
(%o4) [T(t) = x(t)+g4255(t),g4255(t) = T(t)^2,x(t) = t]
(%i5) gf_express(%, T(t));
(%o5) T(t)^2-T(t)+t
(%i6) algeq_to_rec(%, T(t));
(%o6) n*y[n]+(6-4*n)*y[n-1]
(%i7) rec_to_function(%, y[n], [1,1])$
(%i8) y_rf[100];
(%o8) 227508830794229349661819540395688853956041682601541047340
(%i9) nice_disp(select_from_species(T, spec, 5));
(%o9) [x,[x,[[x,x],x]]]
\end{example}
%
The random selection corresponds to the tree in Figure \ref{fig:tree}.

\begin{figure}
\begin{center}
\begin{tikzpicture}[style=thick, scale=0.66]
	\draw (0,0) node (n1) [] {} --
	++(-45:2) node (n2) [] {} --
	++ (-45:2) node (n3) [] {} --
	++ (-135:2) node (n4) [] {} --
	++ (-135:2) node (n5) [fill=black] {}
	(n4) -- ++ (-45:2) node (n6) [fill=black] {}
	(n3) -- ++ (-45:2) node (n7) [fill=black] {}
	(n2) -- ++ (-134:2) node (n8) [fill=black] {}
	(n1) -- ++ (-135:2) node (n9) [fill=black] {};
\end{tikzpicture}
\end{center}
\caption{A random binary tree with 5 leaves.}
\label{fig:tree}
\end{figure}

A \DEF{ternary tree} is a rooted tree in which each node has at most
three children. We do not distinguish between two trees if one can be
obtained from the other by permuting the children of some nodes.

Ternary trees can be counted with the following specification.

\begin{example}
(%i10) spec: [TT=Prod(x, MSet(TT, max_card=3))]$
(%i11) makelist(count_species(TT, spec, i), i, 1, 15);
(%o11) [1,1,2,4,8,17,39,89,211,507,1238,3057,7639,19241,48865]
\end{example}
%
The function \command{tree\_disp} nicely prints a tree.
\begin{example}
(%i12) tree_disp(tree) := tree_disp1(tree, 1)$
       tree_disp1(tree, d) := (
         if length(tree)>0 then
           printf(true,"狺苘狺ア磲脲扉篝á洎骈蝮舁趄邋┅殒戾铉翳趄邋┚翳孱磲皎灬礅溽ㄛ糨趄邋咪轶鸨衄浍穿┈箦泔钿趄邋┅─苠钿屮犴痨妪蜥钿镯翦蝾狎趄邋镱辈铒溴ㄆ殓躜茯彐骈绾趑铋沐禊痱轭翦鏖翳翳茔镯磲钿趄邋苓溟箴骢钽糸镱茆彗轭屮犴痨妪ē楸畅趄邋铋沐咪轶皎箦戾泗哝蝻磉箴邈殄蟥栽箴邈辈┅ē楸穿趄邋咪轶皎趄邋─墉墉墉墉墉墉墉墉墉墉墉墉苠钿屮犴痨妪茆彗轭骈珲蝈茆彗轭沐铘弪茆彗轭糸膪痖泗躜妪垠豉戾紧栝汶筱犰褰爱递茕蜥ò癌铒溴畋ō惮博铒溴畈畈ō爆博铒溴ī畈ū博铒溴ī畋ò博铒溴畛畛ō铂博铒溴ī畛ò博铒溴ī畛ú博铒溴ī畋ǖ博铒溴īò博铒溴畲畲ō爆博铒溴ī畲ū博铒溴ī苠钿糸膪痖泗躜妪苠钿沐铘弪茔狃糸镱蜥钿镯翦蝾狎趄邋莒徕屐骈绾趑苠钿骈珲蝈ゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥ荏踱篚怏邈糸镱惋铒麸铋疳翳簖盹铒麸铋疳翳轶疳翳犰镱翳邃珏镦ゎ荇轫弩瞍珧殇麒殂篝狎趔狒え艾癌が孱潴狒え瞵瞟犷轶犰麽徕秭翳溟徵镱犰惋铒麸铋疳翳汜忮泔躅翦鏖翳翳骘祆秣轭箴邈殒殂狒轱町茆彗轭骈珲蝈茆彗轭沐铘弪茆彗轭糸膪痖泗躜妪垠豉戾紧栝汶筱犰褰爱返茕蜥郗粳溴泔蜥翦溴泔蜥糸镱襟钺脲ò畅ú旦茕蜥ǔ旦铒溴垆蜥鹘麒轸遢烬茕蜥ù旦铒溴垆蜥鹘麒轸遢ぼ屦箝祜瞍茕蜥ǖ旦铒溴垆蜥鹘麒轸遢茕蜥髹蹯趄翳殂氍据ǘ癌ǘ暴茕蜥郗粳溴泔蜥翦溴泔蜥糸镱襟钺脲ǘ暴ǜ畅茕蜥髹蹯趄翳殂氍据ǜ畅ü畅茕蜥郗粳溴泔蜥翦溴泔蜥糸镱襟钺脲ü畅ū爆旦苠钿糸膪痖泗躜妪苠钿沐铘弪茔狃糸镱腻泔眇矬轸轱镦盹铒麸铋疳翳轭麸箜犰戾盹铒麸铋疳翳螽莒徕屐骈绾托箴邈苠钿骈珲蝈茆彗轭屮犴痨妪ē楸祜徜ㄓ疱汩弩─ē椴箴邈弁薪吁悫硼箝祜瞵序镤ㄕ瓞托议玷衄托┅议玷艚硼箝祜钶ē槌磲脲扉篝ㄣ秕铘唧疱汩弩ㄍ鞋箴邈椹楝爆卑┗ē锍郾铂惮贝床背铂床宫贝嘲锤恫倍饭遁苠钿屮犴痨妪澡箦聃孱沐轶箝黹灬麸铛礅弪镦忾钺蝙趄邋螽澡铛礅弪轭翳箦聃孱沐狎腩秣狍冕翎灬铛礅弪っ哳杰骝徙饼瞰饼差茔栾矬铨ぎ茆彗轭骈珲蝈茆彗轭沐铘弪茆彗轭糸膪痖泗躜妪垠豉戾紧栝汶筱犰褰爱递茕蜥髹珧狴篝屦讲ò癌珧殇ū冬倍┗茕蜥髹珧狴祜矬屐溽箬邃ò癌ū冬倍┗茕蜥髹粳蹯趄翳殂胼ò癌ò博茕蜥髹粳蹯趄翳殂胼ò博ú博茕蜥髹粳蹯趄翳殂胼ú博ú穿茕蜥髹粳蹯趄翳殂胼ú穿ú订茕蜥髹粳蹯趄翳殂胼ú订ú俯茕蜥髹粳蹯趄翳殂胼ú俯ù俯茕蜥髹粳蹯趄翳殂胼ù俯ǘ俯茕蜥髹粳蹯趄翳殂胼ǘ俯ǘ卑┗茕蜥髹粳蹯趄翳殂胼ǘ卑ǜ卑┗茕蜥髹粳蹯趄翳殂胼ǜ卑ǜ辈┗茕蜥髹粳蹯趄翳殂胼ǜ辈ǜ贝┗茕蜥髹粳蹯趄翳殂胼ǜ贝ū艾贝┗茕蜥髹粳蹯趄翳殂胼ū艾贝ū铂贝┗茕蜥髹粳蹯趄翳殂胼ū铂贝ū船贝┗茕蜥髹粳蹯趄翳殂胼ū船贝ū船倍┗茕蜥髹粳蹯趄翳殂胼ū船倍ū冬倍┗苠钿糸膪痖泗躜妪苠钿沐铘弪茔狃糸镱蜥钿镯盹铒麸铋疳翳莒徕屐骈绾托苠钿骈珲蝈茆彗轭屮犴痨妪ē榇磲脲扉篝ㄢ轭镯獒歙勃瞵瞟瞰暴瞵爆卑┗ē锎郾铂惮贝床背铂床宫贝嘲锤恫倍饭遁苠钿屮犴痨妪蜥钿镯盹铒麸铋疳翳镦戾铉翳轶箬秣轭崎珲蝈茯彐骈绾托茆彗轭屮犴痨妪ē榈骒狒翦瞑铋沐咪轶鸨箦戾泗哝蝻磉箴邈殄蟥托箴邈俯┅ē锏壅瓞议玷衄震震震议玷衄议玷衄震议玷衄震震议玷衄议玷衄议玷衄震议玷糨苠钿屮犴痨妪族汜骈钿翳屮痨殂轸骘蝽蹯骘翳铛礅弪镦盹铒麸铋疳翳镦戾铉翳ゎ骝镯翳珏铄蜥糸铉骢钽糸镱螽茆彗轭屮犴痨妪ē槎珂咤聃狒轱铙箴邈舂ē榉珂咤痱弩蟥ガ托舂┗ē锓舄托舂薏托舂ē楦犰珏襁麸唑邈ē托舂┗ē锔瞰暴垲莴ú椽瞟垲陛ē楣箫祧暹蝈悒ガ垲莠郾萁暴ē锕垲厕ú瞟玑眄屺瞰悲博篑螋ē痖┆瞰暴々苠钿屮犴痨妪ゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥ荏踱篚怏邈糸镱深翦珏疳螋轸轱铙族鏖祆躞翳茔镯磲钿契钽糸镱痱镤蹉糸镱蝓戾麸溴骈铄箴邈殄镦篚怏弭镦轭翦珏蝮族狍篚礤翳狒翳箝镦犷轭翦珏ゎ轶ゎぎ令轭翦珏疳螋轸轱镦ゎ轶翳孱眭祠轶弭镦轭翦珏蝮镦箝ゎぎ茆彗轭屮犴痨妪ē楸祜徜ㄓ疱汩弩─ē椴泐暨轭趔瞟航殒罹翳孱屐箦挨ē槌箴邈尚凵薪陀弭ㄎ┈谓契钽糸镱ㄣ铘唛铘螬荬ē榇泔躅暨箴邈殄蟥尚箴邈尚卑癌ē锎惫暗豆补ē榈铛磉疳螋轸轱铙ū鞍┗ē锏惫暗豆补ē槎铋沐咪轶皎箦戾泗哝蝻磉箴邈殄蟥尚箴邈尚卑癌┗ē锒郾爆爆爆爆爆爆爆超超超超超超超超番番番钡巢苠钿屮犴痨妪湘泔躜箦翳泔躅糸铉骢钽糸镱汜忮盹蝈泔眇扉汜翦洚深翳骘祆秣轭屮犴痨麇泔躅翳铛礅弪镦疳螋轸轱铙镦卑轭麸赭痱轫弩犷赭篑踽蝈螽茆彗轭屮犴痨妪ē榉泐暨痱轫弩瞟航殒痱轫屦瞟翳孱屐箦挨ē楦泐暨篑踽蝈蟥瞟航殒轭翦珏蝠篑螋瞟翳孱屐箦挨ē楣箴邈尚凵薪序镤ㄐ鞋蝇萤薪契钽糸镱ㄣ铘唣蜷礤螬咏契钽糸镱ㄣ铘唧聃狎弩┹ē楸癌泔躅暨箴邈殄蟥尚箴邈尚卑癌ē锉癌彻ē楸暴骒狒翦瞑铋沐咪轶皎箦戾泗哝蝻磉箴邈殄蟥尚箴邈尚卑癌┅ē锉暴郾超斗船倍苠钿屮犴痨妪族汜犰箫泔躅翳铛礅弪镦疳螋轸轱铙镦犷轭翦珏ゎ轭麸翳蝈痱轫弩茆彗轭屮犴痨妪ē楸博箴邈尚泻凵薪陀弭ㄐ汜蜾匠┈薪契钽糸镱ㄣ铘唣蜷礤螬荬ē楸畅磲脲扉篝ㄣ秕铘唧疱汩弩ㄉ鞋箴邈尚鞋椹楝冬卑癌ē锉畅郾爆爆铂爆铂铂铂爆超铂船铂超铂惮铂惮超惮超番超番铂冬超宫铂脯船宫船卑铂北超卑船辈超背船辈惮钡船倍超贝惮狈超倍船倍冬惫超脖惮舶冬舶铂膊惮脖冬膊惮哺惮泊番驳船补惮卜脯补惮吵船补宫吵船车惮炒番嘲齿ē楸穿铋沐咪轶皎箦戾泗哝蝻磉箴邈殄蟥尚箴邈尚鞋嘲暴┗ē锉穿郾超捶泊陛苠钿屮犴痨妪ゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥ荏踱篚怏邈糸镱渝聃孱沐簖箦聃孱沐め弑徇册叱徇窜沅雉螭汜忮蝈痱弩孱翦狍ば蝻洙徇爆序镤ㄡ卟序镤ㄡ叱茔滹趔┅─澡轶孱徕戾躞麸泔躅箦聃孱沐鏖翳箴邈獒痱镳弪糸弩深翳铄屮犴痨麇轭鲥篝殓狒翳铛礅弪镦黠蜾镦戾铉翳ゎ鏖翳戾趑弪岈犷轭麒殂遽汨戾趑弪狃疱狎犷弼孱铛礅弪镦糸礤螽族溴骈铄箴邈殄ち迓迕澶ち迓迕铯ぼ熹雉螭麒殂蝈痱弩孱黠蜾轭麒殂遽汨戾趑弪狃疱狎犷弼孱铛礅弪镦糸礤蠡岈狃疱狎犷弼孱铛礅弪镦糸礤犷犷镤铛礅弪镦糸礤ぼ熹雉螭茆彗轭屮犴痨妪ē楸祜徜ㄓ疱汩弩─ē椴箴邈痕铃洛缅接蹴ㄅ痼殪镱序镤连溜洛缅┈序镤卢铃嘛缅┈序镤矛铃洛蔑┅铃洛蔑接蹴ㄐ蝻洙连溜洛蔑┈序镤卢铃嘛蔑┈序镤矛铃洛缅┅铃嘛缅接蹴ㄐ蝻洙连溜嘛缅┈序镤卢铃洛缅┈序镤矛铃嘛蔑┅铃嘛蔑接蹴ㄐ蝻洙连溜嘛蔑┈序镤卢铃洛蔑┈序镤矛铃嘛缅┅溜洛缅接蹴ㄐ蝻洙连铃洛缅┈序镤卢溜嘛缅┈序镤矛溜洛蔑┅溜洛蔑接蹴ㄐ蝻洙连铃洛蔑┈序镤卢溜嘛蔑┈序镤矛溜洛缅┅溜嘛缅接蹴ㄐ蝻洙连铃嘛缅┈序镤卢溜洛缅┈序镤矛溜嘛蔑┅溜嘛蔑接蹴ㄐ蝻洙连铃嘛蔑┈序镤卢溜洛蔑┈序镤矛溜嘛缅┅荬ē槌磲脲扉篝ㄣ秕铘唧疱汩弩铃洛缅箴邈椹楝艾舶┗ē锍郾艾超艾脖艾备超艾倍幢艾贝范超艾背哺侗艾北沟反超艾卑范倍副艾苟傅当渤艾阜倍苟卑陛ē榇磲脲扉篝ㄣ秕铘唧疱汩弩铃嘛蔑箴邈椹楝艾舶┗ē锎郯艾铂艾舶艾备铂艾倍窗艾贝范铂艾背哺栋艾北沟反铂艾卑范倍赴艾苟傅当膊艾阜倍苟卑拜ē榈磲脲扉篝ㄣ秕铘唧疱汩弩溜嘛蔑箴邈椹楝艾舶┗ē锏郯艾艾冬艾栋艾荡冬艾垂舶艾创哺冬艾彻傅赴艾车阜膊冬艾巢哺蛋窗艾补暗兜扯冬拜ē槎磲脲扉篝ㄣ秕铘唧疱汩弩溜洛缅箴邈椹楝艾舶┗ē锒郯爆艾番艾侗艾荡番艾垂脖艾创哺番艾彻傅副艾车阜膊番艾巢哺蛋幢艾补暗兜扯番拜苠钿屮犴痨妪族箦翳狒骘镤ゎ翳弪狎铒箦聃孱沐轭ち迓迕澶犷骘弼孱ゎ翳弪轶镱盹蝈箦聃孱沐轭ち迓迕澶翳犷轭ち迓锩铯族汜骢螋桢轭鲥篝殓狒翳珏铄蜥糸铉骢钽糸镱螽茆彗轭屮犴痨妪ē榉羼铙珂咤聃狒轱铙箴邈舂ē楦羼铙唧镬珂唧镬鲥ㄥ耦螬ē楣铃洛缅哏婧狍箫悒铃洛缅舂骈蝮舁羼铙唧镬┅ē锕ǚ艮箔暴ü艮喘卑艮搏暴ē楸癌铃洛缅唑邈蜥翩躅唪镞蝈悒铃洛缅哏姗ē锉癌垲莴卑垲草躬垲摧ē楸暴铃洛缅唧镬箫祧暹蝈悒铃洛缅唑邈垲莠郯萁爆郾萁艾鄄萁超鄢萁癌ē锉暴垲侈畀斧唱ō暴揞斧ō畅揞斧朝ē楸博溴沆狎濞瞵轭翦珏颟ē楸畅篚怏舁罱勃瞵铃洛缅唧镬┗ē锉畅鄄钶侈ú瞟传朝苠钿屮犴痨妪ゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥゥ荏踱篚怏邈糸镱迈殪溟铉麸麇蝮茆彗轭骈珲蝈垧茆彗轭沐铘弪茆彗轭糸膪痖泗躜妪垠豉戾紧栝汶筱犰褰爱递茕蜥ú暴ò暴ò癌ú癌ú博ū博ū癌茕蜥ǔ暴ǖ暴ǖ博ǔ博ǔ癌ù癌ù博茕蜥ǚ博ǚ癌ǜ癌ǜ博ǘ博ǘ暴ǜ暴茕蜥ò穿ū穿ū旦ò旦ò穿茕蜥ú穿ǔ穿ǔ旦ú旦ú畅ǔ畅ǔ穿茕蜥ǖ旦ǖ穿ǘ穿ǘ旦ù旦ù穿ǖ穿茕蜥ǜ畅ǜ旦ǚ旦ǚ畅ü畅ü穿ǚ穿苠钿糸膪痖泗躜妪苠钿沐铘弪茔狃糸镱蚂镢塍躞邃骘怩殪溟铉麸麇蝮莒徕屐骈绾忪镢塍苠钿骈珲蝈茆彗轭骈珲蝈垧茆彗轭沐铘弪茆彗轭糸膪痖泗躜妪垠豉戾紧栝汶筱犰褰爱递茕蜥埚弪翳轭珧狴ō爆穿ü穿茕蜥ò癌ú癌ú穿ò穿ò癌ǔ癌ǖ癌ǖ旦ù旦ù穿ǔ穿ǔ癌ǘ癌ǜ癌ǜ穿ǚ穿ǚ旦ǘ旦ǘ癌苠钿糸膪痖泗躜妪苠钿沐铘弪茔狃糸镱燥麇蝮箴邈殄镦箝ゎぎ莒徕屐骈绾麸麇蝮苠钿骈珲蝈茆彗轭骈珲蝈垧茆彗轭沐铘弪茆彗轭糸膪痖泗躜妪垠豉戾紧栝汶筱犰褰爱递茕蜥ò畅ú畅ú旦ò旦ò畅茕蜥ò穿ú穿茕蜥ū畅ū旦茕蜥ǔ穿ǖ穿ǖ畅ǔ畅ǔ旦ǖ旦ǖ穿茕蜥ù旦ù穿茕蜥ǘ穿ǜ穿ǜ畅ǘ畅ǘ旦ǜ旦ǜ穿茕蜥ǚ穿ǚ畅茕蜥ü旦ū爆旦ū爆畅ü畅ü旦茕蜥ü穿ū爆穿茕蜥ū铂旦ū船旦ū船畅ū铂畅ū铂旦茕蜥ū超畅ū超旦茕蜥ò暴ū暴ū博ò博ò癌ú癌ú博ū博茕蜥ù癌ù博ǔ博ǔ癌ǖ癌ǖ博ù博茕蜥ǔ暴ù暴茕蜥ǚ博ǚ暴ǜ暴ǜ博ǘ博ǘ癌ǜ癌ǜ博茕蜥ū艾博ū艾癌ū爆癌ū爆博ü博ü癌ū艾癌茕蜥ū艾暴ū爆暴茕蜥ū铂暴ū超暴ū超癌ū船癌ū船博ū铂博ū铂癌ū超癌茕蜥ū番暴ū冬暴ū冬癌ū番癌ū番博ū惮博ū惮癌ū冬癌苠钿糸膪痖泗躜妪苠钿沐铘弪茔狃糸镱燥麇蝮镦箝伯莒徕屐骈绾麸麇蝮昌苠钿骈珲蝈茆彗轭骈珲蝈垧茆彗轭沐铘弪茆彗轭糸膪痖泗躜妪垠豉戾紧栝汶筱犰褰爱递茕蜥ò癌ú癌ú卑ò卑ò癌茕蜥ū癌ū穿ú穿茕蜥ò畅ú畅茕蜥ū博ú博茕蜥ò暴ú暴茕蜥ū穿ū旦ò旦茕蜥ò订ú订茕蜥ò珐ú珐茕蜥ò俯ú俯茕蜥ū卑ū供ú供苠钿糸膪痖泗躜妪苠钿沐铘弪茔狃糸镱蜥钿镯麸麇镦箝卑莒徕屐骈绾麸麇虮褒苠钿骈珲蝈族泔躅翳铛礅弪镦溟骀弪孱麽麸怩殪赭泔祯眍麸麇鏖翳忪镢塍箬秣轭崎珲蝈茯彐骈绾忪镢塍族钺礤翳忪镢鏖翳戾趑弪蝇脂痊瘫滩坛犷檀骝镯戾骠麸蜷玷衄躔麸怙趑镯骑忪镢塍犷麇徜翳铛礅弪镦翳泔祯眍轭麒殂翳忪镢箝趔涉麇潋狩扉铄狒翳桢殓梏ゎ麇鏖祆栳鲥翳蝈痫篌殁殪轸殄ㄆ殓躜茯彐骈绾麸麇蝮┊澡扉铄滹弩铒轭翦蝮邈犷忪镢箴邈殄ぬ踏┈轸轭翦蝮邈趔忪镢矧滩轭翳箦泔钿泔祯眍犷铒忪镢轭翳骈蝮泔祯眍箴邈殄ぬ肖矧轸轭翦蝮邈趔忪镢矧瘫轭翳骈蝮泔祯眍犷铒忪镢轭翳箦泔钿泔祯眍箴邈殄ば踏┊物翦翳狒殒翳扉铄轭翦蝮邈趔坛轭翳骈蝮泔祯眍犷铒忪镢轭翳箦泔钿泔祯眍翳轶忮祜铉麸翳箴邈殄烫镦箝ゎ堡深翳箴邈殒殂狒轱翳弪轶簌礅镬茔镯磲钿骘翳箝镦翳麸麇虍族犰箫栳鲥簌礅镬骘忪镢塍麒殂狎镦箝爱儒蝈轶箴邈殒殂狒轱骘翳箴邈殄螽茆彗轭屮犴痨妪ē楸祜徜ㄓ疱汩弩─ē椴箴邈烫接蹴ㄅ痼殪镱序镤烫颖硬┈序镤烫醛序镤烫直植┈序镤绦颖┈序镤刑硬┈序镤绦坛┈序镤烫颖檀┈序镤烫坛硬┈序镤刑檀┅绦接蹴序镤烫滩┈序镤刑植┈序镤烫颖植┅刑接蹴序镤烫瘫┈序镤绦直┈序镤烫直硬┅颖脚痼殪镱硬脚痼殪镱直脚痼殪镱植脚痼殪镱冉硼箝祜瞵瘫脚痼殪镱滩脚痼殪镱坛脚痼殪镱檀脚痼殪镱荬苠钿屮犴痨妪族汜扉篝翳麸麇蝮镦箝箬秣轭崎珲蝈茯彐骈绾麸麇蝮昌┊茆彗轭屮犴痨妪ē槌扉篝唧疱汩弩ㄌ态箴邈博ē榇磲皎灬礅溽ㄛ孑蝈篝ㄦ灬趑孱ㄦ┈畅┈铋沐咪轶皎ォ┗ē锎圹颖硬颖硬莠廴颖硬莠塾爆硬容廴容壑爆植莠厶铂颖莠塾爆植颖莠厶爆硬莠壑爆硬硬莠塾爆檀莠厶超硬葺苠钿屮犴痨妪向汨镲箦蜥钿镯麸麇镦箝卑箬秣轭崎珲蝈茯彐骈绾麸麇虮褒┊茆彗轭屮犴痨妪ē榈箦戾泗哝蝻磉箴邈殄蟥烫箴邈卑─ē槎蝈篝ㄦ灬趑孱铋沐咪轶皎ォ┈北┗ē锒塾爆硬直硬硬直硬檀痊痊瘫硬苠钿屮犴痨妪阵轭翳珏铄蜥糸铉骢钽糸镱麇汜骈钿犷屮痨殂轸骘蝽蹯骘翳铛礅弪镦麸麇蝮镦箝ゎぎ娱钽翳簌篝屙轶泔眇扉汜翦麇躞球堍镡铄忉箦麸屮痱弩ぬ台舂ぎ茆彗轭屮犴痨妪ē榉磲脲扉篝ㄣ秕铘唧疱汩弩ㄌ态箴邈椹楝艾旦ē锓郾铂北创备宫饭篙ē楦羼蠛珂咤聃狒轱铙箴邈舂ē楣烫咤窈珂咤痱弩蟥羼蟋烫舂躞暹珧镡铄蚪趄蹂┗ē锕ō艮抄氮艮箔唱臬暴烫舂舡ē楸癌烫唑邈犰珏襁麸唑邈ㄌ踢羼烫舂┗ē锉癌垲莪唱垲陛氮垲草垲齿ē楸暴烫咤痨殂轸箫祧暹蝈悒烫唑邈垲莠郯萁爆郾萁铂鄄萁北┗ē锉暴垲ō暴揞搏篑螋ǖ┇博揞ǔ篑螋ǖ┇旦舶ú篑螋ǖ┅揞ǔ篑螋ǖ┉旦舶苠钿屮犴痨妪麒殂轶い啕铨杰骝徙莒彐舁避蜷玷舂摞铨昌苕蜥沱莒彐舁荏耱酐谍曹蜷玷舂摞铨墁莒彐舁耻荏耱酐谍弟蜷玷舂舶苕蜥沱莒彐舁箔荏耱酐谍茯殓梏摞铨墁莒彐舁耻荏耱酐谍弟蜷玷舂舶い茆彗轭翳邂殁扉镧蜥痂卑茆殁轸屙歪歪轫泔眇豸弪犰珏怛簌篝屙芴晌他梏麴函磲轫岙箫躜沐骘蜱瀹铄舣茆殁轸屙旋熊э禊岈钱苠孙礅轭狒矧轶汨令徼焘弩糸眄躅珏孳Ⅴ球躔疱瞵球狃桢躅汨屙轶汨皱蜮轭漉铉孱零翎歪翳陡ū钩珐贝淡驳串茆殁轸屙数曙犰廉苠疹翳堙屣蜷泔礅轭狒镩蝈溴筌у蜷弩骘蝽屐戾簖龄鲠钽弩轭歪翳屙狒殂床ū垢暴杯覆茆殁轸屙绿听洛蜱弪镱飘提忮祆钱体蝻貘挟苠蔑礅轭狒矧獒羽邈殄犷则邋涕脲郁蝓泗躜弩蓬泫沆镳邃獒镦歪翳屙狒殂犷婶琉痨殂狒轱铙斗冕礅蜷溏疹轹弪箝豉序弩蟋冕礅蜷溏ū构俯茆殁轸屙撩儒眄邈脲耶阴忮彤苠领滹颦蔑礅轭狒令身痨屙孱翎糸镱镦蔑礅轭狒矧獒羽邈殄簖苘芴晌他梏麴函鼢鳟蜷筱躅榄扉铤徙狒疱镳戾桢眄邈脲犰滹虔泔礅轭狒茆殁轸屙兔育腻铋箦廉孽麸躜僧陂眄弪磲铑挟苠皿王辛疳汶徵骘泔躅糸铉犷蜥钿镯禊珏铄蜥糸铉泔礅轭狒矧獒篝蝓泗躜弩深序镢邋溟铉镦菩恿莽垢惫垢惫淡舶串茆殁轸屙兔芴晌他梏麴函眭疳洵泔礅轭狒箫躜沐骘蜱瀹铄舣茆殁轸屙筢珏芴晌他梏麴函筢珏磲翳矧绡茆殁轸屙忪轶簖芴晌他梏麴函鼢鳟翥螽桴舢骈语骠麽蝈忪轶蟑轭溴梏盱苠钿翳邂殁扉镧蜥痂苠钿滹沲礤铘田汜熳矧潴令潋尻诛滹痖鲥镬泔礅轭狒矧殂镬岌磲轫狨麸盹蝠栝箜田汜熳矧潴盹铒黹犰篚怏