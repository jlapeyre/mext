/* dtest1 must take no arguments */

/* Define this to see if it collides with option `extra' */
(kill(extra), extra:13)$
13;

dtest1()$
true;

/* Requires exactly zero arguments */
errcatch([dtest1(0)])$
[];

/* Return unevaluated form instead of an error */
(set_match_form('dtest1), dtest1(0))$
'dtest1(0);

unset_match_form('dtest1)$
done;

/* Different definition syntax */
dtest1a()$
true;

errcatch([dtest1a(0)])$
[];

/* dtest2 must take one argument */
dtest2('dog)$
'dog;

errcatch([dtest2()])$
[];

errcatch([dtest2(1,3)])$
[];

/* dtest3 must take non-neg int argument */

dtest3(0)$
0;

dtest3(1)$
1;

dtest3(101)$
101;

dtest3(10^5)$
10^5;

errcatch([dtest3()])$
[];

errcatch([dtest3(1,2)])$
[];

errcatch([dtest3(-1)])$
[];

errcatch([dtest3(1.0)])$
[];

errcatch([dtest3('dog)])$
[];

/* match_form is set. So wrong argument should return input form
   I put some garbage in check-and-error, and no other tests fail.
*/
dtest3b(-1)$
'dtest3b(-1);

/* dtest4 must take int in [-1,0,1] */

dtest4(-1)$
-1;

dtest4(0)$
0;

dtest4(1)$
1;

errcatch([dtest4(-2)])$
[];

errcatch([dtest4(101)])$
[];

errcatch([dtest4(0.0)])$
[];

/* dtest5 takes an option */

dtest5(1)$
[1,false,false];

dtest5(1,extra->'dog)$
[1,'dog,true];

  /* We cannot quote the option name */
errcatch([dtest5(1,'extra->3)])$
[];

 /* dtest6 takes 2 opts. We can pass options in a list */
dtest6(1,[extra->3,opt2->4])$
[1,3,true,4,true];

block([optlist : [extra->3,opt2->"dog"]],
  dtest6(1,optlist))$
[1,3,true,"dog",true];

/* There is a global variable `extra'. But
 this `->'  means `Rule' which quotes the LHS.*/
block([optlist : [extra->3,opt2->"dog"]],
  append([extra], dtest6(1,optlist)))$
[13,1,3,true,"dog",true];

/* Use options with lisp symbol name for option not the same as option name */
dtest7()$
[true,false];

dtest7(myopt->false)$
[false,true];

/* Not a boolean value */
dtest7(myopt->3)$
'dtest7(Rule(myopt,3));

/* takes no normal args */
dtest7(3)$
'dtest7(3);

/* Test &aux in lambda list */
dtest8('giraffe)$
'giraffe;

/* Test overriding set_match_form with option */

(unset_match_form('dtest9), dtest9(3))$
[3,false,false];

errcatch([dtest9('cat)])$
[];

dtest9(3,match->true)$
[3,true,true];

dtest9('cat,match->true)$
'dtest9(cat, Rule(match, true));

errcatch([dtest9('cat,match->false)])$
[];

dtest9(37,match->false)$
[37,false,true];

(set_match_form('dtest9), dtest9(0))$
[0,false,false];

dtest9('cat)$
'dtest9(cat);

dtest9('girrafe,match->true)$
'dtest9(girrafe, Rule(match, true))

errcatch([dtest9('cat,match->false)])$
[];

kill(extra);
done$
