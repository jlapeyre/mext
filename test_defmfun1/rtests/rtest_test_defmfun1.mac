/* dtest1 must take no arguments */

/* Define this to see if it collides with option `extra' */
(kill(extra), extra:13)$
13;

dtest1()$
true;

/* Requires exactly zero arguments */
(errcatch(dtest1(0)), error_code)$
args_too_many;

/* Return unevaluated form instead of an error */
(set_match_form('dtest1), dtest1(0))$
'dtest1(0);

unset_match_form('dtest1)$
done;

/* Different definition syntax */
dtest1a()$
true;

(errcatch(dtest1a(0)),error_code)$
args_too_many;

/* dtest2 must take one argument */
dtest2('dog)$
'dog;

(errcatch(dtest2()),error_code)$
args_too_few;

(errcatch([dtest2(1,3)]), error_code)$
args_too_many;

/* dtest3 must take non-neg int argument */

dtest3(0)$
0;

dtest3(1)$
1;

dtest3(101)$
101;

dtest3(10^5)$
10^5;

(errcatch(dtest3()),error_code)$
args_too_few;

(errcatch([dtest3(1,2)]), error_code)$
args_too_many;

(errcatch(dtest3(-1)), error_code)$
chk_non_neg_int;

(errcatch(dtest3(1.0)), error_code)$
chk_non_neg_int;

(errcatch(dtest3('dog)), error_code)$
chk_non_neg_int;

/* match_form is set. So wrong argument should return input form
   I put some garbage in check-and-error, and no other tests fail.
*/
dtest3b(-1)$
'dtest3b(-1);

/* dtest4 must take int in [-1,0,1] */

dtest4(-1)$
-1;

dtest4(0)$
0;

dtest4(1)$
1;

(errcatch(dtest4(-2)), error_code)$
chk_int_range;

(errcatch(dtest4(101)), error_code)$
chk_int_range;

(errcatch(dtest4(0.0)), error_code)$
chk_int_range;

/* dtest5 takes an option */

dtest5(1)$
[1,false,false];

dtest5(1,extra->'dog)$
[1,'dog,true];

  /* We cannot quote the option name */
(errcatch(dtest5(1,'extra->3)), error_code)$
defmfun1_invalid_opt_name;

 /* dtest6 takes 2 opts. We can pass options in a list */
dtest6(1,[extra->3,opt2->4])$
[1,3,true,4,true];

block([optlist : [extra->3,opt2->"dog"]],
  dtest6(1,optlist))$
[1,3,true,"dog",true];

/* There is a global variable `extra'. But
 this `->'  means `Rule' which quotes the LHS.*/
block([optlist : [extra->3,opt2->"dog"]],
  append([extra], dtest6(1,optlist)))$
[13,1,3,true,"dog",true];

/* Use options with lisp symbol name for option not the same as option name */
dtest7()$
[true,false];

dtest7(myopt->false)$
[false,true];

/* Not a boolean value */
dtest7(myopt->3)$
'dtest7(Rule(myopt,3));

/* takes no normal args */
dtest7(3)$
'dtest7(3);

/* Test &aux in lambda list */
dtest8('giraffe)$
'giraffe;

/* Test overriding set_match_form with option */

(unset_match_form('dtest9), dtest9(3))$
[3,false,false];

(errcatch(dtest9('cat)), error_code)$
chk_number;

dtest9(3,match->true)$
[3,true,true];

dtest9('cat,match->true)$
'dtest9(cat, Rule(match, true));

(errcatch(dtest9('cat,match->false)), error_code)$
chk_number;

dtest9(37,match->false)$
[37,false,true];

(errcatch(dtest9(101,102)), error_code)$
args_too_many;

dtest9(101,102,match->true)$
'dtest9(101, 102, Rule(match, true));

 /* Now set_match_form and try them again */
(set_match_form('dtest9), dtest9(0))$
[0,false,false];

dtest9('cat)$
'dtest9(cat);

dtest9('girrafe,match->true)$
'dtest9(girrafe, Rule(match, true));

(errcatch(dtest9('cat,match->false)), error_code)$
chk_number;

dtest9(111,222,match->true)$
'dtest9(111, 222, Rule(match, true));

/* dtest10 takes one argument. But checking for number of args is disabled. */
dtest10(1)$
1;

dtest10()$
false;

dtest10(3,4)$
3;

/* Collect opt arguments either fast or slow */
/* One required argument; and it is missing. */

(errcatch(dtest11(opt1->7)), error_code)$
args_too_few;

/* Defined with ( :fast-opt ); so the opt is mistaken for an argument */
dtest11a(opt1->7)$
'Rule(opt1, 7);

/* This function takes an arbitary number of args. */
dtest12("cat","dog")$
["cat","dog"];

/* All args must be strings */
(errcatch(dtest12("cat",3)), error_code)$
chk_string;

kill(extra);
done$
